# Database Migrations and Seeding

## Overview

Database migrations and seeding are essential practices for managing database schema changes and populating databases with initial or test data. This topic demonstrates how to create, run, and manage migrations in PostgreSQL using TypeORM, and how to seed databases with realistic e-commerce data that respects relationships.

## Learning Objectives

- Understand database migration concepts and workflows
- Create TypeORM migrations for PostgreSQL schema changes
- Implement database seeding with related data
- Generate realistic e-commerce data with proper relationships
- Handle migration rollbacks and schema versioning
- Automate database setup for development and testing

## Migration Workflow Overview

### Database Migration Lifecycle

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ              MIGRATION LIFECYCLE                       ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                         ‚îÇ
‚îÇ  Development Workflow:                                 ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê‚îÇ
‚îÇ  ‚îÇ                                                     ‚îÇ‚îÇ
‚îÇ  ‚îÇ  1. Schema Changes                                  ‚îÇ‚îÇ
‚îÇ  ‚îÇ     ‚îÇ                                               ‚îÇ‚îÇ
‚îÇ  ‚îÇ     ‚ñº                                               ‚îÇ‚îÇ
‚îÇ  ‚îÇ  2. Generate Migration                              ‚îÇ‚îÇ
‚îÇ  ‚îÇ     ‚îÇ npm run migration:generate                     ‚îÇ‚îÇ
‚îÇ  ‚îÇ     ‚ñº                                               ‚îÇ‚îÇ
‚îÇ  ‚îÇ  3. Review Generated SQL                            ‚îÇ‚îÇ
‚îÇ  ‚îÇ     ‚îÇ                                               ‚îÇ‚îÇ
‚îÇ  ‚îÇ     ‚ñº                                               ‚îÇ‚îÇ
‚îÇ  ‚îÇ  4. Run Migration                                   ‚îÇ‚îÇ
‚îÇ  ‚îÇ     ‚îÇ npm run migration:run                          ‚îÇ‚îÇ
‚îÇ  ‚îÇ     ‚ñº                                               ‚îÇ‚îÇ
‚îÇ  ‚îÇ  5. Test Changes                                    ‚îÇ‚îÇ
‚îÇ  ‚îÇ                                                     ‚îÇ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò‚îÇ
‚îÇ                                                         ‚îÇ
‚îÇ  Migration States:                                     ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê‚îÇ
‚îÇ  ‚îÇ                                                     ‚îÇ‚îÇ
‚îÇ  ‚îÇ  Pending    ‚Üí    Running    ‚Üí    Completed          ‚îÇ‚îÇ
‚îÇ  ‚îÇ     ‚îÇ               ‚îÇ               ‚îÇ               ‚îÇ‚îÇ
‚îÇ  ‚îÇ     ‚ñº               ‚ñº               ‚ñº               ‚îÇ‚îÇ
‚îÇ  ‚îÇ  Not Applied    Executing      Successfully         ‚îÇ‚îÇ
‚îÇ  ‚îÇ                                Applied              ‚îÇ‚îÇ
‚îÇ  ‚îÇ                                                     ‚îÇ‚îÇ
‚îÇ  ‚îÇ  Rollback   ‚Üê    Error      ‚Üê    Failed             ‚îÇ‚îÇ
‚îÇ  ‚îÇ     ‚îÇ               ‚îÇ               ‚îÇ               ‚îÇ‚îÇ
‚îÇ  ‚îÇ     ‚ñº               ‚ñº               ‚ñº               ‚îÇ‚îÇ
‚îÇ  ‚îÇ  Reverted      Needs Fix      Requires             ‚îÇ‚îÇ
‚îÇ  ‚îÇ                               Manual Fix           ‚îÇ‚îÇ
‚îÇ  ‚îÇ                                                     ‚îÇ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò‚îÇ
‚îÇ                                                         ‚îÇ
‚îÇ  Database Schema Versioning:                          ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê‚îÇ
‚îÇ  ‚îÇ migrations/                                         ‚îÇ‚îÇ
‚îÇ  ‚îÇ ‚îú‚îÄ‚îÄ 1670000001000-CreateUserTable.ts               ‚îÇ‚îÇ
‚îÇ  ‚îÇ ‚îú‚îÄ‚îÄ 1670000002000-CreateCategoryTable.ts           ‚îÇ‚îÇ
‚îÇ  ‚îÇ ‚îú‚îÄ‚îÄ 1670000003000-CreateProductTable.ts            ‚îÇ‚îÇ
‚îÇ  ‚îÇ ‚îú‚îÄ‚îÄ 1670000004000-CreateOrderTable.ts              ‚îÇ‚îÇ
‚îÇ  ‚îÇ ‚îú‚îÄ‚îÄ 1670000005000-AddUserProfileRelation.ts        ‚îÇ‚îÇ
‚îÇ  ‚îÇ ‚îî‚îÄ‚îÄ 1670000006000-AddProductCategoryRelation.ts    ‚îÇ‚îÇ
‚îÇ  ‚îÇ                                                     ‚îÇ‚îÇ
‚îÇ  ‚îÇ Each migration has:                                 ‚îÇ‚îÇ
‚îÇ  ‚îÇ ‚Ä¢ Timestamp prefix (ensures order)                 ‚îÇ‚îÇ
‚îÇ  ‚îÇ ‚Ä¢ Descriptive name                                  ‚îÇ‚îÇ
‚îÇ  ‚îÇ ‚Ä¢ Up() method (apply changes)                       ‚îÇ‚îÇ
‚îÇ  ‚îÇ ‚Ä¢ Down() method (rollback changes)                  ‚îÇ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## Exercise: Database Migration Implementation

### Step 1: Migration Configuration Setup

**File: section-3/analytics-service/src/config/migration.config.ts**

```typescript
import { DataSource } from "typeorm";
import { config } from "dotenv";

// Load environment variables
config();

export const AppDataSource = new DataSource({
  type: "postgres",
  host: process.env.POSTGRES_HOST || "localhost",
  port: parseInt(process.env.POSTGRES_PORT) || 5432,
  username: process.env.POSTGRES_USER || "postgres",
  password: process.env.POSTGRES_PASSWORD || "password123",
  database: process.env.POSTGRES_DB || "microservices_analytics",

  // Entity locations
  entities: ["src/entities/postgres/*.entity.ts"],

  // Migration settings
  migrations: ["src/migrations/*.ts"],
  migrationsTableName: "migrations_history",

  // Logging for debugging
  logging: ["query", "error", "schema"],

  // Development settings
  synchronize: false, // Always false in production
  dropSchema: false,

  // CLI settings for migration generation
  cli: {
    migrationsDir: "src/migrations",
  },
});

// Initialize data source
AppDataSource.initialize()
  .then(() => {
    console.log("Data Source has been initialized!");
  })
  .catch((err) => {
    console.error("Error during Data Source initialization:", err);
  });
```

**File: section-3/analytics-service/package.json** (add migration scripts)

```json
{
  "scripts": {
    "migration:generate": "typeorm-ts-node-esm migration:generate -d src/config/migration.config.ts",
    "migration:create": "typeorm-ts-node-esm migration:create -d src/config/migration.config.ts",
    "migration:run": "typeorm-ts-node-esm migration:run -d src/config/migration.config.ts",
    "migration:revert": "typeorm-ts-node-esm migration:revert -d src/config/migration.config.ts",
    "migration:show": "typeorm-ts-node-esm migration:show -d src/config/migration.config.ts",
    "seed:run": "ts-node src/seeds/run-seeder.ts",
    "seed:reset": "ts-node src/seeds/reset-database.ts",
    "db:setup": "npm run migration:run && npm run seed:run",
    "db:reset": "npm run seed:reset && npm run migration:run && npm run seed:run"
  }
}
```

### Step 2: Create Initial Migrations

**File: section-3/analytics-service/src/migrations/1670000001000-CreateUserTable.ts**

```typescript
import { MigrationInterface, QueryRunner, Table, Index } from "typeorm";

export class CreateUserTable1670000001000 implements MigrationInterface {
  name = "CreateUserTable1670000001000";

  public async up(queryRunner: QueryRunner): Promise<void> {
    // Create users table
    await queryRunner.createTable(
      new Table({
        name: "users",
        columns: [
          {
            name: "id",
            type: "uuid",
            isPrimary: true,
            generationStrategy: "uuid",
            default: "gen_random_uuid()",
          },
          {
            name: "first_name",
            type: "varchar",
            length: "100",
            isNullable: false,
          },
          {
            name: "last_name",
            type: "varchar",
            length: "100",
            isNullable: false,
          },
          {
            name: "email",
            type: "varchar",
            length: "255",
            isUnique: true,
            isNullable: false,
          },
          {
            name: "phone_number",
            type: "varchar",
            length: "20",
            isNullable: false,
          },
          {
            name: "date_of_birth",
            type: "date",
            isNullable: false,
          },
          {
            name: "role",
            type: "enum",
            enum: ["user", "admin"],
            default: "'user'",
          },
          {
            name: "created_at",
            type: "timestamp",
            default: "CURRENT_TIMESTAMP",
          },
          {
            name: "updated_at",
            type: "timestamp",
            default: "CURRENT_TIMESTAMP",
          },
        ],
      }),
      true
    );

    // Create indexes for better query performance
    await queryRunner.createIndex(
      "users",
      new Index("IDX_USER_EMAIL", ["email"])
    );
    await queryRunner.createIndex(
      "users",
      new Index("IDX_USER_ROLE", ["role"])
    );
    await queryRunner.createIndex(
      "users",
      new Index("IDX_USER_CREATED_AT", ["created_at"])
    );

    // Create trigger for updated_at column
    await queryRunner.query(`
      CREATE OR REPLACE FUNCTION update_updated_at_column()
      RETURNS TRIGGER AS $$
      BEGIN
        NEW.updated_at = CURRENT_TIMESTAMP;
        RETURN NEW;
      END;
      $$ language 'plpgsql';
    `);

    await queryRunner.query(`
      CREATE TRIGGER update_users_updated_at 
      BEFORE UPDATE ON users 
      FOR EACH ROW 
      EXECUTE FUNCTION update_updated_at_column();
    `);
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    // Drop trigger and function
    await queryRunner.query(
      "DROP TRIGGER IF EXISTS update_users_updated_at ON users"
    );
    await queryRunner.query(
      "DROP FUNCTION IF EXISTS update_updated_at_column()"
    );

    // Drop table (indexes will be dropped automatically)
    await queryRunner.dropTable("users");
  }
}
```

**File: section-3/analytics-service/src/migrations/1670000002000-CreateCategoryTable.ts**

```typescript
import { MigrationInterface, QueryRunner, Table, Index } from "typeorm";

export class CreateCategoryTable1670000002000 implements MigrationInterface {
  name = "CreateCategoryTable1670000002000";

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.createTable(
      new Table({
        name: "categories",
        columns: [
          {
            name: "id",
            type: "uuid",
            isPrimary: true,
            generationStrategy: "uuid",
            default: "gen_random_uuid()",
          },
          {
            name: "name",
            type: "varchar",
            length: "100",
            isUnique: true,
            isNullable: false,
          },
          {
            name: "description",
            type: "text",
            isNullable: true,
          },
          {
            name: "image",
            type: "varchar",
            length: "255",
            isNullable: true,
          },
          {
            name: "is_active",
            type: "boolean",
            default: true,
          },
          {
            name: "created_at",
            type: "timestamp",
            default: "CURRENT_TIMESTAMP",
          },
          {
            name: "updated_at",
            type: "timestamp",
            default: "CURRENT_TIMESTAMP",
          },
        ],
      }),
      true
    );

    // Create indexes
    await queryRunner.createIndex(
      "categories",
      new Index("IDX_CATEGORY_NAME", ["name"])
    );
    await queryRunner.createIndex(
      "categories",
      new Index("IDX_CATEGORY_ACTIVE", ["is_active"])
    );

    // Add updated_at trigger
    await queryRunner.query(`
      CREATE TRIGGER update_categories_updated_at 
      BEFORE UPDATE ON categories 
      FOR EACH ROW 
      EXECUTE FUNCTION update_updated_at_column();
    `);
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      "DROP TRIGGER IF EXISTS update_categories_updated_at ON categories"
    );
    await queryRunner.dropTable("categories");
  }
}
```

**File: section-3/analytics-service/src/migrations/1670000003000-CreateProductTable.ts**

```typescript
import { MigrationInterface, QueryRunner, Table, Index } from "typeorm";

export class CreateProductTable1670000003000 implements MigrationInterface {
  name = "CreateProductTable1670000003000";

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.createTable(
      new Table({
        name: "products",
        columns: [
          {
            name: "id",
            type: "uuid",
            isPrimary: true,
            generationStrategy: "uuid",
            default: "gen_random_uuid()",
          },
          {
            name: "title",
            type: "varchar",
            length: "200",
            isNullable: false,
          },
          {
            name: "description",
            type: "text",
            isNullable: false,
          },
          {
            name: "summary",
            type: "text",
            isNullable: true,
          },
          {
            name: "price",
            type: "decimal",
            precision: 10,
            scale: 2,
            isNullable: false,
          },
          {
            name: "currency",
            type: "varchar",
            length: "3",
            default: "'USD'",
          },
          {
            name: "images",
            type: "json",
            isNullable: true,
          },
          {
            name: "tags",
            type: "simple-array",
            isNullable: true,
          },
          {
            name: "stock_quantity",
            type: "integer",
            default: 0,
          },
          {
            name: "is_active",
            type: "boolean",
            default: true,
          },
          {
            name: "created_at",
            type: "timestamp",
            default: "CURRENT_TIMESTAMP",
          },
          {
            name: "updated_at",
            type: "timestamp",
            default: "CURRENT_TIMESTAMP",
          },
        ],
      }),
      true
    );

    // Create indexes for common queries
    await queryRunner.createIndex(
      "products",
      new Index("IDX_PRODUCT_TITLE", ["title"])
    );
    await queryRunner.createIndex(
      "products",
      new Index("IDX_PRODUCT_PRICE", ["price"])
    );
    await queryRunner.createIndex(
      "products",
      new Index("IDX_PRODUCT_ACTIVE", ["is_active"])
    );
    await queryRunner.createIndex(
      "products",
      new Index("IDX_PRODUCT_STOCK", ["stock_quantity"])
    );

    // Full-text search index for title and description
    await queryRunner.query(`
      CREATE INDEX IDX_PRODUCT_SEARCH 
      ON products 
      USING gin(to_tsvector('english', title || ' ' || description));
    `);

    // Add updated_at trigger
    await queryRunner.query(`
      CREATE TRIGGER update_products_updated_at 
      BEFORE UPDATE ON products 
      FOR EACH ROW 
      EXECUTE FUNCTION update_updated_at_column();
    `);
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      "DROP TRIGGER IF EXISTS update_products_updated_at ON products"
    );
    await queryRunner.query("DROP INDEX IF EXISTS IDX_PRODUCT_SEARCH");
    await queryRunner.dropTable("products");
  }
}
```

**File: section-3/analytics-service/src/migrations/1670000004000-CreateUserProfileTable.ts**

```typescript
import {
  MigrationInterface,
  QueryRunner,
  Table,
  ForeignKey,
  Index,
} from "typeorm";

export class CreateUserProfileTable1670000004000 implements MigrationInterface {
  name = "CreateUserProfileTable1670000004000";

  public async up(queryRunner: QueryRunner): Promise<void> {
    // Create user_profiles table
    await queryRunner.createTable(
      new Table({
        name: "user_profiles",
        columns: [
          {
            name: "id",
            type: "uuid",
            isPrimary: true,
            generationStrategy: "uuid",
            default: "gen_random_uuid()",
          },
          {
            name: "bio",
            type: "text",
            isNullable: true,
          },
          {
            name: "avatar",
            type: "varchar",
            length: "255",
            isNullable: true,
          },
          {
            name: "preferences",
            type: "json",
            isNullable: true,
          },
          {
            name: "address",
            type: "json",
            isNullable: true,
          },
          {
            name: "created_at",
            type: "timestamp",
            default: "CURRENT_TIMESTAMP",
          },
          {
            name: "updated_at",
            type: "timestamp",
            default: "CURRENT_TIMESTAMP",
          },
        ],
      }),
      true
    );

    // Add profile_id column to users table (one-to-one relationship)
    await queryRunner.query(`
      ALTER TABLE users 
      ADD COLUMN profile_id uuid UNIQUE
    `);

    // Create foreign key constraint
    await queryRunner.createForeignKey(
      "users",
      new ForeignKey({
        columnNames: ["profile_id"],
        referencedTableName: "user_profiles",
        referencedColumnNames: ["id"],
        onDelete: "SET NULL",
        onUpdate: "CASCADE",
      })
    );

    // Create index for JSON fields queries
    await queryRunner.query(`
      CREATE INDEX IDX_USER_PROFILE_ADDRESS_CITY 
      ON user_profiles 
      USING gin((address->>'city'))
    `);

    // Add updated_at trigger
    await queryRunner.query(`
      CREATE TRIGGER update_user_profiles_updated_at 
      BEFORE UPDATE ON user_profiles 
      FOR EACH ROW 
      EXECUTE FUNCTION update_updated_at_column();
    `);
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    // Drop foreign key and column from users table
    await queryRunner.query(
      "ALTER TABLE users DROP COLUMN IF EXISTS profile_id"
    );

    // Drop trigger
    await queryRunner.query(
      "DROP TRIGGER IF EXISTS update_user_profiles_updated_at ON user_profiles"
    );

    // Drop table
    await queryRunner.dropTable("user_profiles");
  }
}
```

**File: section-3/analytics-service/src/migrations/1670000005000-CreateOrdersAndItems.ts**

```typescript
import {
  MigrationInterface,
  QueryRunner,
  Table,
  ForeignKey,
  Index,
} from "typeorm";

export class CreateOrdersAndItems1670000005000 implements MigrationInterface {
  name = "CreateOrdersAndItems1670000005000";

  public async up(queryRunner: QueryRunner): Promise<void> {
    // Create orders table
    await queryRunner.createTable(
      new Table({
        name: "orders",
        columns: [
          {
            name: "id",
            type: "uuid",
            isPrimary: true,
            generationStrategy: "uuid",
            default: "gen_random_uuid()",
          },
          {
            name: "user_id",
            type: "uuid",
            isNullable: false,
          },
          {
            name: "status",
            type: "enum",
            enum: [
              "pending",
              "paid",
              "processing",
              "shipped",
              "delivered",
              "cancelled",
            ],
            default: "'pending'",
          },
          {
            name: "subtotal",
            type: "decimal",
            precision: 10,
            scale: 2,
            isNullable: false,
          },
          {
            name: "tax",
            type: "decimal",
            precision: 10,
            scale: 2,
            default: 0,
          },
          {
            name: "shipping",
            type: "decimal",
            precision: 10,
            scale: 2,
            default: 0,
          },
          {
            name: "total",
            type: "decimal",
            precision: 10,
            scale: 2,
            isNullable: false,
          },
          {
            name: "currency",
            type: "varchar",
            length: "3",
            default: "'USD'",
          },
          {
            name: "shipping_address",
            type: "json",
            isNullable: true,
          },
          {
            name: "created_at",
            type: "timestamp",
            default: "CURRENT_TIMESTAMP",
          },
          {
            name: "updated_at",
            type: "timestamp",
            default: "CURRENT_TIMESTAMP",
          },
        ],
      }),
      true
    );

    // Create order_items table
    await queryRunner.createTable(
      new Table({
        name: "order_items",
        columns: [
          {
            name: "id",
            type: "uuid",
            isPrimary: true,
            generationStrategy: "uuid",
            default: "gen_random_uuid()",
          },
          {
            name: "order_id",
            type: "uuid",
            isNullable: false,
          },
          {
            name: "product_id",
            type: "uuid",
            isNullable: false,
          },
          {
            name: "quantity",
            type: "integer",
            isNullable: false,
          },
          {
            name: "price",
            type: "decimal",
            precision: 10,
            scale: 2,
            isNullable: false,
          },
          {
            name: "total",
            type: "decimal",
            precision: 10,
            scale: 2,
            isNullable: false,
          },
          {
            name: "created_at",
            type: "timestamp",
            default: "CURRENT_TIMESTAMP",
          },
        ],
      }),
      true
    );

    // Create foreign key constraints
    await queryRunner.createForeignKey(
      "orders",
      new ForeignKey({
        columnNames: ["user_id"],
        referencedTableName: "users",
        referencedColumnNames: ["id"],
        onDelete: "CASCADE",
        onUpdate: "CASCADE",
      })
    );

    await queryRunner.createForeignKey(
      "order_items",
      new ForeignKey({
        columnNames: ["order_id"],
        referencedTableName: "orders",
        referencedColumnNames: ["id"],
        onDelete: "CASCADE",
        onUpdate: "CASCADE",
      })
    );

    await queryRunner.createForeignKey(
      "order_items",
      new ForeignKey({
        columnNames: ["product_id"],
        referencedTableName: "products",
        referencedColumnNames: ["id"],
        onDelete: "RESTRICT",
        onUpdate: "CASCADE",
      })
    );

    // Create indexes for common queries
    await queryRunner.createIndex(
      "orders",
      new Index("IDX_ORDER_USER", ["user_id", "created_at"])
    );
    await queryRunner.createIndex(
      "orders",
      new Index("IDX_ORDER_STATUS", ["status"])
    );
    await queryRunner.createIndex(
      "orders",
      new Index("IDX_ORDER_TOTAL", ["total"])
    );

    await queryRunner.createIndex(
      "order_items",
      new Index("IDX_ORDER_ITEM_ORDER", ["order_id"])
    );
    await queryRunner.createIndex(
      "order_items",
      new Index("IDX_ORDER_ITEM_PRODUCT", ["product_id"])
    );

    // Add updated_at triggers
    await queryRunner.query(`
      CREATE TRIGGER update_orders_updated_at 
      BEFORE UPDATE ON orders 
      FOR EACH ROW 
      EXECUTE FUNCTION update_updated_at_column();
    `);
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(
      "DROP TRIGGER IF EXISTS update_orders_updated_at ON orders"
    );
    await queryRunner.dropTable("order_items");
    await queryRunner.dropTable("orders");
  }
}
```

**File: section-3/analytics-service/src/migrations/1670000006000-CreateProductCategoryRelation.ts**

```typescript
import {
  MigrationInterface,
  QueryRunner,
  Table,
  ForeignKey,
  Index,
} from "typeorm";

export class CreateProductCategoryRelation1670000006000
  implements MigrationInterface
{
  name = "CreateProductCategoryRelation1670000006000";

  public async up(queryRunner: QueryRunner): Promise<void> {
    // Create junction table for many-to-many relationship
    await queryRunner.createTable(
      new Table({
        name: "product_categories",
        columns: [
          {
            name: "product_id",
            type: "uuid",
            isNullable: false,
          },
          {
            name: "category_id",
            type: "uuid",
            isNullable: false,
          },
          {
            name: "created_at",
            type: "timestamp",
            default: "CURRENT_TIMESTAMP",
          },
        ],
      }),
      true
    );

    // Create composite primary key
    await queryRunner.createPrimaryKey("product_categories", [
      "product_id",
      "category_id",
    ]);

    // Create foreign key constraints
    await queryRunner.createForeignKey(
      "product_categories",
      new ForeignKey({
        columnNames: ["product_id"],
        referencedTableName: "products",
        referencedColumnNames: ["id"],
        onDelete: "CASCADE",
        onUpdate: "CASCADE",
      })
    );

    await queryRunner.createForeignKey(
      "product_categories",
      new ForeignKey({
        columnNames: ["category_id"],
        referencedTableName: "categories",
        referencedColumnNames: ["id"],
        onDelete: "CASCADE",
        onUpdate: "CASCADE",
      })
    );

    // Create indexes for efficient lookups
    await queryRunner.createIndex(
      "product_categories",
      new Index("IDX_PRODUCT_CATEGORY_PRODUCT", ["product_id"])
    );

    await queryRunner.createIndex(
      "product_categories",
      new Index("IDX_PRODUCT_CATEGORY_CATEGORY", ["category_id"])
    );
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.dropTable("product_categories");
  }
}
```

### Step 3: Database Seeding Implementation

**File: section-3/analytics-service/src/seeds/data-factory.ts**

```typescript
import { faker } from "@faker-js/faker";
import { User } from "../entities/postgres/user.entity";
import { UserProfile } from "../entities/postgres/user-profile.entity";
import { Category } from "../entities/postgres/category.entity";
import { Product } from "../entities/postgres/product.entity";
import { Order } from "../entities/postgres/order.entity";
import { OrderItem } from "../entities/postgres/order-item.entity";

export class DataFactory {
  // Generate user data
  static createUser(): Partial<User> {
    const firstName = faker.person.firstName();
    const lastName = faker.person.lastName();

    return {
      firstName,
      lastName,
      email: faker.internet.email({ firstName, lastName }),
      phoneNumber: faker.phone.number(),
      dateOfBirth: faker.date.birthdate({ min: 18, max: 80, mode: "age" }),
      role: faker.helpers.arrayElement(["user", "admin"] as const),
    };
  }

  // Generate user profile data
  static createUserProfile(): Partial<UserProfile> {
    return {
      bio: faker.lorem.paragraph(),
      avatar: faker.image.avatar(),
      preferences: {
        newsletter: faker.datatype.boolean(),
        notifications: faker.datatype.boolean(),
        theme: faker.helpers.arrayElement(["light", "dark"] as const),
      },
      address: {
        street: faker.location.streetAddress(),
        city: faker.location.city(),
        state: faker.location.state(),
        zipCode: faker.location.zipCode(),
        country: faker.location.country(),
      },
    };
  }

  // Generate category data
  static createCategories(): Partial<Category>[] {
    const categories = [
      { name: "Electronics", description: "Electronic devices and gadgets" },
      { name: "Clothing", description: "Fashion and apparel" },
      {
        name: "Home & Garden",
        description: "Home improvement and garden supplies",
      },
      { name: "Sports", description: "Sports and outdoor equipment" },
      { name: "Books", description: "Books and educational materials" },
      { name: "Toys", description: "Toys and games for all ages" },
      { name: "Health", description: "Health and beauty products" },
      { name: "Automotive", description: "Car accessories and parts" },
      { name: "Food", description: "Food and beverages" },
      { name: "Music", description: "Musical instruments and accessories" },
    ];

    return categories.map((cat) => ({
      ...cat,
      image: faker.image.url({ width: 300, height: 200, category: "products" }),
      isActive: faker.datatype.boolean(0.9), // 90% active
    }));
  }

  // Generate product data
  static createProduct(categoryIds: string[]): Partial<Product> {
    const productTypes = [
      "Smartphone",
      "Laptop",
      "Headphones",
      "T-Shirt",
      "Jeans",
      "Sneakers",
      "Book",
      "Chair",
      "Lamp",
      "Watch",
      "Camera",
      "Tablet",
      "Jacket",
      "Backpack",
      "Sunglasses",
      "Keyboard",
      "Mouse",
      "Monitor",
      "Desk",
      "Plant",
      "Mug",
      "Pillow",
      "Blanket",
      "Phone Case",
      "Charger",
    ];

    const productName = faker.helpers.arrayElement(productTypes);
    const brand = faker.company.name();

    return {
      title: `${brand} ${productName} ${faker.commerce.productAdjective()}`,
      description: faker.commerce.productDescription(),
      summary: faker.lorem.sentence(),
      price: parseFloat(faker.commerce.price({ min: 10, max: 2000 })),
      currency: "USD",
      images: Array.from({ length: faker.number.int({ min: 1, max: 5 }) }, () =>
        faker.image.url({ width: 600, height: 400, category: "products" })
      ),
      tags: Array.from({ length: faker.number.int({ min: 2, max: 6 }) }, () =>
        faker.commerce.productAdjective()
      ),
      stockQuantity: faker.number.int({ min: 0, max: 500 }),
      isActive: faker.datatype.boolean(0.85), // 85% active
    };
  }

  // Generate order data
  static createOrder(userId: string): Partial<Order> {
    const subtotal = parseFloat(faker.commerce.price({ min: 50, max: 1000 }));
    const tax = subtotal * 0.08; // 8% tax
    const shipping = parseFloat(faker.commerce.price({ min: 5, max: 25 }));
    const total = subtotal + tax + shipping;

    return {
      user: { id: userId } as any,
      status: faker.helpers.arrayElement([
        "pending",
        "paid",
        "processing",
        "shipped",
        "delivered",
      ] as const),
      subtotal,
      tax,
      shipping,
      total,
      currency: "USD",
      shippingAddress: {
        street: faker.location.streetAddress(),
        city: faker.location.city(),
        state: faker.location.state(),
        zipCode: faker.location.zipCode(),
        country: "USA",
      },
    };
  }

  // Generate order item data
  static createOrderItem(
    orderId: string,
    productId: string,
    productPrice: number
  ): Partial<OrderItem> {
    const quantity = faker.number.int({ min: 1, max: 5 });
    const price = productPrice;
    const total = quantity * price;

    return {
      order: { id: orderId } as any,
      product: { id: productId } as any,
      quantity,
      price,
      total,
    };
  }

  // Generate sample users with different patterns
  static generateSampleUsers(
    count: number
  ): { user: Partial<User>; profile: Partial<UserProfile> }[] {
    return Array.from({ length: count }, () => ({
      user: this.createUser(),
      profile: this.createUserProfile(),
    }));
  }

  // Generate realistic e-commerce data set
  static generateEcommerceDataSet() {
    return {
      users: this.generateSampleUsers(50), // 50 users with profiles
      categories: this.createCategories(), // 10 categories
      productsPerCategory: 20, // 20 products per category
      ordersPerUser: { min: 0, max: 8 }, // 0-8 orders per user
      itemsPerOrder: { min: 1, max: 6 }, // 1-6 items per order
    };
  }
}
```

**File: section-3/analytics-service/src/seeds/database-seeder.ts**

```typescript
import { DataSource } from "typeorm";
import { User } from "../entities/postgres/user.entity";
import { UserProfile } from "../entities/postgres/user-profile.entity";
import { Category } from "../entities/postgres/category.entity";
import { Product } from "../entities/postgres/product.entity";
import { Order } from "../entities/postgres/order.entity";
import { OrderItem } from "../entities/postgres/order-item.entity";
import { DataFactory } from "./data-factory";
import { faker } from "@faker-js/faker";

export class DatabaseSeeder {
  constructor(private dataSource: DataSource) {}

  async seed(): Promise<void> {
    console.log("üå± Starting database seeding...");

    try {
      // Get repositories
      const userRepo = this.dataSource.getRepository(User);
      const profileRepo = this.dataSource.getRepository(UserProfile);
      const categoryRepo = this.dataSource.getRepository(Category);
      const productRepo = this.dataSource.getRepository(Product);
      const orderRepo = this.dataSource.getRepository(Order);
      const orderItemRepo = this.dataSource.getRepository(OrderItem);

      // Clear existing data (in correct order to avoid foreign key conflicts)
      await orderItemRepo.delete({});
      await orderRepo.delete({});
      await productRepo.query("DELETE FROM product_categories");
      await productRepo.delete({});
      await categoryRepo.delete({});
      await userRepo.query("UPDATE users SET profile_id = NULL");
      await profileRepo.delete({});
      await userRepo.delete({});

      console.log("üóëÔ∏è  Cleared existing data");

      // 1. Seed Categories
      console.log("üìÇ Seeding categories...");
      const categoryData = DataFactory.createCategories();
      const categories = categoryRepo.create(categoryData);
      const savedCategories = await categoryRepo.save(categories);
      console.log(`‚úÖ Created ${savedCategories.length} categories`);

      // 2. Seed Users with Profiles
      console.log("üë• Seeding users and profiles...");
      const userDataSet = DataFactory.generateSampleUsers(50);
      const savedUsers: User[] = [];

      for (const userData of userDataSet) {
        // Create and save profile first
        const profile = profileRepo.create(userData.profile);
        const savedProfile = await profileRepo.save(profile);

        // Create user with profile reference
        const user = userRepo.create({
          ...userData.user,
          profile: savedProfile,
        });
        const savedUser = await userRepo.save(user);
        savedUsers.push(savedUser);
      }
      console.log(`‚úÖ Created ${savedUsers.length} users with profiles`);

      // 3. Seed Products
      console.log("üõçÔ∏è  Seeding products...");
      const products: Product[] = [];

      for (let i = 0; i < savedCategories.length; i++) {
        const category = savedCategories[i];

        // Create 15-25 products per category
        const productsCount = faker.number.int({ min: 15, max: 25 });

        for (let j = 0; j < productsCount; j++) {
          const productData = DataFactory.createProduct([category.id]);
          const product = productRepo.create(productData);

          // Randomly assign to 1-3 categories
          const categoryCount = faker.number.int({ min: 1, max: 3 });
          const selectedCategories = faker.helpers.arrayElements(
            savedCategories,
            categoryCount
          );

          product.categories = selectedCategories;
          products.push(product);
        }
      }

      const savedProducts = await productRepo.save(products);
      console.log(`‚úÖ Created ${savedProducts.length} products`);

      // 4. Seed Orders and Order Items
      console.log("üì¶ Seeding orders and order items...");
      let totalOrders = 0;
      let totalOrderItems = 0;

      for (const user of savedUsers) {
        // Each user gets 0-8 orders
        const orderCount = faker.number.int({ min: 0, max: 8 });

        for (let i = 0; i < orderCount; i++) {
          const orderData = DataFactory.createOrder(user.id);
          const order = orderRepo.create(orderData);
          order.user = user;

          // Set random created date in the past year
          order.createdAt = faker.date.past({ years: 1 });

          const savedOrder = await orderRepo.save(order);
          totalOrders++;

          // Add 1-6 items to each order
          const itemCount = faker.number.int({ min: 1, max: 6 });
          const orderProducts = faker.helpers.arrayElements(
            savedProducts,
            itemCount
          );

          let orderSubtotal = 0;
          const orderItems: OrderItem[] = [];

          for (const product of orderProducts) {
            const orderItemData = DataFactory.createOrderItem(
              savedOrder.id,
              product.id,
              Number(product.price)
            );

            const orderItem = orderItemRepo.create(orderItemData);
            orderItem.order = savedOrder;
            orderItem.product = product;

            orderSubtotal += Number(orderItem.total);
            orderItems.push(orderItem);
          }

          // Update order totals based on actual items
          savedOrder.subtotal = orderSubtotal;
          savedOrder.tax = orderSubtotal * 0.08;
          savedOrder.shipping = orderSubtotal > 100 ? 0 : 9.99;
          savedOrder.total =
            savedOrder.subtotal + savedOrder.tax + savedOrder.shipping;

          await orderRepo.save(savedOrder);
          await orderItemRepo.save(orderItems);
          totalOrderItems += orderItems.length;
        }
      }

      console.log(
        `‚úÖ Created ${totalOrders} orders with ${totalOrderItems} order items`
      );

      // 5. Generate summary statistics
      const stats = await this.generateSeedingStats();
      console.log("\nüìä Seeding Summary:");
      console.log(`Users: ${stats.users}`);
      console.log(`User Profiles: ${stats.profiles}`);
      console.log(`Categories: ${stats.categories}`);
      console.log(`Products: ${stats.products}`);
      console.log(`Orders: ${stats.orders}`);
      console.log(`Order Items: ${stats.orderItems}`);
      console.log(`Total Revenue: $${stats.totalRevenue.toFixed(2)}`);

      console.log("\nüéâ Database seeding completed successfully!");
    } catch (error) {
      console.error("‚ùå Seeding failed:", error);
      throw error;
    }
  }

  private async generateSeedingStats() {
    const userCount = await this.dataSource.getRepository(User).count();
    const profileCount = await this.dataSource
      .getRepository(UserProfile)
      .count();
    const categoryCount = await this.dataSource.getRepository(Category).count();
    const productCount = await this.dataSource.getRepository(Product).count();
    const orderCount = await this.dataSource.getRepository(Order).count();
    const orderItemCount = await this.dataSource
      .getRepository(OrderItem)
      .count();

    const totalRevenueResult = await this.dataSource
      .getRepository(Order)
      .createQueryBuilder("order")
      .select("SUM(order.total)", "total")
      .getRawOne();

    const totalRevenue = parseFloat(totalRevenueResult.total) || 0;

    return {
      users: userCount,
      profiles: profileCount,
      categories: categoryCount,
      products: productCount,
      orders: orderCount,
      orderItems: orderItemCount,
      totalRevenue,
    };
  }
}
```

### Step 4: Seeding Runner Scripts

**File: section-3/analytics-service/src/seeds/run-seeder.ts**

```typescript
import "reflect-metadata";
import { AppDataSource } from "../config/migration.config";
import { DatabaseSeeder } from "./database-seeder";

async function runSeeder() {
  try {
    // Initialize data source if not already done
    if (!AppDataSource.isInitialized) {
      await AppDataSource.initialize();
    }

    console.log("üöÄ Starting database seeding process...");

    const seeder = new DatabaseSeeder(AppDataSource);
    await seeder.seed();

    console.log("‚úÖ Seeding process completed successfully!");
    process.exit(0);
  } catch (error) {
    console.error("‚ùå Seeding process failed:", error);
    process.exit(1);
  }
}

// Run the seeder
runSeeder();
```

**File: section-3/analytics-service/src/seeds/reset-database.ts**

```typescript
import "reflect-metadata";
import { AppDataSource } from "../config/migration.config";

async function resetDatabase() {
  try {
    if (!AppDataSource.isInitialized) {
      await AppDataSource.initialize();
    }

    console.log("üóëÔ∏è  Starting database reset...");

    // Drop all tables in correct order
    await AppDataSource.dropDatabase();

    // Recreate database structure
    await AppDataSource.synchronize();

    console.log("‚úÖ Database reset completed!");
    process.exit(0);
  } catch (error) {
    console.error("‚ùå Database reset failed:", error);
    process.exit(1);
  }
}

resetDatabase();
```

### Step 5: Create Migration and Seeding Controller

**File: section-3/analytics-service/src/controllers/migration.controller.ts**

```typescript
import { Controller, Post, Get, Body } from "@nestjs/common";
import { ApiTags, ApiOperation, ApiResponse } from "@nestjs/swagger";
import { InjectDataSource } from "@nestjs/typeorm";
import { DataSource } from "typeorm";
import { DatabaseSeeder } from "../seeds/database-seeder";

@ApiTags("Database Migrations & Seeding")
@Controller("database")
export class MigrationController {
  constructor(@InjectDataSource() private dataSource: DataSource) {}

  @Get("migration-status")
  @ApiOperation({ summary: "Check migration status" })
  async getMigrationStatus() {
    const queryRunner = this.dataSource.createQueryRunner();

    try {
      const migrations = await queryRunner.query(`
        SELECT * FROM migrations_history ORDER BY timestamp ASC
      `);

      return {
        description: "Migration history",
        migrationsApplied: migrations.length,
        migrations: migrations.map((m) => ({
          id: m.id,
          timestamp: m.timestamp,
          name: m.name,
          appliedAt: m.timestamp,
        })),
      };
    } catch (error) {
      return {
        description: "Migration history",
        error: "Migrations table not found - no migrations applied yet",
        migrationsApplied: 0,
      };
    } finally {
      await queryRunner.release();
    }
  }

  @Get("table-info")
  @ApiOperation({ summary: "Get database table information" })
  async getTableInfo() {
    const queryRunner = this.dataSource.createQueryRunner();

    try {
      const tables = await queryRunner.query(`
        SELECT 
          table_name,
          (SELECT COUNT(*) FROM information_schema.columns WHERE table_name = t.table_name) as column_count
        FROM information_schema.tables t
        WHERE table_schema = 'public' 
        AND table_type = 'BASE TABLE'
        ORDER BY table_name
      `);

      const tableDetails = [];

      for (const table of tables) {
        const rowCount = await queryRunner.query(
          `SELECT COUNT(*) as count FROM ${table.table_name}`
        );

        tableDetails.push({
          tableName: table.table_name,
          columnCount: parseInt(table.column_count),
          rowCount: parseInt(rowCount[0].count),
        });
      }

      return {
        description: "Database table information",
        totalTables: tables.length,
        tables: tableDetails,
      };
    } finally {
      await queryRunner.release();
    }
  }

  @Post("seed")
  @ApiOperation({ summary: "Seed database with sample data" })
  @ApiResponse({ status: 200, description: "Database seeded successfully" })
  async seedDatabase() {
    try {
      const seeder = new DatabaseSeeder(this.dataSource);
      await seeder.seed();

      return {
        success: true,
        message: "Database seeded successfully",
        timestamp: new Date().toISOString(),
      };
    } catch (error) {
      return {
        success: false,
        message: "Database seeding failed",
        error: error.message,
        timestamp: new Date().toISOString(),
      };
    }
  }

  @Get("relationships-demo")
  @ApiOperation({ summary: "Demonstrate database relationships after seeding" })
  async demonstrateRelationships() {
    const userRepo = this.dataSource.getRepository("User");
    const orderRepo = this.dataSource.getRepository("Order");
    const productRepo = this.dataSource.getRepository("Product");

    // Get sample data to show relationships
    const userWithOrders = await userRepo.findOne({
      relations: ["orders", "orders.orderItems", "orders.orderItems.product"],
      where: {},
    });

    const productWithCategories = await productRepo.findOne({
      relations: ["categories"],
      where: {},
    });

    return {
      description: "Database relationships demonstration",
      examples: {
        userWithOrders: userWithOrders
          ? {
              userId: userWithOrders.id,
              userName: userWithOrders.fullName,
              orderCount: userWithOrders.orders?.length || 0,
              firstOrderItems:
                userWithOrders.orders?.[0]?.orderItems?.length || 0,
            }
          : null,
        productWithCategories: productWithCategories
          ? {
              productId: productWithCategories.id,
              productName: productWithCategories.title,
              categoryCount: productWithCategories.categories?.length || 0,
              categories:
                productWithCategories.categories?.map((c) => c.name) || [],
            }
          : null,
      },
      note: "Run /database/seed first if data is empty",
    };
  }
}
```

### Step 6: Testing Migration and Seeding

**File: section-3/analytics-service/test-migration.http**

```http
### Check Migration Status
GET http://localhost:3005/database/migration-status

### Get Table Information
GET http://localhost:3005/database/table-info

### Seed Database with Sample Data
POST http://localhost:3005/database/seed

### Demonstrate Database Relationships
GET http://localhost:3005/database/relationships-demo
```

### Step 7: Migration Commands Reference

**Create a new migration:**

```bash
# Generate migration based on entity changes
npm run migration:generate -- src/migrations/AddNewFeature

# Create empty migration
npm run migration:create -- src/migrations/CustomChanges
```

**Run migrations:**

```bash
# Run all pending migrations
npm run migration:run

# Show migration status
npm run migration:show

# Rollback last migration
npm run migration:revert
```

**Database setup:**

```bash
# Complete database setup (migrations + seed)
npm run db:setup

# Reset and reseed database
npm run db:reset
```

## Key Learning Points

### Migration Best Practices

1. **Always Review Generated Migrations**: Check the SQL before running
2. **Incremental Changes**: Make small, focused migrations
3. **Rollback Strategy**: Always implement `down()` methods
4. **Backup Before Production**: Always backup before running migrations in production
5. **Test Migrations**: Test both up and down migrations thoroughly

### Seeding Best Practices

1. **Relationship Integrity**: Always maintain foreign key constraints
2. **Realistic Data**: Use realistic data that represents production scenarios
3. **Performance**: Use bulk operations for large datasets
4. **Idempotent Seeds**: Seeds should be runnable multiple times safely
5. **Environment Specific**: Different seed data for different environments

### Common Migration Issues

1. **Foreign Key Violations**: Dropping tables in wrong order
2. **Data Loss**: Missing data migration when changing column types
3. **Index Conflicts**: Duplicate index names across migrations
4. **Rollback Failures**: Incomplete down() method implementations

This comprehensive exercise demonstrates the complete workflow for managing database schema changes and populating databases with realistic, relationship-aware data.

---

## References and Resources

### TypeORM Migrations

- [TypeORM Migrations](https://typeorm.io/migrations) - Official migration documentation
- [TypeORM CLI](https://typeorm.io/using-cli) - Command line interface usage
- [Schema Synchronization](https://typeorm.io/schema-sync) - Development vs production approaches

### Database Design

- [PostgreSQL Constraints](https://www.postgresql.org/docs/current/ddl-constraints.html) - Foreign keys and constraints
- [Database Indexing](https://use-the-index-luke.com/) - Index optimization strategies
- [Data Modeling](https://www.postgresql.org/docs/current/ddl.html) - PostgreSQL data definition

### Testing and Seeding

- [Faker.js Documentation](https://fakerjs.dev/) - Generating realistic test data
- [Database Testing](https://martinfowler.com/articles/dblogic.html) - Testing database logic
- [Seed Data Strategies](https://docs.docker.com/samples/library/postgres/) - Docker PostgreSQL initialization
