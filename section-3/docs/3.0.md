# Database Relationships in MongoDB and PostgreSQL

## Overview

This topic demonstrates how to implement and work with database relationships in both MongoDB (NoSQL) and PostgreSQL (SQL) using the analytics service. We'll explore different relationship patterns, implement them in both databases, and create test endpoints to verify our implementations.

## Learning Objectives

- Understand relationship patterns in SQL vs NoSQL databases
- Implement one-to-one, one-to-many, and many-to-many relationships
- Create test endpoints to demonstrate relationships
- Compare relationship handling between MongoDB and PostgreSQL
- Use both TypeORM and Mongoose for relationship management

## Relationship Patterns Comparison

### SQL (PostgreSQL) vs NoSQL (MongoDB) Relationships

```
┌─────────────────────────────────────────────────────────┐
│              RELATIONSHIP PATTERNS                     │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  PostgreSQL (Relational):                             │
│  ┌─────────────────────────────────────────────────────┐│
│  │                                                     ││
│  │  users ──────┐                                     ││
│  │  ├── id (PK)  │                                     ││
│  │  ├── name     │    orders                           ││
│  │  └── email    │    ├── id (PK)                      ││
│  │                └──▶ ├── user_id (FK)                ││
│  │                     ├── total                       ││
│  │                     └── created_at                  ││
│  │                                                     ││
│  │  Characteristics:                                   ││
│  │  • Foreign keys enforce referential integrity      ││
│  │  • JOINs to retrieve related data                  ││
│  │  • ACID compliance                                 ││
│  │  • Normalized data structure                        ││
│  └─────────────────────────────────────────────────────┘│
│                                                         │
│  MongoDB (Document):                                   │
│  ┌─────────────────────────────────────────────────────┐│
│  │                                                     ││
│  │  Approach 1: Embedded Documents                    ││
│  │  users: {                                           ││
│  │    _id: ObjectId,                                   ││
│  │    name: "John",                                    ││
│  │    orders: [                                        ││
│  │      { id: 1, total: 100, items: [...] },          ││
│  │      { id: 2, total: 200, items: [...] }           ││
│  │    ]                                                ││
│  │  }                                                  ││
│  │                                                     ││
│  │  Approach 2: References                             ││
│  │  users: { _id: ObjectId, name: "John" }            ││
│  │  orders: { _id: ObjectId, user_id: ObjectId, ... } ││
│  │                                                     ││
│  │  Characteristics:                                   ││
│  │  • Flexible schema                                  ││
│  │  • Denormalization common                          ││
│  │  • $lookup for joins (aggregation)                 ││
│  │  • Manual referential integrity                     ││
│  └─────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────┘
```

## Exercise: Implementing Relationships in Analytics Service

### Step 1: Setup Project Structure

Let's enhance the analytics service to work with both databases and demonstrate various relationship patterns.

**File: section-3/analytics-service/src/entities/postgres/user.entity.ts**

```typescript
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  OneToMany,
  OneToOne,
  CreateDateColumn,
  UpdateDateColumn,
  JoinColumn,
} from "typeorm";
import { Order } from "./order.entity";
import { UserProfile } from "./user-profile.entity";

@Entity("users")
export class User {
  @PrimaryGeneratedColumn("uuid")
  id: string;

  @Column({ type: "varchar", length: 100 })
  firstName: string;

  @Column({ type: "varchar", length: 100 })
  lastName: string;

  @Column({ type: "varchar", length: 255, unique: true })
  email: string;

  @Column({ type: "varchar", length: 20 })
  phoneNumber: string;

  @Column({ type: "date" })
  dateOfBirth: Date;

  @Column({ type: "enum", enum: ["user", "admin"], default: "user" })
  role: "user" | "admin";

  @CreateDateColumn()
  createdAt: Date;

  @UpdateDateColumn()
  updatedAt: Date;

  // One-to-Many: User has many orders
  @OneToMany(() => Order, (order) => order.user, { cascade: true })
  orders: Order[];

  // One-to-One: User has one profile
  @OneToOne(() => UserProfile, (profile) => profile.user, { cascade: true })
  @JoinColumn()
  profile: UserProfile;

  // Computed properties
  get fullName(): string {
    return `${this.firstName} ${this.lastName}`;
  }
}
```

**File: section-3/analytics-service/src/entities/postgres/user-profile.entity.ts**

```typescript
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  OneToOne,
  CreateDateColumn,
  UpdateDateColumn,
} from "typeorm";
import { User } from "./user.entity";

@Entity("user_profiles")
export class UserProfile {
  @PrimaryGeneratedColumn("uuid")
  id: string;

  @Column({ type: "text", nullable: true })
  bio: string;

  @Column({ type: "varchar", length: 255, nullable: true })
  avatar: string;

  @Column({ type: "json", nullable: true })
  preferences: {
    newsletter: boolean;
    notifications: boolean;
    theme: "light" | "dark";
  };

  @Column({ type: "json", nullable: true })
  address: {
    street: string;
    city: string;
    state: string;
    zipCode: string;
    country: string;
  };

  @CreateDateColumn()
  createdAt: Date;

  @UpdateDateColumn()
  updatedAt: Date;

  // One-to-One: Profile belongs to one user
  @OneToOne(() => User, (user) => user.profile)
  user: User;
}
```

**File: section-3/analytics-service/src/entities/postgres/category.entity.ts**

```typescript
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  ManyToMany,
  OneToMany,
  CreateDateColumn,
  UpdateDateColumn,
} from "typeorm";
import { Product } from "./product.entity";

@Entity("categories")
export class Category {
  @PrimaryGeneratedColumn("uuid")
  id: string;

  @Column({ type: "varchar", length: 100, unique: true })
  name: string;

  @Column({ type: "text", nullable: true })
  description: string;

  @Column({ type: "varchar", length: 255, nullable: true })
  image: string;

  @Column({ type: "boolean", default: true })
  isActive: boolean;

  @CreateDateColumn()
  createdAt: Date;

  @UpdateDateColumn()
  updatedAt: Date;

  // Many-to-Many: Categories have many products
  @ManyToMany(() => Product, (product) => product.categories)
  products: Product[];
}
```

**File: section-3/analytics-service/src/entities/postgres/product.entity.ts**

```typescript
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  ManyToMany,
  OneToMany,
  JoinTable,
  CreateDateColumn,
  UpdateDateColumn,
} from "typeorm";
import { Category } from "./category.entity";
import { OrderItem } from "./order-item.entity";

@Entity("products")
export class Product {
  @PrimaryGeneratedColumn("uuid")
  id: string;

  @Column({ type: "varchar", length: 200 })
  title: string;

  @Column({ type: "text" })
  description: string;

  @Column({ type: "text", nullable: true })
  summary: string;

  @Column({ type: "decimal", precision: 10, scale: 2 })
  price: number;

  @Column({ type: "varchar", length: 3, default: "USD" })
  currency: string;

  @Column({ type: "json", nullable: true })
  images: string[];

  @Column({ type: "simple-array", nullable: true })
  tags: string[];

  @Column({ type: "int", default: 0 })
  stockQuantity: number;

  @Column({ type: "boolean", default: true })
  isActive: boolean;

  @CreateDateColumn()
  createdAt: Date;

  @UpdateDateColumn()
  updatedAt: Date;

  // Many-to-Many: Products belong to many categories
  @ManyToMany(() => Category, (category) => category.products)
  @JoinTable({
    name: "product_categories",
    joinColumn: { name: "product_id", referencedColumnName: "id" },
    inverseJoinColumn: { name: "category_id", referencedColumnName: "id" },
  })
  categories: Category[];

  // One-to-Many: Product appears in many order items
  @OneToMany(() => OrderItem, (orderItem) => orderItem.product)
  orderItems: OrderItem[];
}
```

**File: section-3/analytics-service/src/entities/postgres/order.entity.ts**

```typescript
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  ManyToOne,
  OneToMany,
  CreateDateColumn,
  UpdateDateColumn,
  JoinColumn,
} from "typeorm";
import { User } from "./user.entity";
import { OrderItem } from "./order-item.entity";

export enum OrderStatus {
  PENDING = "pending",
  PAID = "paid",
  PROCESSING = "processing",
  SHIPPED = "shipped",
  DELIVERED = "delivered",
  CANCELLED = "cancelled",
}

@Entity("orders")
export class Order {
  @PrimaryGeneratedColumn("uuid")
  id: string;

  @Column({ type: "enum", enum: OrderStatus, default: OrderStatus.PENDING })
  status: OrderStatus;

  @Column({ type: "decimal", precision: 10, scale: 2 })
  subtotal: number;

  @Column({ type: "decimal", precision: 10, scale: 2, default: 0 })
  tax: number;

  @Column({ type: "decimal", precision: 10, scale: 2, default: 0 })
  shipping: number;

  @Column({ type: "decimal", precision: 10, scale: 2 })
  total: number;

  @Column({ type: "varchar", length: 3, default: "USD" })
  currency: string;

  @Column({ type: "json", nullable: true })
  shippingAddress: {
    street: string;
    city: string;
    state: string;
    zipCode: string;
    country: string;
  };

  @CreateDateColumn()
  createdAt: Date;

  @UpdateDateColumn()
  updatedAt: Date;

  // Many-to-One: Many orders belong to one user
  @ManyToOne(() => User, (user) => user.orders, { onDelete: "CASCADE" })
  @JoinColumn({ name: "user_id" })
  user: User;

  // One-to-Many: Order has many order items
  @OneToMany(() => OrderItem, (orderItem) => orderItem.order, { cascade: true })
  orderItems: OrderItem[];
}
```

**File: section-3/analytics-service/src/entities/postgres/order-item.entity.ts**

```typescript
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  ManyToOne,
  CreateDateColumn,
  JoinColumn,
} from "typeorm";
import { Order } from "./order.entity";
import { Product } from "./product.entity";

@Entity("order_items")
export class OrderItem {
  @PrimaryGeneratedColumn("uuid")
  id: string;

  @Column({ type: "int" })
  quantity: number;

  @Column({ type: "decimal", precision: 10, scale: 2 })
  price: number;

  @Column({ type: "decimal", precision: 10, scale: 2 })
  total: number;

  @CreateDateColumn()
  createdAt: Date;

  // Many-to-One: Many order items belong to one order
  @ManyToOne(() => Order, (order) => order.orderItems, { onDelete: "CASCADE" })
  @JoinColumn({ name: "order_id" })
  order: Order;

  // Many-to-One: Many order items reference one product
  @ManyToOne(() => Product, (product) => product.orderItems)
  @JoinColumn({ name: "product_id" })
  product: Product;
}
```

### Step 2: MongoDB Models with Relationships

**File: section-3/analytics-service/src/models/mongodb/user.model.ts**

```typescript
import { Schema, model, Document, Types } from "mongoose";

// Interface for User document
export interface IUser extends Document {
  firstName: string;
  lastName: string;
  email: string;
  phoneNumber: string;
  dateOfBirth: Date;
  role: "user" | "admin";
  profile: {
    bio?: string;
    avatar?: string;
    preferences: {
      newsletter: boolean;
      notifications: boolean;
      theme: "light" | "dark";
    };
    address?: {
      street: string;
      city: string;
      state: string;
      zipCode: string;
      country: string;
    };
  };
  orders: Types.ObjectId[]; // Reference to orders
  createdAt: Date;
  updatedAt: Date;
  fullName: string;
}

const UserSchema = new Schema<IUser>(
  {
    firstName: {
      type: String,
      required: true,
      maxlength: 100,
    },
    lastName: {
      type: String,
      required: true,
      maxlength: 100,
    },
    email: {
      type: String,
      required: true,
      unique: true,
      maxlength: 255,
    },
    phoneNumber: {
      type: String,
      required: true,
      maxlength: 20,
    },
    dateOfBirth: {
      type: Date,
      required: true,
    },
    role: {
      type: String,
      enum: ["user", "admin"],
      default: "user",
    },
    // Embedded profile document (One-to-One as embedded)
    profile: {
      bio: String,
      avatar: String,
      preferences: {
        newsletter: { type: Boolean, default: true },
        notifications: { type: Boolean, default: true },
        theme: {
          type: String,
          enum: ["light", "dark"],
          default: "light",
        },
      },
      address: {
        street: String,
        city: String,
        state: String,
        zipCode: String,
        country: String,
      },
    },
    // References to orders (One-to-Many as references)
    orders: [
      {
        type: Schema.Types.ObjectId,
        ref: "Order",
      },
    ],
  },
  {
    timestamps: true,
    toJSON: { virtuals: true },
    toObject: { virtuals: true },
  }
);

// Virtual for full name
UserSchema.virtual("fullName").get(function (this: IUser) {
  return `${this.firstName} ${this.lastName}`;
});

// Index for better query performance
UserSchema.index({ email: 1 });
UserSchema.index({ "profile.address.city": 1 });

export const UserModel = model<IUser>("User", UserSchema);
```

**File: section-3/analytics-service/src/models/mongodb/category.model.ts**

```typescript
import { Schema, model, Document } from "mongoose";

export interface ICategory extends Document {
  name: string;
  description?: string;
  image?: string;
  isActive: boolean;
  createdAt: Date;
  updatedAt: Date;
}

const CategorySchema = new Schema<ICategory>(
  {
    name: {
      type: String,
      required: true,
      unique: true,
      maxlength: 100,
    },
    description: {
      type: String,
      maxlength: 1000,
    },
    image: {
      type: String,
      maxlength: 255,
    },
    isActive: {
      type: Boolean,
      default: true,
    },
  },
  {
    timestamps: true,
  }
);

CategorySchema.index({ name: 1 });
CategorySchema.index({ isActive: 1 });

export const CategoryModel = model<ICategory>("Category", CategorySchema);
```

**File: section-3/analytics-service/src/models/mongodb/product.model.ts**

```typescript
import { Schema, model, Document, Types } from "mongoose";

export interface IProduct extends Document {
  title: string;
  description: string;
  summary?: string;
  price: number;
  currency: string;
  images: string[];
  tags: string[];
  stockQuantity: number;
  isActive: boolean;
  categories: Types.ObjectId[]; // Many-to-Many as references
  createdAt: Date;
  updatedAt: Date;
}

const ProductSchema = new Schema<IProduct>(
  {
    title: {
      type: String,
      required: true,
      maxlength: 200,
    },
    description: {
      type: String,
      required: true,
    },
    summary: {
      type: String,
      maxlength: 500,
    },
    price: {
      type: Number,
      required: true,
      min: 0,
    },
    currency: {
      type: String,
      default: "USD",
      maxlength: 3,
    },
    images: [String],
    tags: [String],
    stockQuantity: {
      type: Number,
      default: 0,
      min: 0,
    },
    isActive: {
      type: Boolean,
      default: true,
    },
    // Many-to-Many relationship with categories
    categories: [
      {
        type: Schema.Types.ObjectId,
        ref: "Category",
      },
    ],
  },
  {
    timestamps: true,
  }
);

// Indexes for better query performance
ProductSchema.index({ title: "text", description: "text" });
ProductSchema.index({ categories: 1 });
ProductSchema.index({ price: 1 });
ProductSchema.index({ isActive: 1 });
ProductSchema.index({ tags: 1 });

export const ProductModel = model<IProduct>("Product", ProductSchema);
```

**File: section-3/analytics-service/src/models/mongodb/order.model.ts**

```typescript
import { Schema, model, Document, Types } from "mongoose";

export enum OrderStatus {
  PENDING = "pending",
  PAID = "paid",
  PROCESSING = "processing",
  SHIPPED = "shipped",
  DELIVERED = "delivered",
  CANCELLED = "cancelled",
}

// Embedded OrderItem interface
export interface IOrderItem {
  product: Types.ObjectId;
  productSnapshot: {
    title: string;
    price: number;
    image?: string;
  };
  quantity: number;
  price: number;
  total: number;
}

export interface IOrder extends Document {
  user: Types.ObjectId;
  status: OrderStatus;
  items: IOrderItem[]; // Embedded documents for order items
  subtotal: number;
  tax: number;
  shipping: number;
  total: number;
  currency: string;
  shippingAddress: {
    street: string;
    city: string;
    state: string;
    zipCode: string;
    country: string;
  };
  createdAt: Date;
  updatedAt: Date;
}

const OrderItemSchema = new Schema<IOrderItem>({
  product: {
    type: Schema.Types.ObjectId,
    ref: "Product",
    required: true,
  },
  // Denormalized product data for performance
  productSnapshot: {
    title: { type: String, required: true },
    price: { type: Number, required: true },
    image: String,
  },
  quantity: {
    type: Number,
    required: true,
    min: 1,
  },
  price: {
    type: Number,
    required: true,
    min: 0,
  },
  total: {
    type: Number,
    required: true,
    min: 0,
  },
});

const OrderSchema = new Schema<IOrder>(
  {
    user: {
      type: Schema.Types.ObjectId,
      ref: "User",
      required: true,
    },
    status: {
      type: String,
      enum: Object.values(OrderStatus),
      default: OrderStatus.PENDING,
    },
    // Embedded order items (One-to-Many as embedded)
    items: [OrderItemSchema],
    subtotal: {
      type: Number,
      required: true,
      min: 0,
    },
    tax: {
      type: Number,
      default: 0,
      min: 0,
    },
    shipping: {
      type: Number,
      default: 0,
      min: 0,
    },
    total: {
      type: Number,
      required: true,
      min: 0,
    },
    currency: {
      type: String,
      default: "USD",
      maxlength: 3,
    },
    shippingAddress: {
      street: { type: String, required: true },
      city: { type: String, required: true },
      state: { type: String, required: true },
      zipCode: { type: String, required: true },
      country: { type: String, required: true },
    },
  },
  {
    timestamps: true,
  }
);

// Indexes for better query performance
OrderSchema.index({ user: 1, createdAt: -1 });
OrderSchema.index({ status: 1 });
OrderSchema.index({ total: 1 });
OrderSchema.index({ "items.product": 1 });

export const OrderModel = model<IOrder>("Order", OrderSchema);
```

### Step 3: Create Services for Relationship Testing

**File: section-3/analytics-service/src/services/postgres.service.ts**

```typescript
import { Injectable } from "@nestjs/common";
import { InjectRepository } from "@nestjs/typeorm";
import { Repository } from "typeorm";
import { User } from "../entities/postgres/user.entity";
import { UserProfile } from "../entities/postgres/user-profile.entity";
import { Category } from "../entities/postgres/category.entity";
import { Product } from "../entities/postgres/product.entity";
import { Order } from "../entities/postgres/order.entity";
import { OrderItem } from "../entities/postgres/order-item.entity";

@Injectable()
export class PostgresService {
  constructor(
    @InjectRepository(User) private userRepo: Repository<User>,
    @InjectRepository(UserProfile) private profileRepo: Repository<UserProfile>,
    @InjectRepository(Category) private categoryRepo: Repository<Category>,
    @InjectRepository(Product) private productRepo: Repository<Product>,
    @InjectRepository(Order) private orderRepo: Repository<Order>,
    @InjectRepository(OrderItem) private orderItemRepo: Repository<OrderItem>
  ) {}

  // Test One-to-One Relationship: User and Profile
  async testOneToOneRelationship(userId: string) {
    // Get user with profile using JOIN
    const userWithProfile = await this.userRepo.findOne({
      where: { id: userId },
      relations: ["profile"],
    });

    return {
      relationshipType: "One-to-One",
      description: "User has one profile",
      data: userWithProfile,
      query:
        "SELECT u.*, p.* FROM users u LEFT JOIN user_profiles p ON u.profile_id = p.id WHERE u.id = ?",
    };
  }

  // Test One-to-Many Relationship: User and Orders
  async testOneToManyRelationship(userId: string) {
    // Get user with all orders
    const userWithOrders = await this.userRepo.findOne({
      where: { id: userId },
      relations: ["orders", "orders.orderItems", "orders.orderItems.product"],
    });

    return {
      relationshipType: "One-to-Many",
      description: "User has many orders, Order has many order items",
      data: userWithOrders,
      ordersCount: userWithOrders?.orders?.length || 0,
      query:
        "SELECT u.*, o.*, oi.*, p.title FROM users u LEFT JOIN orders o ON u.id = o.user_id LEFT JOIN order_items oi ON o.id = oi.order_id LEFT JOIN products p ON oi.product_id = p.id WHERE u.id = ?",
    };
  }

  // Test Many-to-Many Relationship: Product and Categories
  async testManyToManyRelationship(productId: string) {
    // Get product with all categories
    const productWithCategories = await this.productRepo.findOne({
      where: { id: productId },
      relations: ["categories"],
    });

    return {
      relationshipType: "Many-to-Many",
      description:
        "Product belongs to many categories, Category has many products",
      data: productWithCategories,
      categoriesCount: productWithCategories?.categories?.length || 0,
      query:
        "SELECT p.*, c.* FROM products p LEFT JOIN product_categories pc ON p.id = pc.product_id LEFT JOIN categories c ON pc.category_id = c.id WHERE p.id = ?",
    };
  }

  // Complex relationship query: Get order with all related data
  async getOrderWithAllRelations(orderId: string) {
    const orderWithRelations = await this.orderRepo.findOne({
      where: { id: orderId },
      relations: [
        "user",
        "user.profile",
        "orderItems",
        "orderItems.product",
        "orderItems.product.categories",
      ],
    });

    return {
      description:
        "Order with user, profile, order items, products, and categories",
      data: orderWithRelations,
      relationshipChain:
        "Order -> User -> Profile, Order -> OrderItems -> Product -> Categories",
    };
  }

  // Aggregation query using Query Builder
  async getUserOrderSummary(userId: string) {
    const summary = await this.orderRepo
      .createQueryBuilder("order")
      .leftJoin("order.user", "user")
      .leftJoin("order.orderItems", "orderItem")
      .select([
        "COUNT(order.id) as totalOrders",
        "SUM(order.total) as totalSpent",
        "AVG(order.total) as averageOrderValue",
        "COUNT(orderItem.id) as totalItems",
      ])
      .where("user.id = :userId", { userId })
      .getRawOne();

    return {
      description: "User order summary using aggregation",
      data: summary,
      query:
        "SELECT COUNT(o.id) as totalOrders, SUM(o.total) as totalSpent, AVG(o.total) as averageOrderValue, COUNT(oi.id) as totalItems FROM orders o LEFT JOIN order_items oi ON o.id = oi.order_id WHERE o.user_id = ?",
    };
  }

  // Get products by category with relationship data
  async getProductsByCategory(categoryId: string) {
    const products = await this.productRepo
      .createQueryBuilder("product")
      .leftJoinAndSelect("product.categories", "category")
      .leftJoinAndSelect("product.orderItems", "orderItem")
      .leftJoinAndSelect("orderItem.order", "order")
      .where("category.id = :categoryId", { categoryId })
      .getMany();

    return {
      description: "Products in category with order statistics",
      data: products,
      query:
        "SELECT p.*, c.*, COUNT(oi.id) as timesSold FROM products p LEFT JOIN product_categories pc ON p.id = pc.product_id LEFT JOIN categories c ON pc.category_id = c.id LEFT JOIN order_items oi ON p.id = oi.product_id WHERE c.id = ? GROUP BY p.id",
    };
  }
}
```

**File: section-3/analytics-service/src/services/mongodb.service.ts**

```typescript
import { Injectable } from "@nestjs/common";
import { InjectModel } from "@nestjs/mongoose";
import { Model, Types } from "mongoose";
import { UserModel, IUser } from "../models/mongodb/user.model";
import { CategoryModel, ICategory } from "../models/mongodb/category.model";
import { ProductModel, IProduct } from "../models/mongodb/product.model";
import { OrderModel, IOrder } from "../models/mongodb/order.model";

@Injectable()
export class MongoService {
  constructor(
    @InjectModel("User") private userModel: Model<IUser>,
    @InjectModel("Category") private categoryModel: Model<ICategory>,
    @InjectModel("Product") private productModel: Model<IProduct>,
    @InjectModel("Order") private orderModel: Model<IOrder>
  ) {}

  // Test Reference Relationship: User and Orders
  async testReferenceRelationship(userId: string) {
    // Get user with referenced orders using populate
    const userWithOrders = await this.userModel
      .findById(userId)
      .populate({
        path: "orders",
        populate: {
          path: "items.product",
          select: "title price images",
        },
      })
      .exec();

    return {
      relationshipType: "Reference (One-to-Many)",
      description: "User references many orders, orders embed order items",
      data: userWithOrders,
      ordersCount: userWithOrders?.orders?.length || 0,
      mongoQuery:
        'db.users.findOne({_id: ObjectId(userId)}).populate("orders").populate("orders.items.product")',
    };
  }

  // Test Embedded Document Relationship: Order and OrderItems
  async testEmbeddedRelationship(orderId: string) {
    // Get order with embedded order items
    const orderWithItems = await this.orderModel
      .findById(orderId)
      .populate("user", "firstName lastName email")
      .populate("items.product", "title price categories")
      .exec();

    return {
      relationshipType: "Embedded Documents",
      description: "Order embeds order items as subdocuments",
      data: orderWithItems,
      itemsCount: orderWithItems?.items?.length || 0,
      mongoQuery:
        'db.orders.findOne({_id: ObjectId(orderId)}).populate("user").populate("items.product")',
    };
  }

  // Test Many-to-Many via References: Product and Categories
  async testManyToManyRelationship(productId: string) {
    // Get product with populated categories
    const productWithCategories = await this.productModel
      .findById(productId)
      .populate("categories")
      .exec();

    return {
      relationshipType: "Many-to-Many via References",
      description: "Product references many categories",
      data: productWithCategories,
      categoriesCount: productWithCategories?.categories?.length || 0,
      mongoQuery:
        'db.products.findOne({_id: ObjectId(productId)}).populate("categories")',
    };
  }

  // Complex aggregation: User order statistics
  async getUserOrderSummary(userId: string) {
    const pipeline = [
      { $match: { user: new Types.ObjectId(userId) } },
      {
        $group: {
          _id: "$user",
          totalOrders: { $sum: 1 },
          totalSpent: { $sum: "$total" },
          averageOrderValue: { $avg: "$total" },
          totalItems: { $sum: { $size: "$items" } },
          orderStatuses: { $push: "$status" },
        },
      },
      {
        $lookup: {
          from: "users",
          localField: "_id",
          foreignField: "_id",
          as: "userInfo",
        },
      },
      {
        $project: {
          totalOrders: 1,
          totalSpent: 1,
          averageOrderValue: 1,
          totalItems: 1,
          orderStatuses: 1,
          user: { $arrayElemAt: ["$userInfo", 0] },
        },
      },
    ];

    const summary = await this.orderModel.aggregate(pipeline).exec();

    return {
      description: "User order summary using MongoDB aggregation pipeline",
      data: summary[0] || null,
      pipeline: pipeline,
      mongoQuery: "db.orders.aggregate([...])",
    };
  }

  // Advanced aggregation: Products with sales analytics
  async getProductSalesAnalytics(categoryId?: string) {
    const pipeline: any[] = [
      { $unwind: "$items" },
      {
        $lookup: {
          from: "products",
          localField: "items.product",
          foreignField: "_id",
          as: "productInfo",
        },
      },
      { $unwind: "$productInfo" },
    ];

    // Filter by category if provided
    if (categoryId) {
      pipeline.push({
        $match: {
          "productInfo.categories": new Types.ObjectId(categoryId),
        },
      });
    }

    pipeline.push(
      {
        $group: {
          _id: "$items.product",
          product: { $first: "$productInfo" },
          totalSold: { $sum: "$items.quantity" },
          totalRevenue: { $sum: "$items.total" },
          averagePrice: { $avg: "$items.price" },
          orderCount: { $sum: 1 },
        },
      },
      {
        $sort: { totalRevenue: -1 },
      },
      {
        $limit: 10,
      }
    );

    const analytics = await this.orderModel.aggregate(pipeline).exec();

    return {
      description: "Product sales analytics using complex aggregation",
      data: analytics,
      pipeline: pipeline,
      mongoQuery:
        'db.orders.aggregate([{$unwind: "$items"}, {$lookup: ...}, ...])',
    };
  }

  // Test relationship lookup across multiple collections
  async getOrderWithAllRelations(orderId: string) {
    const order = await this.orderModel
      .findById(orderId)
      .populate({
        path: "user",
        select: "firstName lastName email profile",
      })
      .populate({
        path: "items.product",
        populate: {
          path: "categories",
          select: "name description",
        },
      })
      .exec();

    return {
      description:
        "Order with deep population of user and product relationships",
      data: order,
      relationshipChain:
        "Order -> User (profile embedded), Order -> Items -> Product -> Categories",
      mongoQuery:
        'db.orders.findOne({_id: ObjectId(orderId)}).populate("user").populate("items.product").populate("items.product.categories")',
    };
  }

  // Find orders by user location using embedded document queries
  async getOrdersByUserLocation(city: string) {
    const orders = await this.orderModel
      .find({})
      .populate({
        path: "user",
        match: { "profile.address.city": city },
        select: "firstName lastName email profile.address",
      })
      .exec();

    // Filter out orders where user is null (didn't match the city)
    const filteredOrders = orders.filter((order) => order.user !== null);

    return {
      description:
        "Orders filtered by user location using embedded document query",
      data: filteredOrders,
      count: filteredOrders.length,
      mongoQuery: `db.orders.find({}).populate({path: "user", match: {"profile.address.city": "${city}"}})`,
    };
  }
}
```

### Step 4: Create Controllers to Test Relationships

**File: section-3/analytics-service/src/controllers/relationships.controller.ts**

```typescript
import { Controller, Get, Param, Query } from "@nestjs/common";
import {
  ApiTags,
  ApiOperation,
  ApiParam,
  ApiQuery,
  ApiResponse,
} from "@nestjs/swagger";
import { PostgresService } from "../services/postgres.service";
import { MongoService } from "../services/mongodb.service";

@ApiTags("Database Relationships")
@Controller("relationships")
export class RelationshipsController {
  constructor(
    private readonly postgresService: PostgresService,
    private readonly mongoService: MongoService
  ) {}

  // PostgreSQL Relationship Tests
  @Get("postgres/one-to-one/:userId")
  @ApiOperation({
    summary: "Test One-to-One relationship (User-Profile) in PostgreSQL",
  })
  @ApiParam({ name: "userId", description: "User ID to test relationship" })
  async testPostgresOneToOne(@Param("userId") userId: string) {
    return this.postgresService.testOneToOneRelationship(userId);
  }

  @Get("postgres/one-to-many/:userId")
  @ApiOperation({
    summary: "Test One-to-Many relationship (User-Orders) in PostgreSQL",
  })
  @ApiParam({ name: "userId", description: "User ID to test relationship" })
  async testPostgresOneToMany(@Param("userId") userId: string) {
    return this.postgresService.testOneToManyRelationship(userId);
  }

  @Get("postgres/many-to-many/:productId")
  @ApiOperation({
    summary:
      "Test Many-to-Many relationship (Product-Categories) in PostgreSQL",
  })
  @ApiParam({
    name: "productId",
    description: "Product ID to test relationship",
  })
  async testPostgresManyToMany(@Param("productId") productId: string) {
    return this.postgresService.testManyToManyRelationship(productId);
  }

  @Get("postgres/order/:orderId/complete")
  @ApiOperation({ summary: "Get order with all relationships in PostgreSQL" })
  @ApiParam({
    name: "orderId",
    description: "Order ID to fetch with relations",
  })
  async getPostgresOrderComplete(@Param("orderId") orderId: string) {
    return this.postgresService.getOrderWithAllRelations(orderId);
  }

  @Get("postgres/user/:userId/summary")
  @ApiOperation({
    summary: "Get user order summary using aggregation in PostgreSQL",
  })
  @ApiParam({ name: "userId", description: "User ID for order summary" })
  async getPostgresUserSummary(@Param("userId") userId: string) {
    return this.postgresService.getUserOrderSummary(userId);
  }

  @Get("postgres/category/:categoryId/products")
  @ApiOperation({
    summary: "Get products by category with relationships in PostgreSQL",
  })
  @ApiParam({
    name: "categoryId",
    description: "Category ID to fetch products",
  })
  async getPostgresProductsByCategory(@Param("categoryId") categoryId: string) {
    return this.postgresService.getProductsByCategory(categoryId);
  }

  // MongoDB Relationship Tests
  @Get("mongodb/reference/:userId")
  @ApiOperation({
    summary: "Test Reference relationship (User-Orders) in MongoDB",
  })
  @ApiParam({ name: "userId", description: "User ID to test relationship" })
  async testMongoReference(@Param("userId") userId: string) {
    return this.mongoService.testReferenceRelationship(userId);
  }

  @Get("mongodb/embedded/:orderId")
  @ApiOperation({ summary: "Test Embedded documents (Order-Items) in MongoDB" })
  @ApiParam({ name: "orderId", description: "Order ID to test relationship" })
  async testMongoEmbedded(@Param("orderId") orderId: string) {
    return this.mongoService.testEmbeddedRelationship(orderId);
  }

  @Get("mongodb/many-to-many/:productId")
  @ApiOperation({
    summary: "Test Many-to-Many via References (Product-Categories) in MongoDB",
  })
  @ApiParam({
    name: "productId",
    description: "Product ID to test relationship",
  })
  async testMongoManyToMany(@Param("productId") productId: string) {
    return this.mongoService.testManyToManyRelationship(productId);
  }

  @Get("mongodb/user/:userId/summary")
  @ApiOperation({
    summary: "Get user order summary using aggregation in MongoDB",
  })
  @ApiParam({ name: "userId", description: "User ID for order summary" })
  async getMongoUserSummary(@Param("userId") userId: string) {
    return this.mongoService.getUserOrderSummary(userId);
  }

  @Get("mongodb/products/analytics")
  @ApiOperation({
    summary: "Get product sales analytics using aggregation in MongoDB",
  })
  @ApiQuery({
    name: "categoryId",
    description: "Optional category ID filter",
    required: false,
  })
  async getMongoProductAnalytics(@Query("categoryId") categoryId?: string) {
    return this.mongoService.getProductSalesAnalytics(categoryId);
  }

  @Get("mongodb/order/:orderId/complete")
  @ApiOperation({ summary: "Get order with all relationships in MongoDB" })
  @ApiParam({
    name: "orderId",
    description: "Order ID to fetch with relations",
  })
  async getMongoOrderComplete(@Param("orderId") orderId: string) {
    return this.mongoService.getOrderWithAllRelations(orderId);
  }

  @Get("mongodb/orders/location/:city")
  @ApiOperation({
    summary: "Get orders by user location using embedded queries in MongoDB",
  })
  @ApiParam({ name: "city", description: "City name to filter orders" })
  async getMongoOrdersByLocation(@Param("city") city: string) {
    return this.mongoService.getOrdersByUserLocation(city);
  }

  // Comparison endpoints
  @Get("compare/user/:userId/orders")
  @ApiOperation({
    summary: "Compare user-orders relationship between PostgreSQL and MongoDB",
  })
  @ApiParam({
    name: "userId",
    description: "User ID to compare (use same ID for both)",
  })
  async compareUserOrders(@Param("userId") userId: string) {
    const [postgresResult, mongoResult] = await Promise.all([
      this.postgresService.testOneToManyRelationship(userId),
      this.mongoService.testReferenceRelationship(userId),
    ]);

    return {
      comparison: "User-Orders Relationship",
      postgres: {
        approach: "Foreign Key Relationship with JOINs",
        result: postgresResult,
      },
      mongodb: {
        approach: "References with Population",
        result: mongoResult,
      },
      keyDifferences: [
        "PostgreSQL uses foreign keys and JOINs for referential integrity",
        "MongoDB uses references and populate() for similar functionality",
        "PostgreSQL enforces referential integrity at database level",
        "MongoDB requires application-level integrity management",
        "PostgreSQL normalizes data, MongoDB can denormalize for performance",
      ],
    };
  }
}
```

### Step 5: Testing the Relationships

**File: section-3/analytics-service/test-relationships.http**

```http
### Test PostgreSQL One-to-One Relationship
GET http://localhost:3005/relationships/postgres/one-to-one/550e8400-e29b-41d4-a716-446655440000

### Test PostgreSQL One-to-Many Relationship
GET http://localhost:3005/relationships/postgres/one-to-many/550e8400-e29b-41d4-a716-446655440000

### Test PostgreSQL Many-to-Many Relationship
GET http://localhost:3005/relationships/postgres/many-to-many/550e8400-e29b-41d4-a716-446655440001

### Test PostgreSQL Complete Order with All Relations
GET http://localhost:3005/relationships/postgres/order/550e8400-e29b-41d4-a716-446655440010/complete

### Test PostgreSQL User Order Summary
GET http://localhost:3005/relationships/postgres/user/550e8400-e29b-41d4-a716-446655440000/summary

### Test MongoDB Reference Relationship
GET http://localhost:3005/relationships/mongodb/reference/507f1f77bcf86cd799439011

### Test MongoDB Embedded Documents
GET http://localhost:3005/relationships/mongodb/embedded/507f1f77bcf86cd799439020

### Test MongoDB Many-to-Many via References
GET http://localhost:3005/relationships/mongodb/many-to-many/507f1f77bcf86cd799439030

### Test MongoDB User Summary with Aggregation
GET http://localhost:3005/relationships/mongodb/user/507f1f77bcf86cd799439011/summary

### Test MongoDB Product Analytics
GET http://localhost:3005/relationships/mongodb/products/analytics

### Test MongoDB Product Analytics by Category
GET http://localhost:3005/relationships/mongodb/products/analytics?categoryId=507f1f77bcf86cd799439040

### Test MongoDB Orders by Location
GET http://localhost:3005/relationships/mongodb/orders/location/New York

### Compare User-Orders Relationship Between Databases
GET http://localhost:3005/relationships/compare/user/550e8400-e29b-41d4-a716-446655440000/orders
```

## Key Learning Points

### PostgreSQL Relationships

1. **Foreign Keys**: Enforce referential integrity at database level
2. **JOINs**: Required to fetch related data from multiple tables
3. **TypeORM Relations**: Decorators like `@OneToMany`, `@ManyToOne`, `@JoinTable`
4. **Query Builder**: Provides fine-grained control over SQL queries
5. **ACID Compliance**: Ensures data consistency across related tables

### MongoDB Relationships

1. **References**: Store ObjectIds to reference documents in other collections
2. **Embedded Documents**: Store related data as nested objects/arrays
3. **Population**: Mongoose feature to automatically fetch referenced documents
4. **Aggregation Pipelines**: Powerful tool for complex queries across collections
5. **Denormalization**: Strategic data duplication for performance

### When to Use Each Approach

- **PostgreSQL**: When you need strong consistency, complex relationships, and ACID transactions
- **MongoDB**: When you need flexible schema, horizontal scaling, and can manage eventual consistency

This exercise demonstrates the fundamental differences in how relationships are implemented and queried in SQL vs NoSQL databases, providing practical experience with both approaches.

---

## References and Resources

### TypeORM Documentation

- [TypeORM Relations](https://typeorm.io/relations) - Complete guide to database relations
- [TypeORM Query Builder](https://typeorm.io/select-query-builder) - Advanced querying techniques
- [TypeORM Entity Decorators](https://typeorm.io/entities) - Entity definition and decoration

### Mongoose Documentation

- [Mongoose Population](https://mongoosejs.com/docs/populate.html) - Referencing other documents
- [Mongoose Aggregation](https://mongoosejs.com/docs/aggregate.html) - Complex queries and data processing
- [Mongoose Schema Design](https://mongoosejs.com/docs/guide.html) - Best practices for schema design

### Database Design Resources

- [Database Normalization](https://en.wikipedia.org/wiki/Database_normalization) - SQL normalization principles
- [MongoDB Data Modeling](https://docs.mongodb.com/manual/core/data-modeling-introduction/) - NoSQL schema design patterns
- [SQL vs NoSQL](https://www.mongodb.com/nosql-explained/nosql-vs-sql) - Choosing the right database approach
