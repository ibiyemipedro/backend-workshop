# MongoDB Operations - Basic to Advanced

## Overview

This topic covers MongoDB operations from basic CRUD to advanced aggregation pipelines using Mongoose and MongoDB Compass. We'll explore document modeling, complex queries, aggregation frameworks, indexing strategies, and database administration essential for modern NoSQL applications.

## Learning Objectives

- Master Mongoose for MongoDB operations and queries
- Build complex aggregation pipelines for data analysis
- Understand MongoDB-specific features and optimization
- Use MongoDB Compass for database administration
- Implement transactions and error handling
- Optimize queries and collections for performance
- Work with advanced MongoDB features (text search, geospatial, time-series)

## MongoDB Query Complexity Levels

### Query Complexity Progression

```
┌─────────────────────────────────────────────────────────┐
│               MONGODB QUERY COMPLEXITY                 │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  Level 1: Basic Operations (CRUD)                     │
│  ┌─────────────────────────────────────────────────────┐│
│  │ • db.users.find()                                  ││
│  │ • db.users.insertOne({...})                       ││
│  │ • db.users.updateOne({_id: ...}, {$set: {...}})   ││
│  │ • db.users.deleteOne({_id: ...})                  ││
│  └─────────────────────────────────────────────────────┘│
│                           │                             │
│  Level 2: Query Operators                             │
│  ┌─────────────────────────────────────────────────────┐│
│  │ • $eq, $ne, $gt, $lt, $gte, $lte                  ││
│  │ • $in, $nin, $exists, $type                       ││
│  │ • $and, $or, $not, $nor                           ││
│  │ • $regex, $elemMatch, $size                       ││
│  └─────────────────────────────────────────────────────┘│
│                           │                             │
│  Level 3: Document Navigation                         │
│  ┌─────────────────────────────────────────────────────┐│
│  │ • Nested field queries (address.city)              ││
│  │ • Array field operations                           ││
│  │ • Population and references                        ││
│  │ • Projection and field selection                   ││
│  └─────────────────────────────────────────────────────┘│
│                           │                             │
│  Level 4: Aggregation Framework                       │
│  ┌─────────────────────────────────────────────────────┐│
│  │ • $match, $project, $group, $sort                  ││
│  │ • $lookup for joins                                ││
│  │ • $unwind for array processing                     ││
│  │ • $facet for multi-dimensional analysis            ││
│  └─────────────────────────────────────────────────────┘│
│                           │                             │
│  Level 5: Advanced Features                           │
│  ┌─────────────────────────────────────────────────────┐│
│  │ • Text search with $text operator                  ││
│  │ • Geospatial queries with $near, $geoWithin        ││
│  │ • Time-series collections and operations           ││
│  │ • Change streams for real-time updates             ││
│  │ • MapReduce for complex data processing            ││
│  └─────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────┘
```

## Exercise: MongoDB Operations Implementation

### Step 1: MongoDB Models with Advanced Features

**File: section-3/analytics-service/src/models/mongodb/advanced-user.model.ts**

```typescript
import { Schema, Document, model } from "mongoose";

// Enhanced User Schema with MongoDB-specific features
export interface IAdvancedUser extends Document {
  firstName: string;
  lastName: string;
  email: string;
  phoneNumber?: string;
  dateOfBirth?: Date;
  role: "user" | "admin" | "moderator";

  // Profile information with nested documents
  profile: {
    bio?: string;
    avatar?: string;
    preferences: {
      newsletter: boolean;
      notifications: boolean;
      theme: "light" | "dark" | "auto";
      language: string;
    };
    address: {
      street: string;
      city: string;
      state: string;
      zipCode: string;
      country: string;
      coordinates?: [number, number]; // [longitude, latitude] for geospatial
    };
    socialMedia?: {
      platform: string;
      username: string;
      url: string;
    }[];
  };

  // Activity tracking
  activity: {
    lastLogin?: Date;
    loginCount: number;
    totalSpent: number;
    orderHistory: Schema.Types.ObjectId[];
    favoriteProducts: Schema.Types.ObjectId[];
    viewHistory: {
      productId: Schema.Types.ObjectId;
      viewedAt: Date;
      duration: number; // seconds
    }[];
    searchHistory: {
      query: string;
      searchedAt: Date;
      resultsCount: number;
    }[];
  };

  // Metadata
  tags: string[]; // For categorization
  metadata: Map<string, any>; // Flexible key-value storage
  isActive: boolean;
  emailVerified: boolean;
  createdAt: Date;
  updatedAt: Date;
}

const AdvancedUserSchema = new Schema<IAdvancedUser>(
  {
    firstName: { type: String, required: true, trim: true },
    lastName: { type: String, required: true, trim: true },
    email: {
      type: String,
      required: true,
      unique: true,
      lowercase: true,
      index: true, // Single field index
    },
    phoneNumber: { type: String, sparse: true },
    dateOfBirth: { type: Date },
    role: {
      type: String,
      enum: ["user", "admin", "moderator"],
      default: "user",
      index: true,
    },

    // Nested profile object
    profile: {
      bio: { type: String, maxlength: 500 },
      avatar: { type: String },
      preferences: {
        newsletter: { type: Boolean, default: true },
        notifications: { type: Boolean, default: true },
        theme: {
          type: String,
          enum: ["light", "dark", "auto"],
          default: "light",
        },
        language: { type: String, default: "en" },
      },
      address: {
        street: { type: String, required: true },
        city: { type: String, required: true, index: true },
        state: { type: String, required: true, index: true },
        zipCode: { type: String, required: true },
        country: { type: String, required: true, default: "USA" },
        coordinates: {
          type: [Number], // [longitude, latitude]
          index: "2dsphere", // Geospatial index for location queries
        },
      },
      socialMedia: [
        {
          platform: { type: String, required: true },
          username: { type: String, required: true },
          url: { type: String },
        },
      ],
    },

    // Activity tracking with nested arrays and objects
    activity: {
      lastLogin: { type: Date },
      loginCount: { type: Number, default: 0 },
      totalSpent: { type: Number, default: 0, index: true },
      orderHistory: [
        {
          type: Schema.Types.ObjectId,
          ref: "Order",
        },
      ],
      favoriteProducts: [
        {
          type: Schema.Types.ObjectId,
          ref: "Product",
        },
      ],
      viewHistory: [
        {
          productId: {
            type: Schema.Types.ObjectId,
            ref: "Product",
            required: true,
          },
          viewedAt: { type: Date, default: Date.now },
          duration: { type: Number, default: 0 },
        },
      ],
      searchHistory: [
        {
          query: { type: String, required: true },
          searchedAt: { type: Date, default: Date.now },
          resultsCount: { type: Number, default: 0 },
        },
      ],
    },

    tags: [{ type: String, index: true }], // Array field with index
    metadata: { type: Map, of: Schema.Types.Mixed }, // Flexible storage
    isActive: { type: Boolean, default: true, index: true },
    emailVerified: { type: Boolean, default: false },
  },
  {
    timestamps: true, // Automatically adds createdAt and updatedAt
    // Compound indexes for common query patterns
    indexes: [
      { "profile.address.city": 1, "profile.address.state": 1 },
      { "activity.totalSpent": -1, "activity.loginCount": -1 },
      { tags: 1, role: 1 },
      { createdAt: -1, isActive: 1 },
    ],
  }
);

// Text search index for searchable fields
AdvancedUserSchema.index({
  firstName: "text",
  lastName: "text",
  email: "text",
  "profile.bio": "text",
});

// Virtual for full name
AdvancedUserSchema.virtual("fullName").get(function () {
  return `${this.firstName} ${this.lastName}`;
});

// Instance methods
AdvancedUserSchema.methods.addToViewHistory = function (
  productId: string,
  duration: number = 0
) {
  this.activity.viewHistory.push({
    productId,
    viewedAt: new Date(),
    duration,
  });

  // Keep only last 100 views
  if (this.activity.viewHistory.length > 100) {
    this.activity.viewHistory = this.activity.viewHistory.slice(-100);
  }

  return this.save();
};

AdvancedUserSchema.methods.addToSearchHistory = function (
  query: string,
  resultsCount: number
) {
  this.activity.searchHistory.push({
    query,
    searchedAt: new Date(),
    resultsCount,
  });

  // Keep only last 50 searches
  if (this.activity.searchHistory.length > 50) {
    this.activity.searchHistory = this.activity.searchHistory.slice(-50);
  }

  return this.save();
};

// Static methods
AdvancedUserSchema.statics.findByLocation = function (
  city: string,
  state?: string
) {
  const query: any = { "profile.address.city": new RegExp(city, "i") };
  if (state) {
    query["profile.address.state"] = new RegExp(state, "i");
  }
  return this.find(query);
};

AdvancedUserSchema.statics.findActiveUsersWithMinSpending = function (
  minSpending: number
) {
  return this.find({
    isActive: true,
    "activity.totalSpent": { $gte: minSpending },
  }).sort({ "activity.totalSpent": -1 });
};

// Pre-save middleware
AdvancedUserSchema.pre("save", function (next) {
  // Update totalSpent when orderHistory changes
  if (this.isModified("activity.orderHistory")) {
    // In real application, you'd aggregate from actual order amounts
    this.activity.totalSpent = this.activity.orderHistory.length * 50; // Placeholder calculation
  }
  next();
});

export const AdvancedUser = model<IAdvancedUser>(
  "AdvancedUser",
  AdvancedUserSchema
);
```

**File: section-3/analytics-service/src/models/mongodb/product-analytics.model.ts**

```typescript
import { Schema, Document, model } from "mongoose";

export interface IProductAnalytics extends Document {
  productId: Schema.Types.ObjectId;
  name: string;
  category: string;
  price: number;
  tags: string[];

  // Analytics data
  analytics: {
    views: {
      total: number;
      unique: number;
      dailyViews: Map<string, number>; // date -> count
      weeklyViews: Map<string, number>; // week -> count
    };
    sales: {
      totalUnits: number;
      totalRevenue: number;
      averageOrderQuantity: number;
      dailySales: Map<string, { units: number; revenue: number }>;
      monthlySales: Map<string, { units: number; revenue: number }>;
    };
    inventory: {
      currentStock: number;
      reservedStock: number;
      reorderLevel: number;
      stockMovements: {
        type: "in" | "out" | "adjustment";
        quantity: number;
        timestamp: Date;
        reason: string;
      }[];
    };
    reviews: {
      totalReviews: number;
      averageRating: number;
      ratingDistribution: Map<string, number>; // rating -> count
    };
    recommendations: {
      frequentlyBoughtWith: {
        productId: Schema.Types.ObjectId;
        frequency: number;
        confidence: number;
      }[];
      similarProducts: {
        productId: Schema.Types.ObjectId;
        similarity: number;
      }[];
    };
  };

  // Time-series data for trending analysis
  dailyMetrics: {
    date: Date;
    views: number;
    uniqueViews: number;
    sales: number;
    revenue: number;
    cartAdds: number;
    wishlistAdds: number;
  }[];

  lastUpdated: Date;
}

const ProductAnalyticsSchema = new Schema<IProductAnalytics>(
  {
    productId: {
      type: Schema.Types.ObjectId,
      ref: "Product",
      required: true,
      unique: true,
    },
    name: { type: String, required: true, index: "text" },
    category: { type: String, required: true, index: true },
    price: { type: Number, required: true, index: true },
    tags: [{ type: String, index: true }],

    analytics: {
      views: {
        total: { type: Number, default: 0 },
        unique: { type: Number, default: 0 },
        dailyViews: { type: Map, of: Number, default: {} },
        weeklyViews: { type: Map, of: Number, default: {} },
      },
      sales: {
        totalUnits: { type: Number, default: 0 },
        totalRevenue: { type: Number, default: 0 },
        averageOrderQuantity: { type: Number, default: 0 },
        dailySales: {
          type: Map,
          of: {
            units: { type: Number, default: 0 },
            revenue: { type: Number, default: 0 },
          },
          default: {},
        },
        monthlySales: {
          type: Map,
          of: {
            units: { type: Number, default: 0 },
            revenue: { type: Number, default: 0 },
          },
          default: {},
        },
      },
      inventory: {
        currentStock: { type: Number, default: 0 },
        reservedStock: { type: Number, default: 0 },
        reorderLevel: { type: Number, default: 10 },
        stockMovements: [
          {
            type: {
              type: String,
              enum: ["in", "out", "adjustment"],
              required: true,
            },
            quantity: { type: Number, required: true },
            timestamp: { type: Date, default: Date.now },
            reason: { type: String, required: true },
          },
        ],
      },
      reviews: {
        totalReviews: { type: Number, default: 0 },
        averageRating: { type: Number, default: 0 },
        ratingDistribution: { type: Map, of: Number, default: {} },
      },
      recommendations: {
        frequentlyBoughtWith: [
          {
            productId: { type: Schema.Types.ObjectId, ref: "Product" },
            frequency: { type: Number, default: 0 },
            confidence: { type: Number, default: 0 },
          },
        ],
        similarProducts: [
          {
            productId: { type: Schema.Types.ObjectId, ref: "Product" },
            similarity: { type: Number, default: 0 },
          },
        ],
      },
    },

    dailyMetrics: [
      {
        date: { type: Date, required: true },
        views: { type: Number, default: 0 },
        uniqueViews: { type: Number, default: 0 },
        sales: { type: Number, default: 0 },
        revenue: { type: Number, default: 0 },
        cartAdds: { type: Number, default: 0 },
        wishlistAdds: { type: Number, default: 0 },
      },
    ],

    lastUpdated: { type: Date, default: Date.now },
  },
  {
    timestamps: true,
    // Compound indexes for analytics queries
    indexes: [
      { category: 1, "analytics.sales.totalRevenue": -1 },
      { "analytics.views.total": -1, "analytics.sales.totalUnits": -1 },
      { "dailyMetrics.date": -1 },
      { tags: 1, price: 1 },
    ],
  }
);

// Time-series index for daily metrics
ProductAnalyticsSchema.index({ "dailyMetrics.date": 1 });

export const ProductAnalytics = model<IProductAnalytics>(
  "ProductAnalytics",
  ProductAnalyticsSchema
);
```

### Step 2: MongoDB Operations Service

**File: section-3/analytics-service/src/services/mongodb-operations.service.ts**

```typescript
import { Injectable, Logger } from "@nestjs/common";
import { InjectModel, InjectConnection } from "@nestjs/mongoose";
import { Model, Connection, Types, ClientSession } from "mongoose";
import {
  AdvancedUser,
  IAdvancedUser,
} from "../models/mongodb/advanced-user.model";
import {
  ProductAnalytics,
  IProductAnalytics,
} from "../models/mongodb/product-analytics.model";

@Injectable()
export class MongodbOperationsService {
  private logger = new Logger("MongodbOperations");

  constructor(
    @InjectModel(AdvancedUser.name) private userModel: Model<IAdvancedUser>,
    @InjectModel(ProductAnalytics.name)
    private productAnalyticsModel: Model<IProductAnalytics>,
    @InjectConnection() private connection: Connection
  ) {}

  // Level 1: Basic CRUD Operations
  async demonstrateBasicCRUD() {
    this.logger.log("=== BASIC MONGODB CRUD OPERATIONS ===");

    // CREATE - Single document
    const newUser = new this.userModel({
      firstName: "MongoDB",
      lastName: "Demo",
      email: "mongodb.demo@example.com",
      role: "user",
      profile: {
        preferences: {
          newsletter: true,
          notifications: false,
          theme: "dark",
          language: "en",
        },
        address: {
          street: "123 MongoDB St",
          city: "Database City",
          state: "TX",
          zipCode: "12345",
          country: "USA",
          coordinates: [-97.7431, 30.2672], // Austin, TX
        },
      },
      activity: {
        loginCount: 0,
        totalSpent: 0,
        orderHistory: [],
        favoriteProducts: [],
        viewHistory: [],
        searchHistory: [],
      },
      tags: ["demo", "test", "mongodb"],
      isActive: true,
      emailVerified: false,
    });

    const savedUser = await newUser.save();
    this.logger.log(`Created user: ${savedUser._id}`);

    // CREATE - Multiple documents
    const bulkUsers = await this.userModel.insertMany([
      {
        firstName: "John",
        lastName: "Bulk",
        email: "john.bulk@example.com",
        role: "user",
        profile: {
          preferences: {
            newsletter: true,
            notifications: true,
            theme: "light",
            language: "en",
          },
          address: {
            street: "456 Bulk St",
            city: "Houston",
            state: "TX",
            zipCode: "77001",
            country: "USA",
          },
        },
        activity: { loginCount: 5, totalSpent: 150 },
        tags: ["bulk", "user"],
      },
      {
        firstName: "Jane",
        lastName: "Bulk",
        email: "jane.bulk@example.com",
        role: "admin",
        profile: {
          preferences: {
            newsletter: false,
            notifications: true,
            theme: "dark",
            language: "es",
          },
          address: {
            street: "789 Admin Ave",
            city: "Dallas",
            state: "TX",
            zipCode: "75001",
            country: "USA",
          },
        },
        activity: { loginCount: 25, totalSpent: 500 },
        tags: ["bulk", "admin"],
      },
    ]);

    // READ - Various find operations
    const allUsers = await this.userModel.find().limit(5);
    const userById = await this.userModel.findById(savedUser._id);
    const userByEmail = await this.userModel.findOne({
      email: "mongodb.demo@example.com",
    });
    const usersByCity = await this.userModel.find({
      "profile.address.city": "Database City",
    });

    // UPDATE - Single document
    const updateResult = await this.userModel.updateOne(
      { _id: savedUser._id },
      {
        $set: {
          "profile.preferences.theme": "light",
          "activity.loginCount": 1,
          lastLogin: new Date(),
        },
        $addToSet: { tags: "updated" }, // Add to array if not exists
      }
    );

    // UPDATE - Multiple documents
    const bulkUpdateResult = await this.userModel.updateMany(
      { "profile.address.state": "TX" },
      { $inc: { "activity.loginCount": 1 } } // Increment field
    );

    // DELETE - Single document
    await this.userModel.deleteOne({ _id: savedUser._id });

    // DELETE - Multiple documents
    await this.userModel.deleteMany({ tags: "bulk" });

    return {
      description: "Basic MongoDB CRUD operations demonstration",
      operations: [
        "CREATE: new Model(), save(), insertMany()",
        "READ: find(), findById(), findOne() with various filters",
        "UPDATE: updateOne(), updateMany() with $set, $inc, $addToSet",
        "DELETE: deleteOne(), deleteMany()",
      ],
      results: {
        createdUserId: savedUser._id,
        bulkCreatedCount: bulkUsers.length,
        totalUsers: allUsers.length,
        foundById: !!userById,
        foundByEmail: !!userByEmail,
        foundByCity: usersByCity.length,
        updateModified: updateResult.modifiedCount,
        bulkUpdateModified: bulkUpdateResult.modifiedCount,
      },
    };
  }

  // Level 2: Query Operators and Filtering
  async demonstrateQueryOperators() {
    this.logger.log("=== MONGODB QUERY OPERATORS ===");

    // Comparison operators
    const highSpenders = await this.userModel
      .find({
        "activity.totalSpent": { $gte: 100 }, // Greater than or equal
      })
      .limit(10);

    const roleFilter = await this.userModel.find({
      role: { $in: ["admin", "moderator"] }, // In array
    });

    const activeUsers = await this.userModel.find({
      isActive: true,
      emailVerified: { $ne: false }, // Not equal
      "activity.loginCount": { $gt: 0 }, // Greater than
    });

    // Logical operators
    const complexQuery = await this.userModel.find({
      $and: [
        { isActive: true },
        {
          $or: [
            { "profile.address.state": "TX" },
            { "activity.totalSpent": { $gt: 200 } },
          ],
        },
        {
          $nor: [{ tags: "banned" }, { role: "guest" }],
        },
      ],
    });

    // Element operators
    const usersWithBio = await this.userModel.find({
      "profile.bio": { $exists: true, $ne: null },
    });

    const usersWithTags = await this.userModel.find({
      tags: { $size: { $gte: 2 } }, // Array size
    });

    // Array operators
    const usersWithSpecificTags = await this.userModel.find({
      tags: { $elemMatch: { $regex: /user/i } }, // Element match
    });

    // Text search (requires text index)
    const textSearchResults = await this.userModel
      .find(
        {
          $text: { $search: "mongodb demo" },
        },
        {
          score: { $meta: "textScore" },
        }
      )
      .sort({ score: { $meta: "textScore" } });

    // Regular expressions
    const emailPatternUsers = await this.userModel.find({
      email: { $regex: /\.demo@/, $options: "i" }, // Case insensitive regex
    });

    // Projection (field selection)
    const userBasicInfo = await this.userModel
      .find(
        { isActive: true },
        {
          firstName: 1,
          lastName: 1,
          email: 1,
          "profile.address.city": 1,
          "activity.totalSpent": 1,
          _id: 0, // Exclude _id
        }
      )
      .limit(5);

    return {
      description: "MongoDB query operators demonstration",
      results: {
        highSpenders: highSpenders.length,
        roleFilter: roleFilter.length,
        activeUsers: activeUsers.length,
        complexQuery: complexQuery.length,
        usersWithBio: usersWithBio.length,
        usersWithTags: usersWithTags.length,
        usersWithSpecificTags: usersWithSpecificTags.length,
        textSearchResults: textSearchResults.length,
        emailPatternUsers: emailPatternUsers.length,
        userBasicInfo: userBasicInfo.length,
      },
      sampleProjectedData: userBasicInfo.slice(0, 3),
      queryExamples: [
        "{ 'activity.totalSpent': { $gte: 100 } }",
        "{ role: { $in: ['admin', 'moderator'] } }",
        "{ $and: [...], $or: [...], $nor: [...] }",
        "{ 'profile.bio': { $exists: true, $ne: null } }",
        "{ $text: { $search: 'mongodb demo' } }",
      ],
    };
  }

  // Level 3: Document Navigation and Population
  async demonstrateDocumentNavigation() {
    this.logger.log("=== DOCUMENT NAVIGATION AND POPULATION ===");

    // Nested field queries
    const citiesInTexas = await this.userModel
      .find({
        "profile.address.state": "TX",
      })
      .distinct("profile.address.city"); // Get unique cities

    const lightThemeUsers = await this.userModel.find({
      "profile.preferences.theme": "light",
    });

    // Array field operations
    const usersWithSearchHistory = await this.userModel.find({
      "activity.searchHistory": { $exists: true, $ne: [] },
    });

    const recentViewers = await this.userModel.find({
      "activity.viewHistory.viewedAt": {
        $gte: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000), // Last 7 days
      },
    });

    // Population simulation (since we're using ObjectIds)
    const usersWithOrderHistory = await this.userModel
      .find({
        "activity.orderHistory": { $ne: [] },
      })
      .populate("activity.orderHistory"); // This would populate if Orders collection exists

    // Complex nested array queries
    const longViewers = await this.userModel.find({
      "activity.viewHistory": {
        $elemMatch: {
          duration: { $gt: 300 }, // More than 5 minutes
          viewedAt: { $gte: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000) },
        },
      },
    });

    // Array field aggregation queries
    const userActivityStats = await this.userModel.aggregate([
      {
        $project: {
          firstName: 1,
          lastName: 1,
          email: 1,
          totalViews: { $size: { $ifNull: ["$activity.viewHistory", []] } },
          totalSearches: {
            $size: { $ifNull: ["$activity.searchHistory", []] },
          },
          avgViewDuration: { $avg: "$activity.viewHistory.duration" },
          lastSearch: { $max: "$activity.searchHistory.searchedAt" },
        },
      },
      {
        $match: {
          totalViews: { $gt: 0 },
        },
      },
    ]);

    // Geospatial queries (if coordinates are available)
    const nearbyUsers = await this.userModel.find({
      "profile.address.coordinates": {
        $near: {
          $geometry: {
            type: "Point",
            coordinates: [-97.7431, 30.2672], // Austin, TX
          },
          $maxDistance: 50000, // 50km in meters
        },
      },
    });

    return {
      description: "Document navigation and population operations",
      results: {
        texasCities: citiesInTexas,
        lightThemeUsers: lightThemeUsers.length,
        usersWithSearchHistory: usersWithSearchHistory.length,
        recentViewers: recentViewers.length,
        usersWithOrderHistory: usersWithOrderHistory.length,
        longViewers: longViewers.length,
        userActivityStats: userActivityStats.slice(0, 5),
        nearbyUsers: nearbyUsers.length,
      },
      documentFeatures: [
        "Nested field queries with dot notation",
        "Array field operations and $elemMatch",
        "Population for referenced documents",
        "Geospatial queries with $near",
        "Distinct values and field aggregation",
      ],
    };
  }

  // Level 4: Aggregation Framework
  async demonstrateAggregationFramework() {
    this.logger.log("=== MONGODB AGGREGATION FRAMEWORK ===");

    // Basic aggregation - User statistics by role
    const userStatsByRole = await this.userModel.aggregate([
      {
        $match: { isActive: true },
      },
      {
        $group: {
          _id: "$role",
          count: { $sum: 1 },
          avgTotalSpent: { $avg: "$activity.totalSpent" },
          maxTotalSpent: { $max: "$activity.totalSpent" },
          avgLoginCount: { $avg: "$activity.loginCount" },
        },
      },
      {
        $sort: { count: -1 },
      },
    ]);

    // Geographic analysis aggregation
    const geographicStats = await this.userModel.aggregate([
      {
        $group: {
          _id: {
            state: "$profile.address.state",
            city: "$profile.address.city",
          },
          userCount: { $sum: 1 },
          totalSpent: { $sum: "$activity.totalSpent" },
          avgSpentPerUser: { $avg: "$activity.totalSpent" },
          users: { $push: { firstName: "$firstName", lastName: "$lastName" } },
        },
      },
      {
        $match: { userCount: { $gt: 1 } },
      },
      {
        $sort: { totalSpent: -1 },
      },
      {
        $limit: 10,
      },
    ]);

    // Complex aggregation with multiple stages
    const userEngagementAnalysis = await this.userModel.aggregate([
      {
        $match: {
          isActive: true,
          "activity.viewHistory": { $ne: [] },
        },
      },
      {
        $addFields: {
          totalViews: { $size: "$activity.viewHistory" },
          totalSearches: { $size: "$activity.searchHistory" },
          avgViewDuration: { $avg: "$activity.viewHistory.duration" },
          lastActivity: { $max: "$activity.viewHistory.viewedAt" },
        },
      },
      {
        $project: {
          firstName: 1,
          lastName: 1,
          email: 1,
          role: 1,
          totalViews: 1,
          totalSearches: 1,
          avgViewDuration: 1,
          lastActivity: 1,
          "activity.totalSpent": 1,
          engagementScore: {
            $add: [
              { $multiply: ["$totalViews", 2] },
              { $multiply: ["$totalSearches", 3] },
              { $divide: [{ $ifNull: ["$avgViewDuration", 0] }, 60] },
            ],
          },
        },
      },
      {
        $sort: { engagementScore: -1 },
      },
      {
        $limit: 20,
      },
    ]);

    // Faceted search aggregation
    const facetedAnalysis = await this.userModel.aggregate([
      {
        $match: { isActive: true },
      },
      {
        $facet: {
          byRole: [
            {
              $group: {
                _id: "$role",
                count: { $sum: 1 },
                avgSpent: { $avg: "$activity.totalSpent" },
              },
            },
          ],
          byTheme: [
            {
              $group: {
                _id: "$profile.preferences.theme",
                count: { $sum: 1 },
                avgLoginCount: { $avg: "$activity.loginCount" },
              },
            },
          ],
          topStates: [
            {
              $group: {
                _id: "$profile.address.state",
                count: { $sum: 1 },
              },
            },
            { $sort: { count: -1 } },
            { $limit: 5 },
          ],
          spendingDistribution: [
            {
              $bucket: {
                groupBy: "$activity.totalSpent",
                boundaries: [0, 50, 100, 200, 500, 1000],
                default: "1000+",
                output: {
                  count: { $sum: 1 },
                  avgLoginCount: { $avg: "$activity.loginCount" },
                },
              },
            },
          ],
        },
      },
    ]);

    // Time-series aggregation for activity trends
    const activityTrends = await this.userModel.aggregate([
      {
        $match: {
          "activity.viewHistory": { $ne: [] },
        },
      },
      {
        $unwind: "$activity.viewHistory",
      },
      {
        $group: {
          _id: {
            year: { $year: "$activity.viewHistory.viewedAt" },
            month: { $month: "$activity.viewHistory.viewedAt" },
            day: { $dayOfMonth: "$activity.viewHistory.viewedAt" },
          },
          totalViews: { $sum: 1 },
          uniqueUsers: { $addToSet: "$_id" },
          avgDuration: { $avg: "$activity.viewHistory.duration" },
        },
      },
      {
        $addFields: {
          uniqueUserCount: { $size: "$uniqueUsers" },
          date: {
            $dateFromParts: {
              year: "$_id.year",
              month: "$_id.month",
              day: "$_id.day",
            },
          },
        },
      },
      {
        $project: {
          _id: 0,
          date: 1,
          totalViews: 1,
          uniqueUserCount: 1,
          avgDuration: { $round: ["$avgDuration", 2] },
        },
      },
      {
        $sort: { date: -1 },
      },
      {
        $limit: 30,
      },
    ]);

    // Lookup aggregation (join with other collections)
    const productAnalyticsWithUsers =
      await this.productAnalyticsModel.aggregate([
        {
          $match: { "analytics.views.total": { $gt: 0 } },
        },
        {
          $lookup: {
            from: "advancedusers", // Collection name
            localField: "productId",
            foreignField: "activity.favoriteProducts",
            as: "favoriteByUsers",
          },
        },
        {
          $addFields: {
            favoriteCount: { $size: "$favoriteByUsers" },
          },
        },
        {
          $project: {
            name: 1,
            category: 1,
            "analytics.views.total": 1,
            "analytics.sales.totalRevenue": 1,
            favoriteCount: 1,
            popularityScore: {
              $add: [
                "$analytics.views.total",
                { $multiply: ["$analytics.sales.totalUnits", 10] },
                { $multiply: ["$favoriteCount", 5] },
              ],
            },
          },
        },
        {
          $sort: { popularityScore: -1 },
        },
        {
          $limit: 15,
        },
      ]);

    return {
      description: "MongoDB aggregation framework demonstrations",
      results: {
        userStatsByRole,
        geographicStats: geographicStats.slice(0, 5),
        topEngagedUsers: userEngagementAnalysis.slice(0, 10),
        facetedAnalysis: facetedAnalysis[0],
        recentActivityTrends: activityTrends.slice(0, 10),
        topProducts: productAnalyticsWithUsers.slice(0, 10),
      },
      aggregationFeatures: [
        "$match for filtering documents",
        "$group for aggregation operations",
        "$project for field transformation",
        "$sort and $limit for ordering and pagination",
        "$facet for multi-dimensional analysis",
        "$lookup for joining collections",
        "$unwind for array processing",
        "$addFields for computed fields",
      ],
    };
  }

  // Level 5: Advanced MongoDB Features
  async demonstrateAdvancedFeatures() {
    this.logger.log("=== ADVANCED MONGODB FEATURES ===");

    const textSearch = await this.demonstrateTextSearch();
    const geospatialQueries = await this.demonstrateGeospatialQueries();
    const timeSeriesOperations = await this.demonstrateTimeSeriesOperations();
    const transactionExample = await this.demonstrateTransactions();

    return {
      description: "Advanced MongoDB features demonstration",
      features: {
        textSearch,
        geospatialQueries,
        timeSeriesOperations,
        transactionExample,
      },
    };
  }

  private async demonstrateTextSearch() {
    // Full-text search with scoring
    const textSearchResults = await this.userModel
      .find(
        { $text: { $search: "john admin mongodb" } },
        { score: { $meta: "textScore" } }
      )
      .sort({ score: { $meta: "textScore" } })
      .limit(10);

    // Text search with specific phrases
    const phraseSearch = await this.userModel.find({
      $text: { $search: '"Database City"' }, // Exact phrase
    });

    // Text search excluding terms
    const excludeSearch = await this.userModel.find({
      $text: { $search: "user -admin" }, // Contains 'user' but not 'admin'
    });

    return {
      textSearchResults: textSearchResults.length,
      phraseSearchResults: phraseSearch.length,
      excludeSearchResults: excludeSearch.length,
      textFeatures: [
        "Full-text search with $text operator",
        "Relevance scoring with $meta: textScore",
        "Phrase search with quotes",
        "Term exclusion with minus operator",
      ],
    };
  }

  private async demonstrateGeospatialQueries() {
    // Find users within a radius
    const nearbyUsers = await this.userModel
      .find({
        "profile.address.coordinates": {
          $near: {
            $geometry: {
              type: "Point",
              coordinates: [-97.7431, 30.2672], // Austin, TX
            },
            $maxDistance: 100000, // 100km
          },
        },
      })
      .limit(10);

    // Find users within a polygon (e.g., city boundaries)
    const polygonUsers = await this.userModel.find({
      "profile.address.coordinates": {
        $geoWithin: {
          $geometry: {
            type: "Polygon",
            coordinates: [
              [
                [-98, 29],
                [-97, 29],
                [-97, 31],
                [-98, 31],
                [-98, 29], // Rough Texas rectangle
              ],
            ],
          },
        },
      },
    });

    // Geospatial aggregation
    const geoStats = await this.userModel.aggregate([
      {
        $match: {
          "profile.address.coordinates": { $exists: true },
        },
      },
      {
        $group: {
          _id: null,
          center: {
            $avg: "$profile.address.coordinates",
          },
          bounds: {
            $push: "$profile.address.coordinates",
          },
        },
      },
    ]);

    return {
      nearbyUsers: nearbyUsers.length,
      polygonUsers: polygonUsers.length,
      geoStats: geoStats[0],
      geospatialFeatures: [
        "$near for proximity queries",
        "$geoWithin for area queries",
        "2dsphere index for spherical calculations",
        "GeoJSON geometry support",
      ],
    };
  }

  private async demonstrateTimeSeriesOperations() {
    // Time-based grouping
    const monthlyUserRegistrations = await this.userModel.aggregate([
      {
        $group: {
          _id: {
            year: { $year: "$createdAt" },
            month: { $month: "$createdAt" },
          },
          count: { $sum: 1 },
          totalSpent: { $sum: "$activity.totalSpent" },
        },
      },
      {
        $sort: { "_id.year": -1, "_id.month": -1 },
      },
    ]);

    // Moving averages and trends
    const activityTrends = await this.userModel.aggregate([
      {
        $match: {
          "activity.lastLogin": { $exists: true },
        },
      },
      {
        $group: {
          _id: {
            $dateToString: {
              format: "%Y-%m-%d",
              date: "$activity.lastLogin",
            },
          },
          dailyActiveUsers: { $sum: 1 },
          avgSpent: { $avg: "$activity.totalSpent" },
        },
      },
      {
        $sort: { _id: -1 },
      },
      {
        $limit: 30,
      },
    ]);

    return {
      monthlyRegistrations: monthlyUserRegistrations.slice(0, 12),
      recentActivityTrends: activityTrends.slice(0, 10),
      timeSeriesFeatures: [
        "Date grouping with $year, $month, $dayOfMonth",
        "$dateToString for date formatting",
        "Time-based filtering and sorting",
        "Rolling aggregations for trends",
      ],
    };
  }

  private async demonstrateTransactions() {
    const session = await this.connection.startSession();

    try {
      const result = await session.withTransaction(async () => {
        // Create user within transaction
        const [newUser] = await this.userModel.create(
          [
            {
              firstName: "Transaction",
              lastName: "User",
              email: "transaction.user.mongo@example.com",
              role: "user",
              profile: {
                preferences: {
                  newsletter: true,
                  notifications: true,
                  theme: "light",
                  language: "en",
                },
                address: {
                  street: "123 Transaction St",
                  city: "Transaction City",
                  state: "TX",
                  zipCode: "12345",
                  country: "USA",
                },
              },
              activity: {
                loginCount: 0,
                totalSpent: 0,
                orderHistory: [],
                favoriteProducts: [],
                viewHistory: [],
                searchHistory: [],
              },
              tags: ["transaction", "test"],
              isActive: true,
              emailVerified: false,
            },
          ],
          { session }
        );

        // Update user activity within same transaction
        await this.userModel.updateOne(
          { _id: newUser._id },
          {
            $inc: { "activity.loginCount": 1 },
            $set: { "activity.lastLogin": new Date() },
          },
          { session }
        );

        return newUser;
      });

      return {
        success: true,
        description: "Transaction completed successfully",
        createdUserId: result._id,
        transactionFeatures: [
          "Multi-document ACID transactions",
          "Session-based transaction handling",
          "Automatic rollback on errors",
          "Cross-collection consistency",
        ],
      };
    } catch (error) {
      return {
        success: false,
        description: "Transaction failed and was rolled back",
        error: error.message,
      };
    } finally {
      await session.endSession();
    }
  }

  // Performance optimization examples
  async demonstratePerformanceOptimization() {
    this.logger.log("=== MONGODB PERFORMANCE OPTIMIZATION ===");

    // Index usage analysis
    const indexStats = await this.userModel.collection
      .aggregate([{ $indexStats: {} }])
      .toArray();

    // Query performance analysis
    const explainResult = await this.userModel
      .find({
        "profile.address.state": "TX",
        "activity.totalSpent": { $gt: 100 },
      })
      .explain("executionStats");

    // Optimized aggregation with early filtering
    const optimizedAggregation = await this.userModel.aggregate([
      // Early match stage to reduce document count
      {
        $match: {
          isActive: true,
          "activity.totalSpent": { $gt: 50 },
        },
      },
      // Limit fields early to reduce memory usage
      {
        $project: {
          firstName: 1,
          lastName: 1,
          "profile.address.state": 1,
          "activity.totalSpent": 1,
          role: 1,
        },
      },
      // Group after filtering
      {
        $group: {
          _id: "$profile.address.state",
          count: { $sum: 1 },
          avgSpent: { $avg: "$activity.totalSpent" },
        },
      },
      {
        $sort: { avgSpent: -1 },
      },
    ]);

    return {
      description: "Performance optimization techniques",
      indexStats: indexStats.slice(0, 5),
      queryExecutionStats: {
        totalDocsExamined: explainResult.executionStats?.totalDocsExamined,
        totalDocsReturned: explainResult.executionStats?.totalDocsReturned,
        executionTimeMillis: explainResult.executionStats?.executionTimeMillis,
        indexesUsed: explainResult.executionStats?.executionStages,
      },
      optimizedResults: optimizedAggregation,
      optimizationTips: [
        "Use indexes for frequently queried fields",
        "Start aggregations with $match to filter early",
        "Use $project to limit field processing",
        "Monitor query performance with explain()",
        "Create compound indexes for multi-field queries",
        "Use lean() for read-only operations",
      ],
    };
  }
}
```

### Step 3: MongoDB Compass Integration Guide

**File: section-3/analytics-service/docs/mongodb-compass-setup.md**

````markdown
# MongoDB Compass Setup and Usage Guide

## Docker Setup for MongoDB with Authentication

```yaml
# docker-compose.yml
services:
  mongodb:
    image: mongo:7.0
    container_name: mongodb-analytics
    environment:
      MONGO_INITDB_ROOT_USERNAME: admin
      MONGO_INITDB_ROOT_PASSWORD: password123
      MONGO_INITDB_DATABASE: microservices_analytics
    ports:
      - "27017:27017"
    volumes:
      - mongodb_data:/data/db
      - ./init-mongo.js:/docker-entrypoint-initdb.d/init-mongo.js:ro
    networks:
      - mongodb-network

  mongo-express:
    image: mongo-express
    container_name: mongo-express
    environment:
      ME_CONFIG_MONGODB_ADMINUSERNAME: admin
      ME_CONFIG_MONGODB_ADMINPASSWORD: password123
      ME_CONFIG_MONGODB_SERVER: mongodb
      ME_CONFIG_BASICAUTH_USERNAME: admin
      ME_CONFIG_BASICAUTH_PASSWORD: admin123
    ports:
      - "8081:8081"
    depends_on:
      - mongodb
    networks:
      - mongodb-network

volumes:
  mongodb_data:

networks:
  mongodb-network:
    driver: bridge
```
````

## MongoDB Compass Connection

1. Download MongoDB Compass from [MongoDB Website](https://www.mongodb.com/try/download/compass)
2. Connection String: `mongodb://admin:password123@localhost:27017/microservices_analytics?authSource=admin`
3. Or use individual fields:
   - Host: localhost
   - Port: 27017
   - Authentication: Username/Password
   - Username: admin
   - Password: password123
   - Authentication Database: admin

## Essential Compass Features

### 1. Database and Collection Management

- Create/drop databases and collections
- View collection statistics and indexes
- Import/export data in various formats

### 2. Document Browser

- Browse and edit documents
- Advanced filtering and sorting
- Document validation rules

### 3. Query Builder

- Visual query builder for complex queries
- Query history and favorites
- Export queries to various languages

### 4. Aggregation Pipeline Builder

- Visual aggregation pipeline construction
- Stage-by-stage result preview
- Performance analysis

### 5. Performance Monitoring

- Real-time performance statistics
- Query performance analysis
- Index usage monitoring

## Common MongoDB Compass Tasks

### Document Queries

```javascript
// Basic filter
{ "isActive": true, "role": "user" }

// Range query
{ "activity.totalSpent": { "$gte": 100, "$lt": 500 } }

// Text search
{ "$text": { "$search": "mongodb demo" } }

// Array queries
{ "tags": { "$in": ["user", "premium"] } }

// Nested field queries
{ "profile.address.state": "TX", "profile.preferences.theme": "dark" }

// Date range queries
{ "createdAt": { "$gte": ISODate("2024-01-01"), "$lt": ISODate("2024-12-31") } }
```

### Aggregation Pipelines

```javascript
// User statistics by state
[
  { $match: { isActive: true } },
  { $group: { _id: "$profile.address.state", count: { $sum: 1 } } },
  { $sort: { count: -1 } },
][
  // Top spending users
  ({ $match: { "activity.totalSpent": { $gt: 0 } } },
  { $sort: { "activity.totalSpent": -1 } },
  { $limit: 10 },
  { $project: { firstName: 1, lastName: 1, "activity.totalSpent": 1 } })
][
  // Activity trends by month
  ({
    $group: {
      _id: { year: { $year: "$createdAt" }, month: { $month: "$createdAt" } },
      users: { $sum: 1 },
      totalSpent: { $sum: "$activity.totalSpent" },
    },
  },
  { $sort: { "_id.year": 1, "_id.month": 1 } })
];
```

### Index Management

```javascript
// Create single field index
db.advancedusers.createIndex({ email: 1 }, { unique: true });

// Create compound index
db.advancedusers.createIndex({ role: 1, "activity.totalSpent": -1 });

// Create text index
db.advancedusers.createIndex({
  firstName: "text",
  lastName: "text",
  "profile.bio": "text",
});

// Create geospatial index
db.advancedusers.createIndex({ "profile.address.coordinates": "2dsphere" });

// View index usage
db.advancedusers.aggregate([{ $indexStats: {} }]);
```

````

### Step 4: MongoDB Operations Controller

**File: section-3/analytics-service/src/controllers/mongodb-admin.controller.ts**
```typescript
import { Controller, Get, Post, Query, Param } from '@nestjs/common';
import { ApiTags, ApiOperation, ApiQuery, ApiParam } from '@nestjs/swagger';
import { MongodbOperationsService } from '../services/mongodb-operations.service';

@ApiTags('MongoDB Operations & Admin')
@Controller('mongodb-admin')
export class MongodbAdminController {
  constructor(private readonly mongodbService: MongodbOperationsService) {}

  @Get('basic-crud')
  @ApiOperation({ summary: 'Demonstrate basic MongoDB CRUD operations' })
  async basicCRUD() {
    return this.mongodbService.demonstrateBasicCRUD();
  }

  @Get('query-operators')
  @ApiOperation({ summary: 'Demonstrate MongoDB query operators and filtering' })
  async queryOperators() {
    return this.mongodbService.demonstrateQueryOperators();
  }

  @Get('document-navigation')
  @ApiOperation({ summary: 'Demonstrate document navigation and population' })
  async documentNavigation() {
    return this.mongodbService.demonstrateDocumentNavigation();
  }

  @Get('aggregation-framework')
  @ApiOperation({ summary: 'Demonstrate MongoDB aggregation framework' })
  async aggregationFramework() {
    return this.mongodbService.demonstrateAggregationFramework();
  }

  @Get('advanced-features')
  @ApiOperation({ summary: 'Demonstrate advanced MongoDB features' })
  async advancedFeatures() {
    return this.mongodbService.demonstrateAdvancedFeatures();
  }

  @Get('performance-optimization')
  @ApiOperation({ summary: 'Demonstrate MongoDB performance optimization' })
  async performanceOptimization() {
    return this.mongodbService.demonstratePerformanceOptimization();
  }

  @Get('all-operations')
  @ApiOperation({ summary: 'Run all MongoDB operations demonstrations' })
  async allOperations() {
    const results = await Promise.all([
      this.mongodbService.demonstrateBasicCRUD(),
      this.mongodbService.demonstrateQueryOperators(),
      this.mongodbService.demonstrateDocumentNavigation(),
      this.mongodbService.demonstrateAggregationFramework(),
      this.mongodbService.demonstrateAdvancedFeatures(),
    ]);

    return {
      description: 'Complete MongoDB operations demonstration',
      totalOperations: results.length,
      results: results,
      note: 'Check application logs for detailed MongoDB queries'
    };
  }
}
````

### Step 5: MongoDB Query Testing Interface

**File: section-3/analytics-service/test-mongodb-operations.http**

```http
### Test Basic CRUD Operations
GET http://localhost:3005/mongodb-admin/basic-crud

### Test Query Operators
GET http://localhost:3005/mongodb-admin/query-operators

### Test Document Navigation
GET http://localhost:3005/mongodb-admin/document-navigation

### Test Aggregation Framework
GET http://localhost:3005/mongodb-admin/aggregation-framework

### Test Advanced Features
GET http://localhost:3005/mongodb-admin/advanced-features

### Test Performance Optimization
GET http://localhost:3005/mongodb-admin/performance-optimization

### Run All MongoDB Operations
GET http://localhost:3005/mongodb-admin/all-operations
```

## Practical Exercises

### Exercise 1: MongoDB Compass Exploration

1. Connect to MongoDB using Compass
2. Explore the database schema and collections
3. Browse documents and understand the data structure
4. Create simple queries using the query builder

### Exercise 2: Aggregation Pipeline Building

1. Use Compass aggregation pipeline builder
2. Create multi-stage pipelines for data analysis
3. Preview results at each stage
4. Export pipelines for code integration

### Exercise 3: Index Optimization

1. Analyze query performance in Compass
2. Identify slow operations
3. Create appropriate indexes
4. Compare performance before and after indexing

### Exercise 4: Advanced Query Patterns

1. Build complex queries with multiple operators
2. Use text search and geospatial queries
3. Implement time-series data analysis
4. Test transaction scenarios

## Key Learning Points

### MongoDB Document Model

1. **Flexible Schema**: Dynamic document structure
2. **Nested Documents**: Embedded vs. referenced relationships
3. **Array Operations**: Working with array fields
4. **Rich Data Types**: ObjectId, Date, Geospatial, etc.

### Query Capabilities

1. **Query Operators**: Comparison, logical, element, array operators
2. **Aggregation Framework**: Powerful data processing pipeline
3. **Text Search**: Full-text search with relevance scoring
4. **Geospatial Queries**: Location-based queries

### Performance Optimization

1. **Indexing Strategy**: Single, compound, and special indexes
2. **Query Optimization**: Using explain() for performance analysis
3. **Aggregation Performance**: Early filtering and projection
4. **Memory Management**: Efficient document processing

This comprehensive exercise provides hands-on experience with MongoDB from basic document operations to advanced aggregation pipelines and performance optimization.

---

## References and Resources

### MongoDB Documentation

- [MongoDB Manual](https://www.mongodb.com/docs/manual/) - Complete MongoDB documentation
- [Aggregation Pipeline](https://www.mongodb.com/docs/manual/aggregation/) - Aggregation framework guide
- [Query Operators](https://www.mongodb.com/docs/manual/reference/operator/query/) - All query operators

### Mongoose Documentation

- [Mongoose Guide](https://mongoosejs.com/docs/guide.html) - Mongoose ODM documentation
- [Aggregation in Mongoose](https://mongoosejs.com/docs/api/aggregate.html) - Aggregation with Mongoose
- [Schema Types](https://mongoosejs.com/docs/schematypes.html) - Document schema definition

### MongoDB Compass Resources

- [MongoDB Compass Documentation](https://www.mongodb.com/docs/compass/) - Complete Compass guide
- [Query Builder](https://www.mongodb.com/docs/compass/current/query/filter/) - Visual query building
- [Aggregation Pipeline Builder](https://www.mongodb.com/docs/compass/current/aggregation-pipeline-builder/) - Visual pipeline creation
