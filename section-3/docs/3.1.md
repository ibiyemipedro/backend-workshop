# Viewing Queries Generated by ORMs

## Overview

Understanding the actual SQL and MongoDB queries generated by ORMs is crucial for performance optimization, debugging, and learning how your data access layer works under the hood. This topic demonstrates how to log, view, and analyze queries generated by TypeORM (PostgreSQL) and Mongoose (MongoDB) in real-time.

## Learning Objectives

- Enable query logging in TypeORM and Mongoose
- Analyze generated SQL queries and their performance
- Understand MongoDB operation logs and query patterns
- Create custom query logging middleware
- Compare ORM-generated queries with hand-written queries
- Identify and optimize slow queries

## Query Logging Architecture

### TypeORM vs Mongoose Query Logging

```
┌─────────────────────────────────────────────────────────┐
│              ORM QUERY LOGGING FLOW                    │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  TypeORM (PostgreSQL):                                │
│  ┌─────────────────────────────────────────────────────┐│
│  │                                                     ││
│  │  Application Code                                   ││
│  │       │                                             ││
│  │       ▼                                             ││
│  │  TypeORM Query Builder/Repository                   ││
│  │       │                                             ││
│  │       ▼                                             ││
│  │  SQL Generation                                     ││
│  │  ┌─────────────────────────────────────────────────┐││
│  │  │ SELECT u.*, p.* FROM users u                    │││
│  │  │ LEFT JOIN user_profiles p ON u.profile_id = p.id│││
│  │  │ WHERE u.id = $1                                 │││
│  │  └─────────────────────────────────────────────────┘││
│  │       │                                             ││
│  │       ▼                                             ││
│  │  Query Logging (Console/File/Custom)               ││
│  │       │                                             ││
│  │       ▼                                             ││
│  │  PostgreSQL Database                                ││
│  │                                                     ││
│  └─────────────────────────────────────────────────────┘│
│                                                         │
│  Mongoose (MongoDB):                                   │
│  ┌─────────────────────────────────────────────────────┐│
│  │                                                     ││
│  │  Application Code                                   ││
│  │       │                                             ││
│  │       ▼                                             ││
│  │  Mongoose Model/Query                               ││
│  │       │                                             ││
│  │       ▼                                             ││
│  │  MongoDB Query Generation                           ││
│  │  ┌─────────────────────────────────────────────────┐││
│  │  │ db.users.findOne({                              │││
│  │  │   _id: ObjectId("..."),                         │││
│  │  │ }).populate("orders")                           │││
│  │  └─────────────────────────────────────────────────┘││
│  │       │                                             ││
│  │       ▼                                             ││
│  │  Query Debugging/Middleware                        ││
│  │       │                                             ││
│  │       ▼                                             ││
│  │  MongoDB Database                                   ││
│  │                                                     ││
│  └─────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────┘
```

## Exercise: Implementing Query Logging

### Step 1: TypeORM Query Logging Setup

**File: section-3/analytics-service/src/config/database.config.ts**

```typescript
import { TypeOrmModuleOptions } from "@nestjs/typeorm";
import { Logger } from "@nestjs/common";

export class DatabaseLogger {
  private logger = new Logger("TypeORM");

  logQuery(query: string, parameters?: any[], queryRunner?: any) {
    const executionTime = queryRunner?.data?.queryExecutionTime || 0;

    this.logger.log(`
╭─ SQL Query (${executionTime}ms) ─────────────────────────────────
│ ${query}
│ Parameters: ${parameters ? JSON.stringify(parameters) : "none"}
╰─────────────────────────────────────────────────────────────────
    `);
  }

  logQueryError(error: string, query: string, parameters?: any[]) {
    this.logger.error(`
╭─ SQL Query ERROR ───────────────────────────────────────────────
│ Query: ${query}
│ Parameters: ${parameters ? JSON.stringify(parameters) : "none"}
│ Error: ${error}
╰─────────────────────────────────────────────────────────────────
    `);
  }

  logQuerySlow(time: number, query: string, parameters?: any[]) {
    this.logger.warn(`
╭─ SLOW SQL Query (${time}ms) ────────────────────────────────────
│ ${query}
│ Parameters: ${parameters ? JSON.stringify(parameters) : "none"}
│ ⚠️  Consider adding indexes or optimizing this query
╰─────────────────────────────────────────────────────────────────
    `);
  }

  logSchemaBuild(message: string) {
    this.logger.log(`Schema: ${message}`);
  }

  logMigration(message: string) {
    this.logger.log(`Migration: ${message}`);
  }

  log(level: "log" | "info" | "warn", message: any) {
    this.logger[level](message);
  }
}

export const typeOrmConfig: TypeOrmModuleOptions = {
  type: "postgres",
  host: process.env.POSTGRES_HOST || "localhost",
  port: parseInt(process.env.POSTGRES_PORT) || 5432,
  username: process.env.POSTGRES_USER || "postgres",
  password: process.env.POSTGRES_PASSWORD || "password123",
  database: process.env.POSTGRES_DB || "microservices_analytics",
  entities: [__dirname + "/../entities/postgres/*.entity{.ts,.js}"],
  synchronize: true,
  logging: ["query", "error", "schema", "warn", "info", "log"],
  logger: new DatabaseLogger(),
  maxQueryExecutionTime: 1000, // Log slow queries (>1000ms)
  cache: {
    duration: 30000, // 30 seconds cache
    type: "redis",
    options: {
      host: "localhost",
      port: 6379,
    },
  },
};
```

**File: section-3/analytics-service/src/middleware/query-timing.middleware.ts**

```typescript
import { Injectable, NestMiddleware, Logger } from "@nestjs/common";
import { Request, Response, NextFunction } from "express";

@Injectable()
export class QueryTimingMiddleware implements NestMiddleware {
  private logger = new Logger("QueryTiming");

  use(req: Request, res: Response, next: NextFunction) {
    const startTime = Date.now();

    // Store start time for database operations
    req["startTime"] = startTime;

    // Override res.json to log after response
    const originalJson = res.json.bind(res);
    res.json = (body: any) => {
      const endTime = Date.now();
      const duration = endTime - startTime;

      this.logger.log(`
╭─ Request Timing ────────────────────────────────────────────────
│ ${req.method} ${req.path}
│ Total Duration: ${duration}ms
│ Query Parameters: ${JSON.stringify(req.query)}
│ Status: ${res.statusCode}
╰─────────────────────────────────────────────────────────────────
      `);

      return originalJson(body);
    };

    next();
  }
}
```

### Step 2: Mongoose Query Logging Setup

**File: section-3/analytics-service/src/config/mongodb.config.ts**

```typescript
import { MongooseModuleOptions } from "@nestjs/mongoose";
import { Logger } from "@nestjs/common";
import * as mongoose from "mongoose";

export class MongoQueryLogger {
  private logger = new Logger("Mongoose");

  setupQueryLogging() {
    // Log all queries
    mongoose.set(
      "debug",
      (collectionName: string, methodName: string, query: any, doc?: any) => {
        this.logger.log(`
╭─ MongoDB Query ─────────────────────────────────────────────────
│ Collection: ${collectionName}
│ Method: ${methodName}
│ Query: ${JSON.stringify(query, null, 2)}
${doc ? `│ Document: ${JSON.stringify(doc, null, 2)}` : ""}
╰─────────────────────────────────────────────────────────────────
      `);
      }
    );

    // Custom query middleware for timing
    this.setupQueryMiddleware();
  }

  private setupQueryMiddleware() {
    // Pre-hook to record start time
    mongoose.plugin(function (schema) {
      schema.pre(
        [
          "find",
          "findOne",
          "findOneAndUpdate",
          "updateOne",
          "deleteOne",
          "aggregate",
        ],
        function () {
          this._startTime = Date.now();
        }
      );

      // Post-hook to log execution time
      schema.post(
        [
          "find",
          "findOne",
          "findOneAndUpdate",
          "updateOne",
          "deleteOne",
          "aggregate",
        ],
        function (result) {
          if (this._startTime) {
            const duration = Date.now() - this._startTime;

            if (duration > 100) {
              // Log slow queries (>100ms)
              new Logger("MongoSlow").warn(`
╭─ SLOW MongoDB Query (${duration}ms) ────────────────────────────
│ Collection: ${this.getQuery ? this.collection?.collectionName : "unknown"}
│ Query: ${JSON.stringify(this.getQuery?.() || this.getFilter?.() || "unknown")}
│ ⚠️  Consider adding indexes or optimizing this query
╰─────────────────────────────────────────────────────────────────
            `);
            } else {
              new Logger("MongoTiming").log(
                `MongoDB Query completed in ${duration}ms`
              );
            }
          }
        }
      );
    });
  }
}

export const mongooseConfig: MongooseModuleOptions = {
  uri:
    process.env.MONGODB_URI ||
    "mongodb://localhost:27017/microservices_analytics",
  connectionFactory: (connection) => {
    const queryLogger = new MongoQueryLogger();
    queryLogger.setupQueryLogging();
    return connection;
  },
};
```

### Step 3: Enhanced Services with Query Analysis

**File: section-3/analytics-service/src/services/query-analysis.service.ts**

```typescript
import { Injectable, Logger } from "@nestjs/common";
import { InjectRepository, InjectDataSource } from "@nestjs/typeorm";
import { InjectModel } from "@nestjs/mongoose";
import { Repository, DataSource } from "typeorm";
import { Model } from "mongoose";
import { User } from "../entities/postgres/user.entity";
import { Order } from "../entities/postgres/order.entity";
import { UserModel, IUser } from "../models/mongodb/user.model";
import { OrderModel, IOrder } from "../models/mongodb/order.model";

@Injectable()
export class QueryAnalysisService {
  private logger = new Logger("QueryAnalysis");

  constructor(
    @InjectRepository(User) private userRepo: Repository<User>,
    @InjectRepository(Order) private orderRepo: Repository<Order>,
    @InjectDataSource() private dataSource: DataSource,
    @InjectModel("User") private userModel: Model<IUser>,
    @InjectModel("Order") private orderModel: Model<IOrder>
  ) {}

  // PostgreSQL Query Examples with Analysis
  async demonstrateSimpleQuery() {
    this.logger.log("=== DEMONSTRATING SIMPLE QUERY ===");

    // Simple find - will show basic SELECT
    const users = await this.userRepo.find({ take: 5 });

    return {
      description: "Simple find query",
      resultCount: users.length,
      expectedSQL: "SELECT * FROM users LIMIT 5",
      data: users.map((u) => ({ id: u.id, name: u.fullName, email: u.email })),
    };
  }

  async demonstrateWhereQuery() {
    this.logger.log("=== DEMONSTRATING WHERE QUERY ===");

    // Query with WHERE clause
    const activeUsers = await this.userRepo.find({
      where: { role: "user" },
      take: 5,
    });

    return {
      description: "Query with WHERE clause",
      resultCount: activeUsers.length,
      expectedSQL: "SELECT * FROM users WHERE role = 'user' LIMIT 5",
      data: activeUsers.map((u) => ({
        id: u.id,
        name: u.fullName,
        role: u.role,
      })),
    };
  }

  async demonstrateJoinQuery() {
    this.logger.log("=== DEMONSTRATING JOIN QUERY ===");

    // Query with relations (JOINs)
    const usersWithOrders = await this.userRepo.find({
      relations: ["orders"],
      take: 3,
    });

    return {
      description: "Query with JOIN to get related data",
      resultCount: usersWithOrders.length,
      expectedSQL:
        "SELECT u.*, o.* FROM users u LEFT JOIN orders o ON u.id = o.user_id LIMIT 3",
      data: usersWithOrders.map((u) => ({
        id: u.id,
        name: u.fullName,
        ordersCount: u.orders?.length || 0,
      })),
    };
  }

  async demonstrateComplexQuery() {
    this.logger.log("=== DEMONSTRATING COMPLEX QUERY ===");

    // Complex query with Query Builder
    const result = await this.userRepo
      .createQueryBuilder("user")
      .leftJoinAndSelect("user.orders", "order")
      .leftJoinAndSelect("order.orderItems", "orderItem")
      .leftJoinAndSelect("orderItem.product", "product")
      .where("user.role = :role", { role: "user" })
      .andWhere("order.total > :minTotal", { minTotal: 50 })
      .orderBy("order.total", "DESC")
      .limit(5)
      .getMany();

    return {
      description: "Complex query with multiple JOINs and conditions",
      resultCount: result.length,
      expectedSQL: `
        SELECT user.*, order.*, orderItem.*, product.* 
        FROM users user 
        LEFT JOIN orders order ON user.id = order.user_id 
        LEFT JOIN order_items orderItem ON order.id = orderItem.order_id 
        LEFT JOIN products product ON orderItem.product_id = product.id 
        WHERE user.role = 'user' AND order.total > 50 
        ORDER BY order.total DESC 
        LIMIT 5
      `,
      data: result.map((u) => ({
        id: u.id,
        name: u.fullName,
        ordersCount: u.orders?.length || 0,
        totalSpent: u.orders?.reduce((sum, o) => sum + Number(o.total), 0) || 0,
      })),
    };
  }

  async demonstrateAggregationQuery() {
    this.logger.log("=== DEMONSTRATING AGGREGATION QUERY ===");

    // Aggregation query
    const stats = await this.userRepo
      .createQueryBuilder("user")
      .leftJoin("user.orders", "order")
      .select([
        "COUNT(DISTINCT user.id) as userCount",
        "COUNT(order.id) as totalOrders",
        "AVG(order.total) as averageOrderValue",
        "SUM(order.total) as totalRevenue",
      ])
      .where("user.role = :role", { role: "user" })
      .getRawOne();

    return {
      description: "Aggregation query with GROUP BY functions",
      expectedSQL: `
        SELECT 
          COUNT(DISTINCT user.id) as userCount,
          COUNT(order.id) as totalOrders,
          AVG(order.total) as averageOrderValue,
          SUM(order.total) as totalRevenue
        FROM users user 
        LEFT JOIN orders order ON user.id = order.user_id 
        WHERE user.role = 'user'
      `,
      data: stats,
    };
  }

  async demonstrateRawQuery() {
    this.logger.log("=== DEMONSTRATING RAW QUERY ===");

    // Raw SQL query
    const rawResult = await this.dataSource.query(
      `
      SELECT 
        u.first_name,
        u.last_name,
        COUNT(o.id) as order_count,
        COALESCE(SUM(o.total), 0) as total_spent
      FROM users u
      LEFT JOIN orders o ON u.id = o.user_id
      WHERE u.role = $1
      GROUP BY u.id, u.first_name, u.last_name
      HAVING COUNT(o.id) > 0
      ORDER BY total_spent DESC
      LIMIT $2
    `,
      ["user", 10]
    );

    return {
      description: "Raw SQL query with parameters",
      query: "Raw SQL as shown above",
      data: rawResult,
    };
  }

  // MongoDB Query Examples with Analysis
  async demonstrateMongoSimpleQuery() {
    this.logger.log("=== DEMONSTRATING MONGO SIMPLE QUERY ===");

    // Simple find in MongoDB
    const users = await this.userModel.find().limit(5).exec();

    return {
      description: "Simple find query in MongoDB",
      resultCount: users.length,
      expectedMongoDB: "db.users.find().limit(5)",
      data: users.map((u) => ({ id: u._id, name: u.fullName, email: u.email })),
    };
  }

  async demonstrateMongoFilterQuery() {
    this.logger.log("=== DEMONSTRATING MONGO FILTER QUERY ===");

    // Query with filter
    const activeUsers = await this.userModel
      .find({ role: "user" })
      .limit(5)
      .exec();

    return {
      description: "Query with filter in MongoDB",
      resultCount: activeUsers.length,
      expectedMongoDB: 'db.users.find({ role: "user" }).limit(5)',
      data: activeUsers.map((u) => ({
        id: u._id,
        name: u.fullName,
        role: u.role,
      })),
    };
  }

  async demonstrateMongoPopulateQuery() {
    this.logger.log("=== DEMONSTRATING MONGO POPULATE QUERY ===");

    // Query with populate (like JOIN)
    const usersWithOrders = await this.userModel
      .find()
      .populate("orders")
      .limit(3)
      .exec();

    return {
      description: "Query with populate (similar to JOIN) in MongoDB",
      resultCount: usersWithOrders.length,
      expectedMongoDB: 'db.users.find().populate("orders").limit(3)',
      data: usersWithOrders.map((u) => ({
        id: u._id,
        name: u.fullName,
        ordersCount: u.orders?.length || 0,
      })),
    };
  }

  async demonstrateMongoAggregationQuery() {
    this.logger.log("=== DEMONSTRATING MONGO AGGREGATION ===");

    // MongoDB aggregation pipeline
    const result = await this.userModel.aggregate([
      { $match: { role: "user" } },
      {
        $lookup: {
          from: "orders",
          localField: "_id",
          foreignField: "user",
          as: "orderData",
        },
      },
      {
        $project: {
          firstName: 1,
          lastName: 1,
          email: 1,
          orderCount: { $size: "$orderData" },
          totalSpent: { $sum: "$orderData.total" },
        },
      },
      { $match: { orderCount: { $gt: 0 } } },
      { $sort: { totalSpent: -1 } },
      { $limit: 10 },
    ]);

    return {
      description: "Complex aggregation pipeline in MongoDB",
      expectedMongoDB: `
        db.users.aggregate([
          { $match: { role: "user" } },
          { $lookup: { from: "orders", localField: "_id", foreignField: "user", as: "orderData" } },
          { $project: { firstName: 1, lastName: 1, email: 1, orderCount: { $size: "$orderData" }, totalSpent: { $sum: "$orderData.total" } } },
          { $match: { orderCount: { $gt: 0 } } },
          { $sort: { totalSpent: -1 } },
          { $limit: 10 }
        ])
      `,
      data: result,
    };
  }

  async demonstrateMongoComplexQuery() {
    this.logger.log("=== DEMONSTRATING MONGO COMPLEX QUERY ===");

    // Complex query with multiple conditions
    const complexResult = await this.userModel
      .find({
        role: "user",
        "profile.address.city": { $exists: true },
        createdAt: { $gte: new Date("2023-01-01") },
      })
      .select("firstName lastName email profile.address.city")
      .sort({ createdAt: -1 })
      .limit(5)
      .exec();

    return {
      description: "Complex query with nested field conditions",
      resultCount: complexResult.length,
      expectedMongoDB: `
        db.users.find({
          role: "user",
          "profile.address.city": { $exists: true },
          createdAt: { $gte: ISODate("2023-01-01") }
        })
        .select("firstName lastName email profile.address.city")
        .sort({ createdAt: -1 })
        .limit(5)
      `,
      data: complexResult,
    };
  }

  // Query Performance Analysis
  async analyzeQueryPerformance() {
    this.logger.log("=== ANALYZING QUERY PERFORMANCE ===");

    const startTime = Date.now();

    // Test different query approaches
    const results = await Promise.all([
      this.testSimpleSelect(),
      this.testJoinQuery(),
      this.testSubquery(),
      this.testMongoEquivalent(),
    ]);

    const totalTime = Date.now() - startTime;

    return {
      description: "Query performance comparison",
      totalExecutionTime: totalTime,
      results: results,
      recommendations: [
        "Use indexes on frequently queried columns",
        "Avoid N+1 query problems with proper joins/populate",
        "Consider pagination for large datasets",
        "Monitor slow query logs regularly",
        "Use explain plans to understand query execution",
      ],
    };
  }

  private async testSimpleSelect() {
    const start = Date.now();
    const result = await this.userRepo.find({ take: 10 });
    const duration = Date.now() - start;

    return {
      type: "Simple SELECT",
      duration,
      resultCount: result.length,
      query: "SELECT * FROM users LIMIT 10",
    };
  }

  private async testJoinQuery() {
    const start = Date.now();
    const result = await this.userRepo.find({
      relations: ["orders"],
      take: 10,
    });
    const duration = Date.now() - start;

    return {
      type: "JOIN Query",
      duration,
      resultCount: result.length,
      query:
        "SELECT u.*, o.* FROM users u LEFT JOIN orders o ON u.id = o.user_id LIMIT 10",
    };
  }

  private async testSubquery() {
    const start = Date.now();
    const result = await this.userRepo
      .createQueryBuilder("user")
      .where("user.id IN (SELECT DISTINCT o.user_id FROM orders o)")
      .limit(10)
      .getMany();
    const duration = Date.now() - start;

    return {
      type: "Subquery",
      duration,
      resultCount: result.length,
      query:
        "SELECT * FROM users WHERE id IN (SELECT DISTINCT user_id FROM orders) LIMIT 10",
    };
  }

  private async testMongoEquivalent() {
    const start = Date.now();
    const result = await this.userModel
      .find()
      .populate("orders")
      .limit(10)
      .exec();
    const duration = Date.now() - start;

    return {
      type: "MongoDB with Populate",
      duration,
      resultCount: result.length,
      query: 'db.users.find().populate("orders").limit(10)',
    };
  }
}
```

### Step 4: Create Controller for Query Demonstrations

**File: section-3/analytics-service/src/controllers/query-logging.controller.ts**

```typescript
import { Controller, Get, Query } from "@nestjs/common";
import { ApiTags, ApiOperation, ApiQuery, ApiResponse } from "@nestjs/swagger";
import { QueryAnalysisService } from "../services/query-analysis.service";

@ApiTags("Query Logging & Analysis")
@Controller("query-analysis")
export class QueryLoggingController {
  constructor(private readonly queryAnalysisService: QueryAnalysisService) {}

  // PostgreSQL Query Demonstrations
  @Get("postgres/simple")
  @ApiOperation({ summary: "Demonstrate simple PostgreSQL query logging" })
  async demonstrateSimplePostgresQuery() {
    return this.queryAnalysisService.demonstrateSimpleQuery();
  }

  @Get("postgres/where")
  @ApiOperation({ summary: "Demonstrate PostgreSQL WHERE query logging" })
  async demonstrateWherePostgresQuery() {
    return this.queryAnalysisService.demonstrateWhereQuery();
  }

  @Get("postgres/join")
  @ApiOperation({ summary: "Demonstrate PostgreSQL JOIN query logging" })
  async demonstrateJoinPostgresQuery() {
    return this.queryAnalysisService.demonstrateJoinQuery();
  }

  @Get("postgres/complex")
  @ApiOperation({ summary: "Demonstrate complex PostgreSQL query logging" })
  async demonstrateComplexPostgresQuery() {
    return this.queryAnalysisService.demonstrateComplexQuery();
  }

  @Get("postgres/aggregation")
  @ApiOperation({ summary: "Demonstrate PostgreSQL aggregation query logging" })
  async demonstrateAggregationPostgresQuery() {
    return this.queryAnalysisService.demonstrateAggregationQuery();
  }

  @Get("postgres/raw")
  @ApiOperation({ summary: "Demonstrate raw PostgreSQL query logging" })
  async demonstrateRawPostgresQuery() {
    return this.queryAnalysisService.demonstrateRawQuery();
  }

  // MongoDB Query Demonstrations
  @Get("mongodb/simple")
  @ApiOperation({ summary: "Demonstrate simple MongoDB query logging" })
  async demonstrateSimpleMongoQuery() {
    return this.queryAnalysisService.demonstrateMongoSimpleQuery();
  }

  @Get("mongodb/filter")
  @ApiOperation({ summary: "Demonstrate MongoDB filter query logging" })
  async demonstrateFilterMongoQuery() {
    return this.queryAnalysisService.demonstrateMongoFilterQuery();
  }

  @Get("mongodb/populate")
  @ApiOperation({ summary: "Demonstrate MongoDB populate query logging" })
  async demonstratePopulateMongoQuery() {
    return this.queryAnalysisService.demonstrateMongoPopulateQuery();
  }

  @Get("mongodb/aggregation")
  @ApiOperation({ summary: "Demonstrate MongoDB aggregation pipeline logging" })
  async demonstrateAggregationMongoQuery() {
    return this.queryAnalysisService.demonstrateMongoAggregationQuery();
  }

  @Get("mongodb/complex")
  @ApiOperation({ summary: "Demonstrate complex MongoDB query logging" })
  async demonstrateComplexMongoQuery() {
    return this.queryAnalysisService.demonstrateMongoComplexQuery();
  }

  // Performance Analysis
  @Get("performance")
  @ApiOperation({ summary: "Analyze and compare query performance" })
  async analyzeQueryPerformance() {
    return this.queryAnalysisService.analyzeQueryPerformance();
  }

  @Get("all-queries")
  @ApiOperation({
    summary: "Run all query demonstrations to see logging in action",
  })
  async runAllQueryDemonstrations() {
    const results = await Promise.all([
      // PostgreSQL queries
      this.queryAnalysisService.demonstrateSimpleQuery(),
      this.queryAnalysisService.demonstrateWhereQuery(),
      this.queryAnalysisService.demonstrateJoinQuery(),
      this.queryAnalysisService.demonstrateComplexQuery(),

      // MongoDB queries
      this.queryAnalysisService.demonstrateMongoSimpleQuery(),
      this.queryAnalysisService.demonstrateMongoFilterQuery(),
      this.queryAnalysisService.demonstrateMongoPopulateQuery(),
      this.queryAnalysisService.demonstrateMongoAggregationQuery(),
    ]);

    return {
      description:
        "All query demonstrations completed - check logs for generated queries",
      summary: {
        postgresQueries: 4,
        mongodbQueries: 4,
        totalQueries: 8,
      },
      results: results,
      note: "Check the application logs to see the actual SQL and MongoDB queries generated",
    };
  }
}
```

### Step 5: Query Logging Testing Script

**File: section-3/analytics-service/test-query-logging.http**

```http
### Test Simple PostgreSQL Query (check logs for SQL)
GET http://localhost:3005/query-analysis/postgres/simple

### Test PostgreSQL WHERE Query
GET http://localhost:3005/query-analysis/postgres/where

### Test PostgreSQL JOIN Query
GET http://localhost:3005/query-analysis/postgres/join

### Test Complex PostgreSQL Query
GET http://localhost:3005/query-analysis/postgres/complex

### Test PostgreSQL Aggregation Query
GET http://localhost:3005/query-analysis/postgres/aggregation

### Test Raw PostgreSQL Query
GET http://localhost:3005/query-analysis/postgres/raw

### Test Simple MongoDB Query (check logs for MongoDB operations)
GET http://localhost:3005/query-analysis/mongodb/simple

### Test MongoDB Filter Query
GET http://localhost:3005/query-analysis/mongodb/filter

### Test MongoDB Populate Query
GET http://localhost:3005/query-analysis/mongodb/populate

### Test MongoDB Aggregation Pipeline
GET http://localhost:3005/query-analysis/mongodb/aggregation

### Test Complex MongoDB Query
GET http://localhost:3005/query-analysis/mongodb/complex

### Test Query Performance Analysis
GET http://localhost:3005/query-analysis/performance

### Run All Queries to See Complete Logging
GET http://localhost:3005/query-analysis/all-queries
```

### Step 6: Advanced Query Optimization Tips

**File: section-3/analytics-service/src/utils/query-optimizer.ts**

```typescript
export class QueryOptimizer {
  // PostgreSQL Optimization Tips
  static getPostgresTips() {
    return {
      indexing: [
        "CREATE INDEX ON users(email) - for email lookups",
        "CREATE INDEX ON orders(user_id, created_at) - for user order history",
        "CREATE INDEX ON products(price) - for price range queries",
      ],

      queryOptimization: [
        "Use EXPLAIN ANALYZE to understand query execution",
        "Avoid SELECT * - specify only needed columns",
        "Use LIMIT to prevent large result sets",
        "Consider materialized views for complex aggregations",
      ],

      commonIssues: [
        "N+1 queries - use JOIN or eager loading",
        "Missing WHERE clauses on large tables",
        "Inefficient OR conditions - consider UNION",
        "Subqueries instead of JOINs",
      ],
    };
  }

  // MongoDB Optimization Tips
  static getMongoDBTips() {
    return {
      indexing: [
        "db.users.createIndex({ email: 1 }) - for email lookups",
        "db.orders.createIndex({ user: 1, createdAt: -1 }) - for user orders",
        "db.products.createIndex({ categories: 1, price: 1 }) - for category/price queries",
      ],

      queryOptimization: [
        "Use .explain() to understand query execution",
        "Project only needed fields with .select()",
        "Use .limit() to prevent large result sets",
        "Consider aggregation pipelines for complex operations",
      ],

      commonIssues: [
        "Missing indexes on query fields",
        "Over-populating referenced documents",
        "Not using aggregation for complex queries",
        "Inefficient regex queries without indexes",
      ],
    };
  }

  // Query Performance Checklist
  static getPerformanceChecklist() {
    return {
      beforeOptimization: [
        "✓ Enable query logging",
        "✓ Identify slow queries (>100ms)",
        "✓ Check current indexes",
        "✓ Analyze query patterns",
      ],

      duringOptimization: [
        "✓ Add appropriate indexes",
        "✓ Rewrite inefficient queries",
        "✓ Test with production-like data",
        "✓ Monitor performance improvements",
      ],

      afterOptimization: [
        "✓ Monitor query performance",
        "✓ Set up alerts for slow queries",
        "✓ Regular performance reviews",
        "✓ Update indexes as data grows",
      ],
    };
  }
}
```

## Key Learning Points

### TypeORM Query Logging Benefits

1. **Transparency**: See exact SQL generated from your ORM code
2. **Performance**: Identify slow queries and optimization opportunities
3. **Debugging**: Understand why queries might not return expected results
4. **Learning**: Bridge the gap between ORM abstraction and SQL knowledge

### Mongoose Query Logging Benefits

1. **MongoDB Operations**: See actual MongoDB operations executed
2. **Population Understanding**: Understand how populate() works under the hood
3. **Aggregation Insights**: See complex aggregation pipelines in action
4. **Performance Monitoring**: Track query execution times

### Best Practices

1. **Enable in Development**: Always log queries during development
2. **Monitor in Production**: Use structured logging for production analysis
3. **Optimize Regularly**: Regular query performance reviews
4. **Index Strategy**: Understand when and how to add database indexes

This exercise provides hands-on experience with query logging and optimization techniques essential for building performant database-driven applications.

---

## References and Resources

### TypeORM Documentation

- [TypeORM Logging](https://typeorm.io/logging) - Official logging documentation
- [TypeORM Query Builder](https://typeorm.io/select-query-builder) - Advanced query building
- [TypeORM Performance](https://typeorm.io/caching) - Performance optimization tips

### Mongoose Documentation

- [Mongoose Debug Mode](https://mongoosejs.com/docs/api/mongoose.html#mongoose_Mongoose-set) - Query debugging
- [Mongoose Performance](https://mongoosejs.com/docs/tutorials/performance.html) - Performance optimization
- [MongoDB Profiler](https://docs.mongodb.com/manual/tutorial/manage-the-database-profiler/) - Database profiling

### Database Performance Resources

- [PostgreSQL EXPLAIN](https://www.postgresql.org/docs/current/sql-explain.html) - Query execution analysis
- [MongoDB Profiling](https://docs.mongodb.com/manual/tutorial/manage-the-database-profiler/) - Query performance analysis
- [Database Indexing Best Practices](https://use-the-index-luke.com/) - Comprehensive indexing guide
