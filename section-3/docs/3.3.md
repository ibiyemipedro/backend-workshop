# PostgreSQL Operations - Basic to Advanced

## Overview

This topic covers PostgreSQL operations from basic CRUD to advanced query techniques using TypeORM and pgAdmin. We'll explore query building, raw SQL execution, performance optimization, transactions, and database administration tasks essential for production applications.

## Learning Objectives

- Master TypeORM Query Builder for complex queries
- Write and execute raw SQL queries safely
- Understand PostgreSQL-specific features and optimization
- Use pgAdmin for database administration
- Implement transactions and error handling
- Optimize queries for performance
- Work with advanced PostgreSQL features (JSON, arrays, full-text search)

## PostgreSQL Query Complexity Levels

### Query Complexity Progression

```
┌─────────────────────────────────────────────────────────┐
│              POSTGRESQL QUERY COMPLEXITY               │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  Level 1: Basic Operations (CRUD)                     │
│  ┌─────────────────────────────────────────────────────┐│
│  │ • SELECT * FROM users                               ││
│  │ • INSERT INTO users (name, email) VALUES (...)     ││
│  │ • UPDATE users SET name = '...' WHERE id = 1       ││
│  │ • DELETE FROM users WHERE id = 1                   ││
│  └─────────────────────────────────────────────────────┘│
│                           │                             │
│  Level 2: Filtering & Sorting                         │
│  ┌─────────────────────────────────────────────────────┐│
│  │ • WHERE conditions (AND, OR, IN, LIKE)             ││
│  │ • ORDER BY with multiple columns                    ││
│  │ • GROUP BY with HAVING clauses                     ││
│  │ • LIMIT and OFFSET for pagination                  ││
│  └─────────────────────────────────────────────────────┘│
│                           │                             │
│  Level 3: Joins & Relationships                       │
│  ┌─────────────────────────────────────────────────────┐│
│  │ • INNER JOIN, LEFT JOIN, RIGHT JOIN                ││
│  │ • Self-joins for hierarchical data                 ││
│  │ • Multiple table joins                             ││
│  │ • Subqueries in WHERE and SELECT                   ││
│  └─────────────────────────────────────────────────────┘│
│                           │                             │
│  Level 4: Aggregations & Analytics                    │
│  ┌─────────────────────────────────────────────────────┐│
│  │ • COUNT, SUM, AVG, MIN, MAX                        ││
│  │ • Window functions (ROW_NUMBER, RANK)              ││
│  │ • Common Table Expressions (CTEs)                  ││
│  │ • CASE statements for conditional logic            ││
│  └─────────────────────────────────────────────────────┘│
│                           │                             │
│  Level 5: Advanced Features                           │
│  ┌─────────────────────────────────────────────────────┐│
│  │ • JSON/JSONB operations                            ││
│  │ • Full-text search with ts_vector                  ││
│  │ • Array operations and unnesting                   ││
│  │ • Recursive queries for hierarchical data          ││
│  │ • Custom functions and stored procedures           ││
│  └─────────────────────────────────────────────────────┘│
└─────────────────────────────────────────────────────────┘
```

## Exercise: PostgreSQL Operations Implementation

### Step 1: Basic CRUD Operations with TypeORM

**File: section-3/analytics-service/src/services/postgres-operations.service.ts**

```typescript
import { Injectable, Logger } from "@nestjs/common";
import { InjectRepository, InjectDataSource } from "@nestjs/typeorm";
import { Repository, DataSource, QueryRunner } from "typeorm";
import { User } from "../entities/postgres/user.entity";
import { Order } from "../entities/postgres/order.entity";
import { Product } from "../entities/postgres/product.entity";
import { Category } from "../entities/postgres/category.entity";

@Injectable()
export class PostgresOperationsService {
  private logger = new Logger("PostgresOperations");

  constructor(
    @InjectRepository(User) private userRepo: Repository<User>,
    @InjectRepository(Order) private orderRepo: Repository<Order>,
    @InjectRepository(Product) private productRepo: Repository<Product>,
    @InjectRepository(Category) private categoryRepo: Repository<Category>,
    @InjectDataSource() private dataSource: DataSource
  ) {}

  // Level 1: Basic CRUD Operations
  async demonstrateBasicCRUD() {
    this.logger.log("=== BASIC CRUD OPERATIONS ===");

    // CREATE - Repository method
    const newUser = this.userRepo.create({
      firstName: "John",
      lastName: "Doe",
      email: "john.doe.demo@example.com",
      phoneNumber: "+1234567890",
      dateOfBirth: new Date("1990-01-01"),
      role: "user",
    });

    const savedUser = await this.userRepo.save(newUser);
    this.logger.log(`Created user: ${savedUser.id}`);

    // READ - Various find methods
    const allUsers = await this.userRepo.find({ take: 5 });
    const userById = await this.userRepo.findOne({
      where: { id: savedUser.id },
    });
    const userByEmail = await this.userRepo.findOne({
      where: { email: "john.doe.demo@example.com" },
    });

    // UPDATE - Repository method
    await this.userRepo.update(savedUser.id, {
      firstName: "Johnny",
    });

    // UPDATE - Save method
    userById.lastName = "Smith";
    await this.userRepo.save(userById);

    // DELETE - Repository method
    await this.userRepo.delete(savedUser.id);

    return {
      description: "Basic CRUD operations demonstration",
      operations: [
        "CREATE: userRepo.create() + userRepo.save()",
        "READ: userRepo.find(), findOne(), findBy()",
        "UPDATE: userRepo.update() or save() existing entity",
        "DELETE: userRepo.delete() or remove()",
      ],
      examples: {
        totalUsers: allUsers.length,
        foundById: !!userById,
        foundByEmail: !!userByEmail,
      },
    };
  }

  // Level 2: Filtering and Sorting Operations
  async demonstrateFilteringAndSorting() {
    this.logger.log("=== FILTERING AND SORTING ===");

    // WHERE conditions
    const activeUsers = await this.userRepo.find({
      where: { role: "user" },
      order: { createdAt: "DESC" },
      take: 10,
    });

    // Multiple conditions
    const recentAdminUsers = await this.userRepo.find({
      where: { role: "admin" },
      order: { createdAt: "DESC" },
      take: 5,
    });

    // Query Builder for complex conditions
    const complexQuery = await this.userRepo
      .createQueryBuilder("user")
      .where("user.role = :role", { role: "user" })
      .andWhere("user.createdAt >= :date", {
        date: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000), // Last 30 days
      })
      .orderBy("user.createdAt", "DESC")
      .addOrderBy("user.lastName", "ASC")
      .limit(10)
      .getMany();

    // LIKE operations
    const searchQuery = await this.userRepo
      .createQueryBuilder("user")
      .where("user.firstName ILIKE :search OR user.lastName ILIKE :search", {
        search: "%john%",
      })
      .getMany();

    // IN operation
    const usersByRole = await this.userRepo
      .createQueryBuilder("user")
      .where("user.role IN (:...roles)", { roles: ["user", "admin"] })
      .getMany();

    return {
      description: "Filtering and sorting operations",
      results: {
        activeUsers: activeUsers.length,
        recentAdmins: recentAdminUsers.length,
        complexQuery: complexQuery.length,
        searchResults: searchQuery.length,
        usersByRole: usersByRole.length,
      },
      sqlExamples: [
        "SELECT * FROM users WHERE role = 'user' ORDER BY created_at DESC LIMIT 10",
        "SELECT * FROM users WHERE role = 'admin' AND created_at >= NOW() - INTERVAL '30 days'",
        "SELECT * FROM users WHERE first_name ILIKE '%john%' OR last_name ILIKE '%john%'",
        "SELECT * FROM users WHERE role IN ('user', 'admin')",
      ],
    };
  }

  // Level 3: Joins and Relationships
  async demonstrateJoins() {
    this.logger.log("=== JOINS AND RELATIONSHIPS ===");

    // INNER JOIN - Users with orders
    const usersWithOrders = await this.userRepo
      .createQueryBuilder("user")
      .innerJoinAndSelect("user.orders", "order")
      .take(5)
      .getMany();

    // LEFT JOIN - All users with their orders (including users without orders)
    const allUsersWithOrders = await this.userRepo
      .createQueryBuilder("user")
      .leftJoinAndSelect("user.orders", "order")
      .take(5)
      .getMany();

    // Multiple JOINs - Users with orders and order items
    const detailedUserOrders = await this.userRepo
      .createQueryBuilder("user")
      .leftJoinAndSelect("user.orders", "order")
      .leftJoinAndSelect("order.orderItems", "orderItem")
      .leftJoinAndSelect("orderItem.product", "product")
      .where("user.role = :role", { role: "user" })
      .take(3)
      .getMany();

    // Subquery - Users who have made orders
    const usersWithOrdersSubquery = await this.userRepo
      .createQueryBuilder("user")
      .where("user.id IN (SELECT DISTINCT o.user_id FROM orders o)")
      .getMany();

    // JOIN with aggregation - Users with order count and total spent
    const userOrderStats = await this.userRepo
      .createQueryBuilder("user")
      .leftJoin("user.orders", "order")
      .select([
        "user.id",
        "user.firstName",
        "user.lastName",
        "user.email",
        "COUNT(order.id) as orderCount",
        "COALESCE(SUM(order.total), 0) as totalSpent",
      ])
      .groupBy("user.id, user.firstName, user.lastName, user.email")
      .having("COUNT(order.id) > 0")
      .orderBy("totalSpent", "DESC")
      .limit(10)
      .getRawMany();

    return {
      description: "JOIN operations and relationships",
      results: {
        usersWithOrders: usersWithOrders.length,
        allUsersWithOrders: allUsersWithOrders.length,
        detailedUserOrders: detailedUserOrders.length,
        usersWithOrdersSubquery: usersWithOrdersSubquery.length,
        userOrderStats: userOrderStats.length,
      },
      sampleUserOrderStats: userOrderStats.slice(0, 3),
      sqlExamples: [
        "SELECT u.*, o.* FROM users u INNER JOIN orders o ON u.id = o.user_id",
        "SELECT u.*, o.* FROM users u LEFT JOIN orders o ON u.id = o.user_id",
        "SELECT u.*, COUNT(o.id), SUM(o.total) FROM users u LEFT JOIN orders o ON u.id = o.user_id GROUP BY u.id",
        "SELECT * FROM users WHERE id IN (SELECT DISTINCT user_id FROM orders)",
      ],
    };
  }

  // Level 4: Aggregations and Analytics
  async demonstrateAggregations() {
    this.logger.log("=== AGGREGATIONS AND ANALYTICS ===");

    // Basic aggregations
    const basicStats = await this.orderRepo
      .createQueryBuilder("order")
      .select([
        "COUNT(*) as totalOrders",
        "SUM(order.total) as totalRevenue",
        "AVG(order.total) as averageOrderValue",
        "MIN(order.total) as minOrderValue",
        "MAX(order.total) as maxOrderValue",
      ])
      .getRawOne();

    // GROUP BY with aggregations - Revenue by month
    const monthlyRevenue = await this.orderRepo
      .createQueryBuilder("order")
      .select([
        "DATE_TRUNC('month', order.createdAt) as month",
        "COUNT(*) as orderCount",
        "SUM(order.total) as revenue",
        "AVG(order.total) as avgOrderValue",
      ])
      .groupBy("DATE_TRUNC('month', order.createdAt)")
      .orderBy("month", "DESC")
      .limit(12)
      .getRawMany();

    // Window functions - Order ranking by user
    const orderRankings = await this.dataSource.query(`
      SELECT 
        u.first_name,
        u.last_name,
        o.total,
        o.created_at,
        ROW_NUMBER() OVER (PARTITION BY o.user_id ORDER BY o.total DESC) as order_rank,
        RANK() OVER (ORDER BY o.total DESC) as global_rank
      FROM orders o
      JOIN users u ON o.user_id = u.id
      WHERE o.total > 100
      ORDER BY o.total DESC
      LIMIT 20
    `);

    // Common Table Expression (CTE) - Customer segments
    const customerSegments = await this.dataSource.query(`
      WITH customer_stats AS (
        SELECT 
          u.id,
          u.first_name,
          u.last_name,
          COUNT(o.id) as order_count,
          SUM(o.total) as total_spent,
          AVG(o.total) as avg_order_value
        FROM users u
        LEFT JOIN orders o ON u.id = o.user_id
        GROUP BY u.id, u.first_name, u.last_name
      )
      SELECT 
        *,
        CASE 
          WHEN total_spent > 1000 THEN 'VIP'
          WHEN total_spent > 500 THEN 'Premium'
          WHEN total_spent > 100 THEN 'Regular'
          ELSE 'New'
        END as customer_segment
      FROM customer_stats
      ORDER BY total_spent DESC NULLS LAST
      LIMIT 20
    `);

    // Product popularity analysis
    const productPopularity = await this.dataSource.query(`
      SELECT 
        p.title,
        p.price,
        COUNT(oi.id) as times_ordered,
        SUM(oi.quantity) as total_quantity_sold,
        SUM(oi.total) as total_revenue,
        AVG(oi.quantity) as avg_quantity_per_order
      FROM products p
      LEFT JOIN order_items oi ON p.id = oi.product_id
      GROUP BY p.id, p.title, p.price
      HAVING COUNT(oi.id) > 0
      ORDER BY total_revenue DESC
      LIMIT 15
    `);

    return {
      description: "Aggregations and analytics operations",
      basicStats: {
        totalOrders: parseInt(basicStats.totalorders),
        totalRevenue: parseFloat(basicStats.totalrevenue),
        averageOrderValue: parseFloat(basicStats.averageordervalue),
        minOrderValue: parseFloat(basicStats.minordervalue),
        maxOrderValue: parseFloat(basicStats.maxordervalue),
      },
      monthlyRevenue: monthlyRevenue.slice(0, 6),
      topOrderRankings: orderRankings.slice(0, 5),
      customerSegments: customerSegments.slice(0, 5),
      topProducts: productPopularity.slice(0, 5),
      sqlFeatures: [
        "SUM, COUNT, AVG, MIN, MAX",
        "GROUP BY with DATE_TRUNC",
        "Window functions (ROW_NUMBER, RANK)",
        "Common Table Expressions (WITH)",
        "CASE statements for conditional logic",
      ],
    };
  }

  // Level 5: Advanced PostgreSQL Features
  async demonstrateAdvancedFeatures() {
    this.logger.log("=== ADVANCED POSTGRESQL FEATURES ===");

    // JSON/JSONB operations
    const jsonQueries = await this.demonstrateJSONOperations();

    // Array operations
    const arrayQueries = await this.demonstrateArrayOperations();

    // Full-text search
    const fullTextSearch = await this.demonstrateFullTextSearch();

    // Date/Time operations
    const dateOperations = await this.demonstrateDateOperations();

    return {
      description: "Advanced PostgreSQL features",
      features: {
        jsonOperations: jsonQueries,
        arrayOperations: arrayQueries,
        fullTextSearch: fullTextSearch,
        dateOperations: dateOperations,
      },
    };
  }

  private async demonstrateJSONOperations() {
    // Query JSON fields in user profiles
    const usersInCity = await this.dataSource.query(`
      SELECT 
        u.first_name,
        u.last_name,
        up.address->>'city' as city,
        up.address->>'state' as state,
        up.preferences->>'theme' as theme
      FROM users u
      JOIN user_profiles up ON u.profile_id = up.id
      WHERE up.address->>'city' IS NOT NULL
      LIMIT 10
    `);

    // JSON aggregation
    const cityStats = await this.dataSource.query(`
      SELECT 
        up.address->>'city' as city,
        COUNT(*) as user_count,
        COUNT(o.id) as order_count,
        COALESCE(SUM(o.total), 0) as total_revenue
      FROM user_profiles up
      JOIN users u ON u.profile_id = up.id
      LEFT JOIN orders o ON u.id = o.user_id
      WHERE up.address->>'city' IS NOT NULL
      GROUP BY up.address->>'city'
      ORDER BY user_count DESC
      LIMIT 10
    `);

    return {
      usersInCity: usersInCity.length,
      cityStats: cityStats.slice(0, 5),
      jsonFeatures: [
        "JSON field access with ->>",
        "JSON path queries",
        "JSON aggregations",
        "JSONB indexing for performance",
      ],
    };
  }

  private async demonstrateArrayOperations() {
    // Array operations with product tags
    const productsWithTags = await this.dataSource.query(`
      SELECT 
        title,
        tags,
        array_length(tags, 1) as tag_count,
        'electronics' = ANY(tags) as has_electronics_tag
      FROM products
      WHERE tags IS NOT NULL
      AND array_length(tags, 1) > 2
      LIMIT 10
    `);

    // Unnest arrays for analysis
    const tagAnalysis = await this.dataSource.query(`
      SELECT 
        unnest(tags) as tag,
        COUNT(*) as usage_count
      FROM products
      WHERE tags IS NOT NULL
      GROUP BY unnest(tags)
      ORDER BY usage_count DESC
      LIMIT 15
    `);

    return {
      productsWithTags: productsWithTags.length,
      topTags: tagAnalysis.slice(0, 10),
      arrayFeatures: [
        "Array length and element access",
        "ANY/ALL operators for array queries",
        "UNNEST for array expansion",
        "Array aggregation functions",
      ],
    };
  }

  private async demonstrateFullTextSearch() {
    // Full-text search on products
    const searchResults = await this.dataSource.query(`
      SELECT 
        title,
        description,
        ts_rank(to_tsvector('english', title || ' ' || description), plainto_tsquery('electronic laptop')) as rank
      FROM products
      WHERE to_tsvector('english', title || ' ' || description) @@ plainto_tsquery('electronic laptop')
      ORDER BY rank DESC
      LIMIT 10
    `);

    // Search with highlighting
    const highlightedResults = await this.dataSource.query(`
      SELECT 
        title,
        ts_headline('english', description, plainto_tsquery('smartphone camera'), 'StartSel=<mark>, StopSel=</mark>') as highlighted_description
      FROM products
      WHERE to_tsvector('english', title || ' ' || description) @@ plainto_tsquery('smartphone camera')
      LIMIT 5
    `);

    return {
      searchResults: searchResults.length,
      highlightedResults: highlightedResults.slice(0, 3),
      searchFeatures: [
        "to_tsvector for full-text indexing",
        "plainto_tsquery for search queries",
        "ts_rank for relevance scoring",
        "ts_headline for result highlighting",
      ],
    };
  }

  private async demonstrateDateOperations() {
    // Date range queries
    const recentOrders = await this.dataSource.query(`
      SELECT 
        DATE_TRUNC('day', created_at) as order_date,
        COUNT(*) as order_count,
        SUM(total) as daily_revenue
      FROM orders
      WHERE created_at >= NOW() - INTERVAL '30 days'
      GROUP BY DATE_TRUNC('day', created_at)
      ORDER BY order_date DESC
      LIMIT 10
    `);

    // Age calculations
    const userAgeAnalysis = await this.dataSource.query(`
      SELECT 
        EXTRACT(YEAR FROM AGE(date_of_birth)) as age,
        COUNT(*) as user_count,
        AVG(EXTRACT(YEAR FROM AGE(date_of_birth))) OVER() as avg_age
      FROM users
      GROUP BY age
      ORDER BY age
      LIMIT 10
    `);

    return {
      recentOrders: recentOrders.slice(0, 7),
      ageAnalysis: userAgeAnalysis.slice(0, 5),
      dateFeatures: [
        "DATE_TRUNC for date grouping",
        "INTERVAL for date arithmetic",
        "EXTRACT for date parts",
        "AGE function for age calculations",
      ],
    };
  }

  // Transaction Examples
  async demonstrateTransactions() {
    this.logger.log("=== TRANSACTION EXAMPLES ===");

    const queryRunner = this.dataSource.createQueryRunner();
    await queryRunner.connect();
    await queryRunner.startTransaction();

    try {
      // Create user and profile in transaction
      const userData = {
        firstName: "Transaction",
        lastName: "User",
        email: "transaction.user@example.com",
        phoneNumber: "+1111111111",
        dateOfBirth: new Date("1995-01-01"),
        role: "user" as const,
      };

      const user = await queryRunner.manager.save(User, userData);

      const profileData = {
        bio: "Created in transaction",
        preferences: {
          newsletter: true,
          notifications: true,
          theme: "light" as const,
        },
        address: {
          street: "123 Transaction St",
          city: "Database City",
          state: "TX",
          zipCode: "12345",
          country: "USA",
        },
      };

      const profile = await queryRunner.manager.save(
        "UserProfile",
        profileData
      );

      // Update user with profile reference
      await queryRunner.manager.update(User, user.id, {
        profile: { id: profile.id },
      });

      // Commit transaction
      await queryRunner.commitTransaction();

      return {
        success: true,
        description: "Transaction completed successfully",
        createdUserId: user.id,
        createdProfileId: profile.id,
        transactionFeatures: [
          "BEGIN/COMMIT for transaction boundaries",
          "ROLLBACK on errors",
          "Consistent state across multiple operations",
          "ACID compliance",
        ],
      };
    } catch (error) {
      // Rollback on error
      await queryRunner.rollbackTransaction();

      return {
        success: false,
        description: "Transaction rolled back due to error",
        error: error.message,
        transactionFeatures: [
          "Automatic rollback on errors",
          "Data consistency maintained",
          "No partial updates",
        ],
      };
    } finally {
      await queryRunner.release();
    }
  }

  // Performance Analysis
  async demonstratePerformanceAnalysis() {
    this.logger.log("=== PERFORMANCE ANALYSIS ===");

    // Explain query plan
    const explainResult = await this.dataSource.query(`
      EXPLAIN (ANALYZE, BUFFERS, FORMAT JSON)
      SELECT 
        u.first_name,
        u.last_name,
        COUNT(o.id) as order_count,
        SUM(o.total) as total_spent
      FROM users u
      LEFT JOIN orders o ON u.id = o.user_id
      WHERE u.created_at >= NOW() - INTERVAL '6 months'
      GROUP BY u.id, u.first_name, u.last_name
      HAVING COUNT(o.id) > 0
      ORDER BY total_spent DESC
      LIMIT 20
    `);

    // Index usage analysis
    const indexUsage = await this.dataSource.query(`
      SELECT 
        schemaname,
        tablename,
        indexname,
        idx_tup_read,
        idx_tup_fetch
      FROM pg_stat_user_indexes
      WHERE schemaname = 'public'
      ORDER BY idx_tup_read DESC
      LIMIT 10
    `);

    // Table size analysis
    const tableSize = await this.dataSource.query(`
      SELECT 
        table_name,
        pg_size_pretty(pg_total_relation_size(quote_ident(table_name))) as size
      FROM information_schema.tables
      WHERE table_schema = 'public'
      AND table_type = 'BASE TABLE'
      ORDER BY pg_total_relation_size(quote_ident(table_name)) DESC
    `);

    return {
      description: "Performance analysis tools",
      queryPlan: explainResult[0],
      indexUsage: indexUsage,
      tableSize: tableSize,
      performanceFeatures: [
        "EXPLAIN ANALYZE for query analysis",
        "pg_stat_user_indexes for index monitoring",
        "pg_size_pretty for size analysis",
        "Query optimization recommendations",
      ],
    };
  }
}
```

### Step 2: pgAdmin Integration Guide

**File: section-3/analytics-service/src/controllers/postgres-admin.controller.ts**

```typescript
import { Controller, Get, Post, Query, Param } from "@nestjs/common";
import { ApiTags, ApiOperation, ApiQuery, ApiParam } from "@nestjs/swagger";
import { PostgresOperationsService } from "../services/postgres-operations.service";

@ApiTags("PostgreSQL Operations & Admin")
@Controller("postgres-admin")
export class PostgresAdminController {
  constructor(private readonly postgresService: PostgresOperationsService) {}

  @Get("basic-crud")
  @ApiOperation({ summary: "Demonstrate basic CRUD operations" })
  async basicCRUD() {
    return this.postgresService.demonstrateBasicCRUD();
  }

  @Get("filtering-sorting")
  @ApiOperation({ summary: "Demonstrate filtering and sorting operations" })
  async filteringAndSorting() {
    return this.postgresService.demonstrateFilteringAndSorting();
  }

  @Get("joins")
  @ApiOperation({ summary: "Demonstrate JOIN operations and relationships" })
  async joins() {
    return this.postgresService.demonstrateJoins();
  }

  @Get("aggregations")
  @ApiOperation({ summary: "Demonstrate aggregations and analytics" })
  async aggregations() {
    return this.postgresService.demonstrateAggregations();
  }

  @Get("advanced-features")
  @ApiOperation({ summary: "Demonstrate advanced PostgreSQL features" })
  async advancedFeatures() {
    return this.postgresService.demonstrateAdvancedFeatures();
  }

  @Post("transactions")
  @ApiOperation({ summary: "Demonstrate transaction handling" })
  async transactions() {
    return this.postgresService.demonstrateTransactions();
  }

  @Get("performance-analysis")
  @ApiOperation({
    summary: "Analyze query performance and database statistics",
  })
  async performanceAnalysis() {
    return this.postgresService.demonstratePerformanceAnalysis();
  }

  @Get("all-operations")
  @ApiOperation({ summary: "Run all PostgreSQL operations demonstrations" })
  async allOperations() {
    const results = await Promise.all([
      this.postgresService.demonstrateBasicCRUD(),
      this.postgresService.demonstrateFilteringAndSorting(),
      this.postgresService.demonstrateJoins(),
      this.postgresService.demonstrateAggregations(),
      this.postgresService.demonstrateAdvancedFeatures(),
    ]);

    return {
      description: "Complete PostgreSQL operations demonstration",
      totalOperations: results.length,
      results: results,
      note: "Check application logs for detailed SQL queries",
    };
  }
}
```

### Step 3: pgAdmin Setup and Usage Guide

**File: section-3/analytics-service/docs/pgadmin-setup.md**

````markdown
# pgAdmin Setup and Usage Guide

## Docker Compose Setup

Add pgAdmin to your docker-compose.yml:

```yaml
services:
  pgadmin:
    image: dpage/pgadmin4:latest
    container_name: pgadmin
    environment:
      PGADMIN_DEFAULT_EMAIL: admin@example.com
      PGADMIN_DEFAULT_PASSWORD: admin123
      PGADMIN_LISTEN_PORT: 80
    ports:
      - "5050:80"
    volumes:
      - pgadmin_data:/var/lib/pgadmin
    depends_on:
      - postgres
    networks:
      - postgres-network

  postgres:
    image: postgres:15-alpine
    container_name: postgres-db
    environment:
      POSTGRES_DB: microservices_analytics
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: password123
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
    networks:
      - postgres-network

volumes:
  postgres_data:
  pgadmin_data:

networks:
  postgres-network:
    driver: bridge
```
````

## Accessing pgAdmin

1. Start containers: `docker-compose up -d`
2. Open browser: `http://localhost:5050`
3. Login with:
   - Email: admin@example.com
   - Password: admin123

## Adding Server Connection

1. Right-click "Servers" → "Register" → "Server"
2. General tab:
   - Name: Analytics DB
3. Connection tab:
   - Host: postgres
   - Port: 5432
   - Database: microservices_analytics
   - Username: postgres
   - Password: password123

## Essential pgAdmin Features

### 1. Query Tool

- SQL editor with syntax highlighting
- Query execution and result viewing
- Query history and favorites
- Export results to CSV/JSON

### 2. Database Administration

- View table structure and data
- Manage indexes and constraints
- Monitor active connections
- Backup and restore databases

### 3. Performance Monitoring

- Query execution plans
- Server activity monitoring
- Lock monitoring
- Statistics and charts

## Common pgAdmin Tasks

### View Table Data

```sql
-- View first 100 rows
SELECT * FROM users LIMIT 100;

-- View with specific columns
SELECT first_name, last_name, email, created_at
FROM users
ORDER BY created_at DESC;
```

### Analyze Table Structure

```sql
-- Table information
\d users

-- Index information
SELECT indexname, indexdef
FROM pg_indexes
WHERE tablename = 'users';

-- Foreign key constraints
SELECT tc.constraint_name, tc.table_name, kcu.column_name,
       ccu.table_name AS foreign_table_name,
       ccu.column_name AS foreign_column_name
FROM information_schema.table_constraints AS tc
JOIN information_schema.key_column_usage AS kcu
  ON tc.constraint_name = kcu.constraint_name
JOIN information_schema.constraint_column_usage AS ccu
  ON ccu.constraint_name = tc.constraint_name
WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = 'users';
```

### Performance Analysis

```sql
-- Query execution plan
EXPLAIN ANALYZE
SELECT u.*, COUNT(o.id) as order_count
FROM users u
LEFT JOIN orders o ON u.id = o.user_id
GROUP BY u.id;

-- Index usage statistics
SELECT schemaname, tablename, indexname, idx_scan, idx_tup_read
FROM pg_stat_user_indexes
ORDER BY idx_scan DESC;

-- Table size information
SELECT
    table_name,
    pg_size_pretty(pg_total_relation_size(quote_ident(table_name))) as size
FROM information_schema.tables
WHERE table_schema = 'public'
ORDER BY pg_total_relation_size(quote_ident(table_name)) DESC;
```

### Database Maintenance

```sql
-- Update table statistics
ANALYZE users;

-- Reindex table
REINDEX TABLE users;

-- Vacuum table (cleanup)
VACUUM ANALYZE users;

-- Check database size
SELECT pg_size_pretty(pg_database_size('microservices_analytics'));
```

````

### Step 4: Advanced Query Examples

**File: section-3/analytics-service/src/queries/advanced-queries.sql**
```sql
-- Advanced PostgreSQL Query Examples

-- 1. Recursive CTE - Product Category Hierarchy (if you had parent-child categories)
WITH RECURSIVE category_hierarchy AS (
  -- Base case: top-level categories
  SELECT id, name, description, 0 as level, ARRAY[name] as path
  FROM categories
  WHERE name LIKE '%Electronics%'

  UNION ALL

  -- Recursive case: child categories (placeholder - adapt based on your schema)
  SELECT c.id, c.name, c.description, ch.level + 1, ch.path || c.name
  FROM categories c
  INNER JOIN category_hierarchy ch ON c.name LIKE '%' || ch.name || '%'
  WHERE ch.level < 3
)
SELECT * FROM category_hierarchy ORDER BY level, name;

-- 2. Advanced Window Functions - Customer Ranking and Percentiles
WITH customer_metrics AS (
  SELECT
    u.id,
    u.first_name || ' ' || u.last_name as full_name,
    COUNT(o.id) as order_count,
    COALESCE(SUM(o.total), 0) as total_spent,
    COALESCE(AVG(o.total), 0) as avg_order_value
  FROM users u
  LEFT JOIN orders o ON u.id = o.user_id
  GROUP BY u.id, u.first_name, u.last_name
)
SELECT
  full_name,
  order_count,
  total_spent,
  avg_order_value,
  -- Ranking functions
  ROW_NUMBER() OVER (ORDER BY total_spent DESC) as spending_rank,
  DENSE_RANK() OVER (ORDER BY order_count DESC) as order_frequency_rank,
  -- Percentile functions
  NTILE(4) OVER (ORDER BY total_spent) as spending_quartile,
  PERCENT_RANK() OVER (ORDER BY total_spent) as spending_percentile,
  -- Running totals
  SUM(total_spent) OVER (ORDER BY total_spent DESC ROWS UNBOUNDED PRECEDING) as cumulative_revenue,
  -- Lag/Lead functions
  LAG(total_spent, 1) OVER (ORDER BY total_spent DESC) as next_customer_spending
FROM customer_metrics
WHERE order_count > 0
ORDER BY total_spent DESC
LIMIT 20;

-- 3. Advanced JSON Operations - User Preferences Analysis
SELECT
  up.preferences->>'theme' as theme_preference,
  up.preferences->>'newsletter' as newsletter_subscription,
  COUNT(*) as user_count,
  AVG(COALESCE(user_stats.total_spent, 0)) as avg_spending,
  STRING_AGG(DISTINCT up.address->>'state', ', ' ORDER BY up.address->>'state') as states
FROM user_profiles up
JOIN users u ON u.profile_id = up.id
LEFT JOIN (
  SELECT
    user_id,
    SUM(total) as total_spent
  FROM orders
  GROUP BY user_id
) user_stats ON u.id = user_stats.user_id
WHERE up.preferences IS NOT NULL
GROUP BY up.preferences->>'theme', up.preferences->>'newsletter'
ORDER BY user_count DESC;

-- 4. Advanced Date/Time Operations - Sales Trends
WITH daily_sales AS (
  SELECT
    DATE(created_at) as sale_date,
    COUNT(*) as order_count,
    SUM(total) as daily_revenue,
    AVG(total) as avg_order_value
  FROM orders
  WHERE created_at >= CURRENT_DATE - INTERVAL '90 days'
  GROUP BY DATE(created_at)
),
sales_with_trends AS (
  SELECT
    sale_date,
    order_count,
    daily_revenue,
    avg_order_value,
    -- Moving averages
    AVG(daily_revenue) OVER (
      ORDER BY sale_date
      ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
    ) as seven_day_avg_revenue,
    -- Growth calculations
    LAG(daily_revenue, 1) OVER (ORDER BY sale_date) as prev_day_revenue,
    LAG(daily_revenue, 7) OVER (ORDER BY sale_date) as same_day_last_week
  FROM daily_sales
)
SELECT
  sale_date,
  daily_revenue,
  seven_day_avg_revenue,
  CASE
    WHEN prev_day_revenue IS NOT NULL THEN
      ROUND(((daily_revenue - prev_day_revenue) / prev_day_revenue * 100)::numeric, 2)
  END as day_over_day_growth_pct,
  CASE
    WHEN same_day_last_week IS NOT NULL THEN
      ROUND(((daily_revenue - same_day_last_week) / same_day_last_week * 100)::numeric, 2)
  END as week_over_week_growth_pct
FROM sales_with_trends
ORDER BY sale_date DESC
LIMIT 30;

-- 5. Product Cohort Analysis - Products bought together
WITH product_pairs AS (
  SELECT
    oi1.product_id as product_a,
    oi2.product_id as product_b,
    COUNT(*) as times_bought_together
  FROM order_items oi1
  JOIN order_items oi2 ON oi1.order_id = oi2.order_id
    AND oi1.product_id < oi2.product_id
  GROUP BY oi1.product_id, oi2.product_id
  HAVING COUNT(*) > 2
)
SELECT
  pa.title as product_a_name,
  pb.title as product_b_name,
  pp.times_bought_together,
  ROUND((pp.times_bought_together::float /
    (SELECT COUNT(DISTINCT order_id) FROM order_items WHERE product_id = pp.product_a) * 100
  )::numeric, 2) as co_purchase_rate_pct
FROM product_pairs pp
JOIN products pa ON pp.product_a = pa.id
JOIN products pb ON pp.product_b = pb.id
ORDER BY times_bought_together DESC
LIMIT 20;

-- 6. Advanced Full-Text Search with Ranking
SELECT
  p.title,
  p.price,
  c.name as category,
  ts_rank_cd(
    to_tsvector('english', p.title || ' ' || p.description),
    plainto_tsquery('english', 'wireless bluetooth headphone')
  ) as relevance_score,
  ts_headline(
    'english',
    p.description,
    plainto_tsquery('english', 'wireless bluetooth headphone'),
    'StartSel=<mark>, StopSel=</mark>, MaxWords=50'
  ) as highlighted_description
FROM products p
JOIN product_categories pc ON p.id = pc.product_id
JOIN categories c ON pc.category_id = c.id
WHERE to_tsvector('english', p.title || ' ' || p.description)
  @@ plainto_tsquery('english', 'wireless bluetooth headphone')
ORDER BY relevance_score DESC, p.price ASC
LIMIT 10;

-- 7. Geographic Analysis (if you have address data)
WITH geographic_stats AS (
  SELECT
    up.address->>'state' as state,
    up.address->>'city' as city,
    COUNT(DISTINCT u.id) as user_count,
    COUNT(o.id) as order_count,
    COALESCE(SUM(o.total), 0) as total_revenue,
    COALESCE(AVG(o.total), 0) as avg_order_value
  FROM user_profiles up
  JOIN users u ON u.profile_id = up.id
  LEFT JOIN orders o ON u.id = o.user_id
  WHERE up.address->>'state' IS NOT NULL
  GROUP BY up.address->>'state', up.address->>'city'
)
SELECT
  state,
  city,
  user_count,
  order_count,
  total_revenue,
  avg_order_value,
  ROUND((total_revenue / SUM(total_revenue) OVER (PARTITION BY state) * 100)::numeric, 2) as state_revenue_share_pct
FROM geographic_stats
WHERE order_count > 0
ORDER BY state, total_revenue DESC;

-- 8. Advanced Inventory and Stock Analysis
SELECT
  p.title,
  p.stock_quantity,
  COALESCE(SUM(oi.quantity), 0) as total_sold,
  ROUND(
    CASE
      WHEN p.stock_quantity > 0 THEN
        (COALESCE(SUM(oi.quantity), 0)::float / p.stock_quantity * 100)
    END::numeric, 2
  ) as stock_turnover_pct,
  -- Sales velocity (items per day)
  ROUND(
    (COALESCE(SUM(oi.quantity), 0)::float /
     GREATEST(1, DATE_PART('days', NOW() - MIN(o.created_at)))
    )::numeric, 2
  ) as daily_sales_velocity,
  -- Revenue per unit
  ROUND(
    (COALESCE(SUM(oi.total), 0) / GREATEST(1, COALESCE(SUM(oi.quantity), 0)))::numeric, 2
  ) as revenue_per_unit
FROM products p
LEFT JOIN order_items oi ON p.id = oi.product_id
LEFT JOIN orders o ON oi.order_id = o.id
WHERE p.is_active = true
GROUP BY p.id, p.title, p.stock_quantity
HAVING COALESCE(SUM(oi.quantity), 0) > 0
ORDER BY daily_sales_velocity DESC
LIMIT 20;
````

### Step 5: Query Testing Interface

**File: section-3/analytics-service/test-postgres-operations.http**

```http
### Test Basic CRUD Operations
GET http://localhost:3005/postgres-admin/basic-crud

### Test Filtering and Sorting
GET http://localhost:3005/postgres-admin/filtering-sorting

### Test JOIN Operations
GET http://localhost:3005/postgres-admin/joins

### Test Aggregations and Analytics
GET http://localhost:3005/postgres-admin/aggregations

### Test Advanced PostgreSQL Features
GET http://localhost:3005/postgres-admin/advanced-features

### Test Transaction Handling
POST http://localhost:3005/postgres-admin/transactions

### Test Performance Analysis
GET http://localhost:3005/postgres-admin/performance-analysis

### Run All Operations
GET http://localhost:3005/postgres-admin/all-operations
```

## pgAdmin Practical Exercises

### Exercise 1: Database Exploration

1. Connect to the database using pgAdmin
2. Explore the table structure
3. Examine indexes and constraints
4. Review foreign key relationships

### Exercise 2: Query Building

1. Use the Query Tool to write and execute queries
2. Start with simple SELECT statements
3. Progress to complex JOINs and aggregations
4. Use EXPLAIN to analyze query performance

### Exercise 3: Performance Optimization

1. Identify slow-running queries
2. Analyze query execution plans
3. Create or modify indexes
4. Compare performance before and after optimization

### Exercise 4: Data Analysis

1. Create analytical queries for business insights
2. Use window functions for advanced analytics
3. Export results for further analysis
4. Create visualizations from query results

## Key Learning Points

### TypeORM Query Patterns

1. **Repository Methods**: Simple CRUD operations
2. **Query Builder**: Complex queries with type safety
3. **Raw Queries**: Full PostgreSQL feature access
4. **Transactions**: Data consistency and error handling

### PostgreSQL Advanced Features

1. **JSON/JSONB**: Semi-structured data handling
2. **Arrays**: Complex data types and operations
3. **Full-Text Search**: Advanced search capabilities
4. **Window Functions**: Advanced analytics

### pgAdmin Administration

1. **Database Exploration**: Understanding schema and data
2. **Query Development**: Building and testing queries
3. **Performance Monitoring**: Identifying bottlenecks
4. **Maintenance Tasks**: Backup, restore, and optimization

This comprehensive exercise provides hands-on experience with PostgreSQL from basic operations to advanced database administration and optimization techniques.

---

## References and Resources

### PostgreSQL Documentation

- [PostgreSQL Official Docs](https://www.postgresql.org/docs/) - Complete PostgreSQL documentation
- [PostgreSQL Query Optimization](https://www.postgresql.org/docs/current/performance-tips.html) - Performance tuning guide
- [PostgreSQL JSON Functions](https://www.postgresql.org/docs/current/functions-json.html) - JSON/JSONB operations

### TypeORM Documentation

- [TypeORM Query Builder](https://typeorm.io/select-query-builder) - Advanced querying with TypeORM
- [TypeORM Raw Queries](https://typeorm.io/select-query-builder#using-raw-sql) - Executing raw SQL
- [TypeORM Transactions](https://typeorm.io/transactions) - Transaction management

### pgAdmin Resources

- [pgAdmin Documentation](https://www.pgadmin.org/docs/) - Complete pgAdmin guide
- [pgAdmin Query Tool](https://www.pgadmin.org/docs/pgadmin4/latest/query_tool.html) - Query editor features
- [Database Administration](https://www.postgresql.org/docs/current/admin.html) - PostgreSQL administration guide
