# Working with External APIs

## Overview

This exercise demonstrates how to integrate external APIs into microservices, focusing on implementing Amazon SES (Simple Email Service) in our notification service. You'll learn to handle external API authentication, error handling, and graceful degradation when external services are unavailable.

## Learning Objectives

- Integrate Amazon SES for email notifications
- Implement external API error handling and retry logic
- Use environment variables for API configuration
- Create fallback mechanisms for external service failures
- Practice external API testing and monitoring
- Understand API rate limiting and throttling

## External API Integration Patterns

### 1. External API Communication Flow

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚             EXTERNAL API INTEGRATION PATTERN           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                         â”‚
â”‚  Internal Service Flow:                                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    Trigger      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚  â”‚Order Serviceâ”‚ â”€â”€â”€â”€ Event â”€â”€â”€â”€â–¶ â”‚Notification Service â”‚â”‚
â”‚  â”‚             â”‚                  â”‚                     â”‚â”‚
â”‚  â”‚ "Order      â”‚                  â”‚ Process Event       â”‚â”‚
â”‚  â”‚ Created"    â”‚                  â”‚ Prepare Email       â”‚â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â”‚                                             â”‚             â”‚
â”‚                                             â–¼             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚            External API Integration                 â”‚ â”‚
â”‚  â”‚                                                     â”‚ â”‚
â”‚  â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    HTTPS     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚ â”‚
â”‚  â”‚ â”‚Notification â”‚ â”€â”€â”€â”€ Call â”€â”€â–¶ â”‚   Amazon SES        â”‚â”‚ â”‚
â”‚  â”‚ â”‚ Service     â”‚              â”‚                     â”‚â”‚ â”‚
â”‚  â”‚ â”‚             â”‚ â—€â”€â”€ Response â”€â”‚ â€¢ Authentication    â”‚â”‚ â”‚
â”‚  â”‚ â”‚ â€¢ Retry     â”‚              â”‚ â€¢ Rate Limiting     â”‚â”‚ â”‚
â”‚  â”‚ â”‚ â€¢ Fallback  â”‚              â”‚ â€¢ Error Handling    â”‚â”‚ â”‚
â”‚  â”‚ â”‚ â€¢ Circuit   â”‚              â”‚ â€¢ Delivery Status   â”‚â”‚ â”‚
â”‚  â”‚ â”‚   Breaker   â”‚              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚ â”‚
â”‚  â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                     â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                         â”‚
â”‚  Fallback Strategies:                                  â”‚
â”‚  â€¢ Retry with exponential backoff                     â”‚
â”‚  â€¢ Circuit breaker for failed services                â”‚
â”‚  â€¢ Queue messages for later processing                â”‚
â”‚  â€¢ Alternative email providers                        â”‚
â”‚  â€¢ Local SMTP server as backup                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2. API Error Handling Strategy

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                API ERROR HANDLING MATRIX               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                         â”‚
â”‚  Error Type         â”‚ Strategy        â”‚ Action          â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
â”‚  4xx Client Errors  â”‚                â”‚                 â”‚
â”‚  â€¢ 400 Bad Request  â”‚ Fix & Retry     â”‚ Validate data   â”‚
â”‚  â€¢ 401 Unauthorized â”‚ Re-authenticate â”‚ Refresh token   â”‚
â”‚  â€¢ 403 Forbidden    â”‚ Check Config    â”‚ Verify perms    â”‚
â”‚  â€¢ 429 Rate Limit   â”‚ Backoff & Retry â”‚ Respect limits  â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
â”‚  5xx Server Errors  â”‚                â”‚                 â”‚
â”‚  â€¢ 500 Server Error â”‚ Retry           â”‚ Exponential BO  â”‚
â”‚  â€¢ 502 Bad Gateway  â”‚ Retry           â”‚ Circuit breaker â”‚
â”‚  â€¢ 503 Unavailable  â”‚ Queue & Retry   â”‚ Use fallback    â”‚
â”‚  â€¢ 504 Timeout      â”‚ Extend timeout  â”‚ Retry shorter   â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
â”‚  Network Errors     â”‚                â”‚                 â”‚
â”‚  â€¢ Connection Ref.  â”‚ Retry           â”‚ Check health    â”‚
â”‚  â€¢ DNS Resolution   â”‚ Cache & Retry   â”‚ Alt endpoints   â”‚
â”‚  â€¢ SSL/TLS Issues   â”‚ Check Certs     â”‚ Update config   â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
â”‚  Business Errors    â”‚                â”‚                 â”‚
â”‚  â€¢ Quota Exceeded   â”‚ Queue           â”‚ Wait for reset  â”‚
â”‚  â€¢ Invalid Content  â”‚ Transform       â”‚ Fix formatting  â”‚
â”‚  â€¢ Blocked Account  â”‚ Alert & Stop    â”‚ Human review    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Exercise: Implementing Amazon SES Integration

### Step 1: AWS SES Setup and Configuration

First, let's set up Amazon SES for email sending.

**Install AWS SDK:**

```bash
# Navigate to notification-service directory
cd notification-service

# Install AWS SDK
npm install aws-sdk
npm install @aws-sdk/client-ses

# Install additional dependencies for email templates
npm install handlebars
npm install @types/handlebars --save-dev
```

**Update `.env` file in notification-service:**

```env
# Existing configuration...
PORT=3004
NODE_ENV=development
MONGODB_URI=mongodb://localhost:27017/notification_service

# AWS SES Configuration
AWS_REGION=us-east-1
AWS_ACCESS_KEY_ID=your_aws_access_key
AWS_SECRET_ACCESS_KEY=your_aws_secret_key
AWS_SES_FROM_EMAIL=noreply@yourdomain.com
AWS_SES_REPLY_TO_EMAIL=support@yourdomain.com

# Email Configuration
EMAIL_PROVIDER=aws-ses
SMTP_FALLBACK_HOST=localhost
SMTP_FALLBACK_PORT=587
SMTP_FALLBACK_USER=
SMTP_FALLBACK_PASS=

# Rate Limiting
EMAIL_RATE_LIMIT_PER_SECOND=14
EMAIL_RATE_LIMIT_PER_DAY=200

# Retry Configuration
EMAIL_RETRY_ATTEMPTS=3
EMAIL_RETRY_DELAY=1000
EMAIL_CIRCUIT_BREAKER_THRESHOLD=5
```

**For Development (using AWS SES Sandbox):**

```env
# Development/Sandbox mode
AWS_SES_SANDBOX_MODE=true
AWS_SES_VERIFIED_EMAIL=your-verified-email@example.com
```

### Step 2: AWS SES Service Implementation

Create a comprehensive email service with error handling.

**Create `src/services/email.service.ts`:**

```typescript
import { Injectable, Logger } from "@nestjs/common";
import { ConfigService } from "@nestjs/config";
import {
  SESClient,
  SendEmailCommand,
  SendEmailCommandInput,
  SESClientConfig,
} from "@aws-sdk/client-ses";
import * as Handlebars from "handlebars";
import * as fs from "fs";
import * as path from "path";

export interface EmailOptions {
  to: string | string[];
  subject: string;
  textBody?: string;
  htmlBody?: string;
  template?: string;
  templateData?: any;
  replyTo?: string;
  attachments?: EmailAttachment[];
}

export interface EmailAttachment {
  filename: string;
  content: Buffer;
  contentType: string;
}

export interface EmailResult {
  success: boolean;
  messageId?: string;
  error?: string;
  provider: string;
  timestamp: Date;
}

@Injectable()
export class EmailService {
  private readonly logger = new Logger(EmailService.name);
  private sesClient: SESClient;
  private rateLimit: {
    perSecond: number;
    perDay: number;
    sentToday: number;
    lastReset: Date;
  };

  constructor(private configService: ConfigService) {
    this.initializeSES();
    this.initializeRateLimit();
  }

  private initializeSES() {
    const awsConfig: SESClientConfig = {
      region: this.configService.get<string>("AWS_REGION"),
      credentials: {
        accessKeyId: this.configService.get<string>("AWS_ACCESS_KEY_ID"),
        secretAccessKey: this.configService.get<string>(
          "AWS_SECRET_ACCESS_KEY"
        ),
      },
    };

    this.sesClient = new SESClient(awsConfig);
    this.logger.log("AWS SES client initialized");
  }

  private initializeRateLimit() {
    this.rateLimit = {
      perSecond: this.configService.get<number>(
        "EMAIL_RATE_LIMIT_PER_SECOND",
        14
      ),
      perDay: this.configService.get<number>("EMAIL_RATE_LIMIT_PER_DAY", 200),
      sentToday: 0,
      lastReset: new Date(),
    };
  }

  async sendEmail(options: EmailOptions): Promise<EmailResult> {
    const startTime = Date.now();

    try {
      // Check rate limits
      this.checkRateLimit();

      // Prepare email content
      const emailContent = await this.prepareEmailContent(options);

      // Validate recipients (important for SES sandbox)
      this.validateRecipients(options.to);

      // Send via AWS SES
      const result = await this.sendViaSES(emailContent);

      // Update rate limit counters
      this.updateRateLimit();

      // Log success
      this.logger.log(
        `Email sent successfully via AWS SES: ${result.messageId} (${
          Date.now() - startTime
        }ms)`
      );

      return {
        success: true,
        messageId: result.messageId,
        provider: "aws-ses",
        timestamp: new Date(),
      };
    } catch (error) {
      this.logger.error(
        `Email sending failed via AWS SES: ${error.message}`,
        error.stack
      );

      // Try fallback if configured
      if (this.shouldUseFallback(error)) {
        this.logger.warn("Attempting fallback email delivery...");
        return await this.sendViaFallback(options);
      }

      return {
        success: false,
        error: error.message,
        provider: "aws-ses",
        timestamp: new Date(),
      };
    }
  }

  private async prepareEmailContent(options: EmailOptions) {
    let htmlBody = options.htmlBody;
    let textBody = options.textBody;

    // Process template if provided
    if (options.template) {
      const templateResult = await this.processTemplate(
        options.template,
        options.templateData || {}
      );
      htmlBody = templateResult.html;
      textBody = templateResult.text || this.stripHtml(templateResult.html);
    }

    // Ensure we have content
    if (!htmlBody && !textBody) {
      throw new Error("Email must have either HTML or text content");
    }

    return {
      to: Array.isArray(options.to) ? options.to : [options.to],
      subject: options.subject,
      htmlBody,
      textBody,
      replyTo:
        options.replyTo ||
        this.configService.get<string>("AWS_SES_REPLY_TO_EMAIL"),
    };
  }

  private async processTemplate(
    templateName: string,
    data: any
  ): Promise<{ html: string; text?: string }> {
    try {
      const templatePath = path.join(
        process.cwd(),
        "src",
        "templates",
        `${templateName}.hbs`
      );
      const templateContent = fs.readFileSync(templatePath, "utf-8");

      const template = Handlebars.compile(templateContent);
      const html = template(data);

      // Try to get text version
      let text;
      try {
        const textTemplatePath = path.join(
          process.cwd(),
          "src",
          "templates",
          `${templateName}.txt`
        );
        const textTemplateContent = fs.readFileSync(textTemplatePath, "utf-8");
        const textTemplate = Handlebars.compile(textTemplateContent);
        text = textTemplate(data);
      } catch (e) {
        // Text template not found, will use HTML-to-text conversion
      }

      return { html, text };
    } catch (error) {
      throw new Error(`Template processing failed: ${error.message}`);
    }
  }

  private validateRecipients(to: string | string[]) {
    const recipients = Array.isArray(to) ? to : [to];
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;

    for (const email of recipients) {
      if (!emailRegex.test(email)) {
        throw new Error(`Invalid email address: ${email}`);
      }
    }

    // In sandbox mode, check if email is verified
    if (this.configService.get<boolean>("AWS_SES_SANDBOX_MODE")) {
      const verifiedEmail = this.configService.get<string>(
        "AWS_SES_VERIFIED_EMAIL"
      );
      for (const email of recipients) {
        if (email !== verifiedEmail) {
          this.logger.warn(
            `Email ${email} may not be verified in SES sandbox mode`
          );
        }
      }
    }
  }

  private async sendViaSES(emailContent: any): Promise<{ messageId: string }> {
    const fromEmail = this.configService.get<string>("AWS_SES_FROM_EMAIL");

    const params: SendEmailCommandInput = {
      Source: fromEmail,
      Destination: {
        ToAddresses: emailContent.to,
      },
      Message: {
        Subject: {
          Data: emailContent.subject,
          Charset: "UTF-8",
        },
        Body: {},
      },
    };

    // Add HTML body if available
    if (emailContent.htmlBody) {
      params.Message.Body.Html = {
        Data: emailContent.htmlBody,
        Charset: "UTF-8",
      };
    }

    // Add text body if available
    if (emailContent.textBody) {
      params.Message.Body.Text = {
        Data: emailContent.textBody,
        Charset: "UTF-8",
      };
    }

    // Add reply-to if specified
    if (emailContent.replyTo) {
      params.ReplyToAddresses = [emailContent.replyTo];
    }

    const command = new SendEmailCommand(params);
    const response = await this.sesClient.send(command);

    return {
      messageId: response.MessageId,
    };
  }

  private checkRateLimit() {
    const now = new Date();

    // Reset daily counter if new day
    if (now.getDate() !== this.rateLimit.lastReset.getDate()) {
      this.rateLimit.sentToday = 0;
      this.rateLimit.lastReset = now;
    }

    // Check daily limit
    if (this.rateLimit.sentToday >= this.rateLimit.perDay) {
      throw new Error(
        `Daily email limit reached (${this.rateLimit.perDay}). Try again tomorrow.`
      );
    }
  }

  private updateRateLimit() {
    this.rateLimit.sentToday++;
  }

  private shouldUseFallback(error: any): boolean {
    // Use fallback for certain types of errors
    const fallbackErrors = [
      "ServiceUnavailable",
      "Throttling",
      "InternalFailure",
      "ECONNREFUSED",
      "ETIMEDOUT",
    ];

    return fallbackErrors.some(
      (errorType) =>
        error.message?.includes(errorType) || error.code?.includes(errorType)
    );
  }

  private async sendViaFallback(options: EmailOptions): Promise<EmailResult> {
    // Implementation for SMTP fallback
    this.logger.log(
      "Fallback email delivery not implemented - queuing for retry"
    );

    // In a real implementation, you might:
    // 1. Use nodemailer with SMTP
    // 2. Queue the email for later retry
    // 3. Use alternative email service

    return {
      success: false,
      error: "Fallback not implemented",
      provider: "fallback",
      timestamp: new Date(),
    };
  }

  private stripHtml(html: string): string {
    return html
      .replace(/<[^>]*>/g, "")
      .replace(/\s+/g, " ")
      .trim();
  }

  // Health check method
  async checkHealth(): Promise<boolean> {
    try {
      // Simple test - check if we can create SES client
      const testClient = new SESClient({
        region: this.configService.get<string>("AWS_REGION"),
        credentials: {
          accessKeyId: this.configService.get<string>("AWS_ACCESS_KEY_ID"),
          secretAccessKey: this.configService.get<string>(
            "AWS_SECRET_ACCESS_KEY"
          ),
        },
      });

      return true;
    } catch (error) {
      this.logger.error("AWS SES health check failed:", error.message);
      return false;
    }
  }
}
```

### Step 3: Email Templates

Create email templates for different notification types.

**Create `src/templates/order-confirmation.hbs`:**

```handlebars
<html>
  <head>
    <meta charset="utf-8" />
    <title>Order Confirmation</title>
    <style>
      body { font-family: Arial, sans-serif; color: #333; } .container {
      max-width: 600px; margin: 0 auto; padding: 20px; } .header {
      background-color: #f8f9fa; padding: 20px; text-align: center; } .content {
      padding: 20px 0; } .order-item { border-bottom: 1px solid #eee; padding:
      10px 0; } .total { font-weight: bold; font-size: 18px; } .footer {
      background-color: #f8f9fa; padding: 20px; text-align: center; font-size:
      12px; color: #666; }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h1>Order Confirmation</h1>
        <p>Thank you for your order!</p>
      </div>

      <div class="content">
        <h2>Hello {{customerName}}!</h2>

        <p>We're excited to let you know that we've received your order and it's
          being processed.</p>

        <h3>Order Details:</h3>
        <p><strong>Order Number:</strong> {{orderNumber}}</p>
        <p><strong>Order Date:</strong> {{orderDate}}</p>

        <h3>Items Ordered:</h3>
        {{#each items}}
          <div class="order-item">
            <strong>{{name}}</strong><br />
            Quantity:
            {{quantity}}<br />
            Price: ${{price}}<br />
            Subtotal: ${{subtotal}}
          </div>
        {{/each}}

        <div class="total">
          <p>Total Amount: ${{totalAmount}}</p>
        </div>

        <h3>Shipping Address:</h3>
        <p>{{shippingAddress}}</p>

        <p>You will receive another email with tracking information once your
          order ships.</p>
      </div>

      <div class="footer">
        <p>Thank you for shopping with us!</p>
        <p>If you have any questions, please contact our support team.</p>
      </div>
    </div>
  </body>
</html>
```

**Create `src/templates/order-confirmation.txt`:**

```text
Order Confirmation

Hello {{customerName}}!

Thank you for your order! We're excited to let you know that we've received your order and it's being processed.

Order Details:
Order Number: {{orderNumber}}
Order Date: {{orderDate}}

Items Ordered:
{{#each items}}
- {{name}}
  Quantity: {{quantity}}
  Price: ${{price}}
  Subtotal: ${{subtotal}}

{{/each}}

Total Amount: ${{totalAmount}}

Shipping Address:
{{shippingAddress}}

You will receive another email with tracking information once your order ships.

Thank you for shopping with us!
If you have any questions, please contact our support team.
```

**Create `src/templates/welcome.hbs`:**

```handlebars
<html>
  <head>
    <meta charset="utf-8" />
    <title>Welcome to Our Service</title>
    <style>
      body { font-family: Arial, sans-serif; color: #333; } .container {
      max-width: 600px; margin: 0 auto; padding: 20px; } .header {
      background-color: #007bff; color: white; padding: 20px; text-align:
      center; } .content { padding: 20px 0; } .button { background-color:
      #007bff; color: white; padding: 10px 20px; text-decoration: none;
      border-radius: 5px; display: inline-block; } .footer { background-color:
      #f8f9fa; padding: 20px; text-align: center; font-size: 12px; color: #666;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h1>Welcome {{firstName}}!</h1>
      </div>

      <div class="content">
        <h2>Thank you for joining us!</h2>

        <p>Hi {{firstName}} {{lastName}},</p>

        <p>Welcome to our service! We're thrilled to have you as part of our
          community.</p>

        <p>Your account has been created with the email address:
          <strong>{{email}}</strong></p>

        <p>Here's what you can do next:</p>
        <ul>
          <li>Browse our product catalog</li>
          <li>Create your first order</li>
          <li>Set up your preferences</li>
          <li>Explore our features</li>
        </ul>

        <p>
          <a href="{{loginUrl}}" class="button">Get Started</a>
        </p>

        <p>If you have any questions, our support team is here to help!</p>
      </div>

      <div class="footer">
        <p>Welcome aboard!</p>
        <p>This email was sent to
          {{email}}. If you didn't create an account, please ignore this email.</p>
      </div>
    </div>
  </body>
</html>
```

### Step 4: Enhanced Notification Service

Update the notification service to use the new email service.

**Update `src/services/notification.service.ts`:**

```typescript
import { Injectable, Logger } from "@nestjs/common";
import { InjectModel } from "@nestjs/mongoose";
import { Model } from "mongoose";
import { EmailService, EmailOptions } from "./email.service";
import {
  Notification,
  NotificationDocument,
} from "../schemas/notification.schema";
import { CreateNotificationDto } from "../dto/create-notification.dto";

export interface NotificationContext {
  orderId?: string;
  userId?: string;
  productId?: string;
  metadata?: any;
}

@Injectable()
export class NotificationService {
  private readonly logger = new Logger(NotificationService.name);

  constructor(
    @InjectModel(Notification.name)
    private notificationModel: Model<NotificationDocument>,
    private emailService: EmailService
  ) {}

  async sendNotification(
    dto: CreateNotificationDto,
    context?: NotificationContext
  ) {
    try {
      // Create notification record
      const notification = new this.notificationModel({
        ...dto,
        status: "pending",
        createdAt: new Date(),
        metadata: context?.metadata,
      });

      await notification.save();
      this.logger.log(`Notification created: ${notification._id}`);

      // Process based on notification type
      let result;
      switch (dto.notificationType) {
        case "email":
          result = await this.sendEmailNotification(notification, context);
          break;
        case "sms":
          result = await this.sendSMSNotification(notification, context);
          break;
        case "push":
          result = await this.sendPushNotification(notification, context);
          break;
        default:
          throw new Error(
            `Unsupported notification type: ${dto.notificationType}`
          );
      }

      // Update notification status
      notification.status = result.success ? "sent" : "failed";
      notification.sentAt = result.success ? new Date() : null;
      notification.errorMessage = result.error;
      notification.externalId = result.messageId;

      await notification.save();

      return {
        success: result.success,
        notificationId: notification._id,
        message: result.success
          ? "Notification sent successfully"
          : "Notification failed",
        error: result.error,
      };
    } catch (error) {
      this.logger.error(
        `Notification processing failed: ${error.message}`,
        error.stack
      );
      throw error;
    }
  }

  private async sendEmailNotification(
    notification: NotificationDocument,
    context?: NotificationContext
  ) {
    try {
      // Get user email (you might need to call user service here)
      const userEmail = await this.getUserEmail(notification.userId);

      if (!userEmail) {
        throw new Error("User email not found");
      }

      let emailOptions: EmailOptions;

      // Determine email template based on title or context
      if (notification.title.toLowerCase().includes("order confirmation")) {
        emailOptions = await this.prepareOrderConfirmationEmail(
          userEmail,
          notification,
          context
        );
      } else if (notification.title.toLowerCase().includes("welcome")) {
        emailOptions = await this.prepareWelcomeEmail(
          userEmail,
          notification,
          context
        );
      } else {
        // Generic email
        emailOptions = {
          to: userEmail,
          subject: notification.title,
          textBody: notification.description,
          htmlBody: `
            <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
              <h2>${notification.title}</h2>
              <p>${notification.description}</p>
            </div>
          `,
        };
      }

      const result = await this.emailService.sendEmail(emailOptions);

      this.logger.log(
        `Email notification processed: ${result.success ? "SUCCESS" : "FAILED"}`
      );

      return result;
    } catch (error) {
      this.logger.error(
        `Email notification failed: ${error.message}`,
        error.stack
      );
      return {
        success: false,
        error: error.message,
        provider: "email",
        timestamp: new Date(),
      };
    }
  }

  private async prepareOrderConfirmationEmail(
    userEmail: string,
    notification: NotificationDocument,
    context?: NotificationContext
  ): Promise<EmailOptions> {
    // In a real application, you'd fetch this data from the order service
    const templateData = {
      customerName: "John Doe", // From user service
      orderNumber: context?.orderId || "ORD-12345",
      orderDate: new Date().toLocaleDateString(),
      items: [
        {
          name: "Sample Product",
          quantity: 1,
          price: "99.99",
          subtotal: "99.99",
        },
      ],
      totalAmount: "99.99",
      shippingAddress: "123 Main St, City, State 12345",
    };

    return {
      to: userEmail,
      subject: "Order Confirmation - Thank you for your purchase!",
      template: "order-confirmation",
      templateData,
    };
  }

  private async prepareWelcomeEmail(
    userEmail: string,
    notification: NotificationDocument,
    context?: NotificationContext
  ): Promise<EmailOptions> {
    const templateData = {
      firstName: "John", // From user service
      lastName: "Doe", // From user service
      email: userEmail,
      loginUrl: "http://localhost:3000/login",
    };

    return {
      to: userEmail,
      subject: "Welcome to Our Service!",
      template: "welcome",
      templateData,
    };
  }

  private async sendSMSNotification(
    notification: NotificationDocument,
    context?: NotificationContext
  ) {
    // Placeholder for SMS implementation
    this.logger.warn("SMS notifications not implemented");
    return {
      success: false,
      error: "SMS provider not configured",
      provider: "sms",
      timestamp: new Date(),
    };
  }

  private async sendPushNotification(
    notification: NotificationDocument,
    context?: NotificationContext
  ) {
    // Placeholder for push notification implementation
    this.logger.warn("Push notifications not implemented");
    return {
      success: false,
      error: "Push provider not configured",
      provider: "push",
      timestamp: new Date(),
    };
  }

  private async getUserEmail(userId: string): Promise<string | null> {
    // In a real implementation, you'd call the user service
    // For now, return a test email
    return "test@example.com";
  }

  async getNotifications(userId: string, page: number = 1, limit: number = 10) {
    const skip = (page - 1) * limit;

    const notifications = await this.notificationModel
      .find({ userId })
      .sort({ createdAt: -1 })
      .skip(skip)
      .limit(limit);

    const total = await this.notificationModel.countDocuments({ userId });

    return {
      notifications,
      pagination: {
        page,
        limit,
        total,
        pages: Math.ceil(total / limit),
      },
    };
  }

  async markAsRead(notificationId: string) {
    return await this.notificationModel.findByIdAndUpdate(
      notificationId,
      {
        isRead: true,
        readAt: new Date(),
      },
      { new: true }
    );
  }

  async checkEmailHealth(): Promise<boolean> {
    return await this.emailService.checkHealth();
  }
}
```

### Step 5: Testing External API Integration

Create comprehensive tests for the email service.

**Create `src/utils/email-test.ts`:**

```typescript
import { EmailService } from "../services/email.service";
import { ConfigService } from "@nestjs/config";

export class EmailTestSuite {
  constructor(private emailService: EmailService) {}

  async runTests() {
    console.log("ğŸ§ª Starting Email Service Tests...\n");

    const tests = [
      this.testBasicEmail.bind(this),
      this.testTemplateEmail.bind(this),
      this.testErrorHandling.bind(this),
      this.testRateLimit.bind(this),
      this.testHealthCheck.bind(this),
    ];

    for (const test of tests) {
      try {
        await test();
      } catch (error) {
        console.error(`âŒ Test failed: ${error.message}`);
      }
    }

    console.log("\nâœ… Email Service Tests Completed");
  }

  private async testBasicEmail() {
    console.log("1. Testing Basic Email Sending...");

    const result = await this.emailService.sendEmail({
      to: "test@example.com",
      subject: "Test Email",
      textBody: "This is a test email from the notification service.",
      htmlBody:
        "<h1>Test Email</h1><p>This is a test email from the notification service.</p>",
    });

    if (result.success) {
      console.log(
        `   âœ… Basic email sent successfully (ID: ${result.messageId})`
      );
    } else {
      console.log(`   âŒ Basic email failed: ${result.error}`);
    }
  }

  private async testTemplateEmail() {
    console.log("2. Testing Template Email...");

    try {
      const result = await this.emailService.sendEmail({
        to: "test@example.com",
        subject: "Welcome to Our Service",
        template: "welcome",
        templateData: {
          firstName: "Test",
          lastName: "User",
          email: "test@example.com",
          loginUrl: "http://localhost:3000/login",
        },
      });

      if (result.success) {
        console.log(
          `   âœ… Template email sent successfully (ID: ${result.messageId})`
        );
      } else {
        console.log(`   âŒ Template email failed: ${result.error}`);
      }
    } catch (error) {
      console.log(`   âš ï¸  Template email test skipped: ${error.message}`);
    }
  }

  private async testErrorHandling() {
    console.log("3. Testing Error Handling...");

    const result = await this.emailService.sendEmail({
      to: "invalid-email",
      subject: "Test Error Handling",
      textBody: "This should fail validation",
    });

    if (!result.success) {
      console.log(`   âœ… Error handling working correctly: ${result.error}`);
    } else {
      console.log(
        `   âŒ Error handling test failed - email should not have succeeded`
      );
    }
  }

  private async testRateLimit() {
    console.log("4. Testing Rate Limiting...");

    // This test might not be practical in a real environment
    console.log("   âš ï¸  Rate limit testing skipped in development");
  }

  private async testHealthCheck() {
    console.log("5. Testing Health Check...");

    const isHealthy = await this.emailService.checkHealth();

    if (isHealthy) {
      console.log("   âœ… Email service health check passed");
    } else {
      console.log("   âŒ Email service health check failed");
    }
  }
}
```

### Step 6: Enhanced Controller with Error Handling

Update the notification controller to handle external API errors gracefully.

**Update `src/controllers/notification.controller.ts`:**

```typescript
import {
  Controller,
  Post,
  Body,
  Get,
  Param,
  Put,
  Query,
  HttpStatus,
  HttpException,
} from "@nestjs/common";
import { ApiTags, ApiOperation, ApiResponse, ApiQuery } from "@nestjs/swagger";
import { NotificationService } from "../services/notification.service";
import { CreateNotificationDto } from "../dto/create-notification.dto";

@ApiTags("Notifications")
@Controller("notifications")
export class NotificationController {
  constructor(private readonly notificationService: NotificationService) {}

  @Post()
  @ApiOperation({ summary: "Send a notification" })
  @ApiResponse({ status: 201, description: "Notification sent successfully" })
  @ApiResponse({ status: 400, description: "Invalid notification data" })
  @ApiResponse({ status: 500, description: "External service error" })
  async sendNotification(@Body() createNotificationDto: CreateNotificationDto) {
    try {
      const result = await this.notificationService.sendNotification(
        createNotificationDto
      );

      // Return different status codes based on result
      if (result.success) {
        return {
          success: true,
          message: "Notification sent successfully",
          data: {
            notificationId: result.notificationId,
            status: "sent",
          },
        };
      } else {
        // Notification was created but delivery failed
        return {
          success: false,
          message: "Notification created but delivery failed",
          data: {
            notificationId: result.notificationId,
            status: "failed",
            error: result.error,
          },
          statusCode: HttpStatus.PARTIAL_CONTENT,
        };
      }
    } catch (error) {
      // Determine if it's a client error or server error
      if (
        error.message.includes("Invalid email") ||
        error.message.includes("validation") ||
        error.message.includes("required")
      ) {
        throw new HttpException(
          {
            success: false,
            message: "Invalid notification data",
            error: error.message,
          },
          HttpStatus.BAD_REQUEST
        );
      }

      // External service errors
      if (
        error.message.includes("AWS") ||
        error.message.includes("SES") ||
        error.message.includes("ServiceUnavailable")
      ) {
        throw new HttpException(
          {
            success: false,
            message: "External service temporarily unavailable",
            error: "Please try again later",
          },
          HttpStatus.SERVICE_UNAVAILABLE
        );
      }

      // Rate limiting errors
      if (
        error.message.includes("rate limit") ||
        error.message.includes("quota")
      ) {
        throw new HttpException(
          {
            success: false,
            message: "Rate limit exceeded",
            error: error.message,
          },
          HttpStatus.TOO_MANY_REQUESTS
        );
      }

      // Generic server error
      throw new HttpException(
        {
          success: false,
          message: "Internal server error",
          error: "An unexpected error occurred",
        },
        HttpStatus.INTERNAL_SERVER_ERROR
      );
    }
  }

  @Post("test-email")
  @ApiOperation({ summary: "Test email sending (development only)" })
  async testEmail(
    @Body() body: { to: string; type: "basic" | "welcome" | "order" }
  ) {
    try {
      let dto: CreateNotificationDto;

      switch (body.type) {
        case "welcome":
          dto = {
            userId: "test-user-id",
            title: "Welcome to Our Service",
            description: "Thank you for joining us!",
            notificationType: "email",
          };
          break;
        case "order":
          dto = {
            userId: "test-user-id",
            title: "Order Confirmation",
            description: "Your order has been confirmed.",
            notificationType: "email",
          };
          break;
        default:
          dto = {
            userId: "test-user-id",
            title: "Test Notification",
            description: "This is a test notification from the API.",
            notificationType: "email",
          };
      }

      const result = await this.notificationService.sendNotification(dto, {
        orderId: "test-order-123",
        metadata: { testEmail: body.to },
      });

      return {
        success: true,
        message: "Test email processed",
        data: result,
      };
    } catch (error) {
      throw new HttpException(
        {
          success: false,
          message: "Test email failed",
          error: error.message,
        },
        HttpStatus.INTERNAL_SERVER_ERROR
      );
    }
  }

  @Get("health")
  @ApiOperation({ summary: "Check notification service health" })
  async checkHealth() {
    try {
      const emailHealth = await this.notificationService.checkEmailHealth();

      return {
        success: true,
        message: "Health check completed",
        data: {
          timestamp: new Date().toISOString(),
          services: {
            email: emailHealth ? "healthy" : "unhealthy",
            database: "healthy", // Assume healthy if we can respond
          },
        },
      };
    } catch (error) {
      throw new HttpException(
        {
          success: false,
          message: "Health check failed",
          error: error.message,
        },
        HttpStatus.SERVICE_UNAVAILABLE
      );
    }
  }

  @Get(":userId")
  @ApiOperation({ summary: "Get user notifications" })
  @ApiQuery({ name: "page", required: false, description: "Page number" })
  @ApiQuery({ name: "limit", required: false, description: "Items per page" })
  async getNotifications(
    @Param("userId") userId: string,
    @Query("page") page: string = "1",
    @Query("limit") limit: string = "10"
  ) {
    try {
      const result = await this.notificationService.getNotifications(
        userId,
        parseInt(page),
        parseInt(limit)
      );

      return {
        success: true,
        message: "Notifications retrieved successfully",
        data: result,
      };
    } catch (error) {
      throw new HttpException(
        {
          success: false,
          message: "Failed to retrieve notifications",
          error: error.message,
        },
        HttpStatus.INTERNAL_SERVER_ERROR
      );
    }
  }
}
```

### Step 7: Environment Setup and Testing

**Update notification service module to include the email service:**

```typescript
// src/app.module.ts
import { Module } from "@nestjs/common";
import { ConfigModule } from "@nestjs/config";
import { MongooseModule } from "@nestjs/mongoose";
import { NotificationController } from "./controllers/notification.controller";
import { NotificationService } from "./services/notification.service";
import { EmailService } from "./services/email.service";
import {
  Notification,
  NotificationSchema,
} from "./schemas/notification.schema";

@Module({
  imports: [
    ConfigModule.forRoot({
      isGlobal: true,
    }),
    MongooseModule.forRoot(process.env.MONGODB_URI),
    MongooseModule.forFeature([
      { name: Notification.name, schema: NotificationSchema },
    ]),
  ],
  controllers: [NotificationController],
  providers: [NotificationService, EmailService],
})
export class AppModule {}
```

**Testing script `test-external-api.sh`:**

```bash
#!/bin/bash

echo "ğŸ§ª Testing External API Integration..."

BASE_URL="http://localhost:3004"

echo "1. Testing health endpoint..."
curl -s "$BASE_URL/health" | jq .

echo -e "\n2. Testing basic email notification..."
curl -s -X POST "$BASE_URL/notifications" \
  -H "Content-Type: application/json" \
  -d '{
    "userId": "test-user-123",
    "title": "Test Notification",
    "description": "Testing external API integration",
    "notificationType": "email"
  }' | jq .

echo -e "\n3. Testing welcome email..."
curl -s -X POST "$BASE_URL/notifications/test-email" \
  -H "Content-Type: application/json" \
  -d '{
    "to": "test@example.com",
    "type": "welcome"
  }' | jq .

echo -e "\n4. Testing order confirmation email..."
curl -s -X POST "$BASE_URL/notifications/test-email" \
  -H "Content-Type: application/json" \
  -d '{
    "to": "test@example.com",
    "type": "order"
  }' | jq .

echo -e "\n5. Testing error handling with invalid email..."
curl -s -X POST "$BASE_URL/notifications" \
  -H "Content-Type: application/json" \
  -d '{
    "userId": "test-user-123",
    "title": "Test Error",
    "description": "Testing error handling",
    "notificationType": "email"
  }' | jq .

echo -e "\nâœ… External API testing completed!"
```

This implementation demonstrates comprehensive external API integration with proper error handling, fallback mechanisms, rate limiting, and testing strategies. It shows how to work with AWS SES while maintaining service reliability and user experience.

---

## References and Resources

### Amazon SES Documentation

- [AWS SES Developer Guide](https://docs.aws.amazon.com/ses/) - Complete AWS SES documentation
- [AWS SDK for JavaScript](https://docs.aws.amazon.com/AWSJavaScriptSDK/v3/latest/clients/client-ses/) - SES client for Node.js
- [AWS SES Sandbox Mode](https://docs.aws.amazon.com/ses/latest/dg/request-production-access.html) - Understanding sandbox limitations

### External API Best Practices

- [REST API Error Handling](https://blog.restcase.com/rest-api-error-codes-101/) - HTTP status codes and error patterns
- [Circuit Breaker Pattern](https://martinfowler.com/bliki/CircuitBreaker.html) - Fault tolerance for external APIs
- [Retry Strategies](https://docs.microsoft.com/en-us/azure/architecture/patterns/retry) - Implementing retry logic

### Email Templates and Design

- [Handlebars.js](https://handlebarsjs.com/) - Template engine documentation
- [Email Template Best Practices](https://mailchimp.com/resources/email-template-guide/) - Email design guidelines
- [MJML Framework](https://mjml.io/) - Responsive email framework

### Node.js HTTP Clients

- [AWS SDK v3](https://docs.aws.amazon.com/AWSJavaScriptSDK/v3/latest/) - Modern AWS SDK for JavaScript
- [Axios](https://axios-http.com/) - Promise-based HTTP client
- [Node.js HTTPS Module](https://nodejs.org/api/https.html) - Native HTTPS client
