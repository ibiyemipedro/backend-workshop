# Communication Across Microservices

## Overview

This exercise demonstrates practical communication between our existing microservices. We'll set up and run four different services on separate ports, then implement service-to-service communication to create a working e-commerce system with user management, products, orders, and notifications.

## Learning Objectives

- Set up multiple microservices to run simultaneously on different ports
- Implement HTTP-based service-to-service communication
- Handle authentication and authorization across services
- Understand service dependencies and error handling
- Practice testing microservice interactions

## Our Microservice Ecosystem

### Service Overview

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              WORKSHOP MICROSERVICES SETUP              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚  â”‚User Service â”‚ â”‚Product Svc  â”‚ â”‚ Order Service       â”‚â”‚
â”‚  â”‚             â”‚ â”‚             â”‚ â”‚                     â”‚â”‚
â”‚  â”‚ Express.js  â”‚ â”‚ NestJS      â”‚ â”‚ Express.js          â”‚â”‚
â”‚  â”‚ MongoDB     â”‚ â”‚ PostgreSQL  â”‚ â”‚ PostgreSQL          â”‚â”‚
â”‚  â”‚ Port: 3001  â”‚ â”‚ Port: 3002  â”‚ â”‚ Port: 3003          â”‚â”‚
â”‚  â”‚             â”‚ â”‚             â”‚ â”‚                     â”‚â”‚
â”‚  â”‚ â€¢ Auth      â”‚ â”‚ â€¢ Categoriesâ”‚ â”‚ â€¢ Orders            â”‚â”‚
â”‚  â”‚ â€¢ Users     â”‚ â”‚ â€¢ Products  â”‚ â”‚ â€¢ Cart              â”‚â”‚
â”‚  â”‚ â€¢ JWT       â”‚ â”‚ â€¢ Stock     â”‚ â”‚ â€¢ Items             â”‚â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â”‚                                           â”‚             â”‚
â”‚                                           â–¼             â”‚
â”‚                               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚                               â”‚ Notification Service    â”‚â”‚
â”‚                               â”‚                         â”‚â”‚
â”‚                               â”‚ NestJS + Bull Queue     â”‚â”‚
â”‚                               â”‚ MongoDB                 â”‚â”‚
â”‚                               â”‚ Port: 3004              â”‚â”‚
â”‚                               â”‚                         â”‚â”‚
â”‚                               â”‚ â€¢ Email                 â”‚â”‚
â”‚                               â”‚ â€¢ SMS                   â”‚â”‚
â”‚                               â”‚ â€¢ Push                  â”‚â”‚
â”‚                               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â”‚                                                         â”‚
â”‚  Communication Patterns:                              â”‚
â”‚  1. User creates account â†’ User Service                â”‚
â”‚  2. User browses products â†’ Product Service            â”‚
â”‚  3. User creates order â†’ Order Service                 â”‚
â”‚  4. Order validates user â†’ User Service                â”‚
â”‚  5. Order checks stock â†’ Product Service              â”‚
â”‚  6. Order created â†’ Notification Service              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Exercise: Setting Up and Testing Service Communication

### Step 1: Environment Configuration

Each service needs to know about the other services. Let's configure environment variables for service discovery.

**User Service (.env):**

```env
# Server Configuration
PORT=3001
NODE_ENV=development

# Database
MONGODB_URI=mongodb://localhost:27017/user_service

# JWT
JWT_SECRET=user_service_jwt_secret_key
JWT_EXPIRES_IN=24h

# Service URLs
PRODUCT_SERVICE_URL=http://localhost:3002
ORDER_SERVICE_URL=http://localhost:3003
NOTIFICATION_SERVICE_URL=http://localhost:3004

# API Keys (for inter-service communication)
INTERNAL_API_KEY=workshop_internal_key_2023
```

**Product Service (.env):**

```env
# Server Configuration
PORT=3002
NODE_ENV=development

# Database
DB_HOST=localhost
DB_PORT=5432
DB_USERNAME=postgres
DB_PASSWORD=password
DB_NAME=product_service

# JWT
JWT_SECRET=product_service_jwt_secret_key
JWT_EXPIRES_IN=24h

# Service URLs
USER_SERVICE_URL=http://localhost:3001
ORDER_SERVICE_URL=http://localhost:3003
NOTIFICATION_SERVICE_URL=http://localhost:3004

# API Keys
INTERNAL_API_KEY=workshop_internal_key_2023
```

**Order Service (.env):**

```env
# Server Configuration
PORT=3003
NODE_ENV=development

# Database
DB_HOST=localhost
DB_PORT=5432
DB_USERNAME=postgres
DB_PASSWORD=password
DB_NAME=order_service

# JWT
JWT_SECRET=order_service_jwt_secret_key
JWT_EXPIRES_IN=24h

# Service URLs
USER_SERVICE_URL=http://localhost:3001
PRODUCT_SERVICE_URL=http://localhost:3002
NOTIFICATION_SERVICE_URL=http://localhost:3004

# API Keys
INTERNAL_API_KEY=workshop_internal_key_2023
```

**Notification Service (.env):**

```env
# Server Configuration
PORT=3004
NODE_ENV=development

# Database
MONGODB_URI=mongodb://localhost:27017/notification_service

# JWT
JWT_SECRET=notification_service_jwt_secret_key
JWT_EXPIRES_IN=24h

# Service URLs
USER_SERVICE_URL=http://localhost:3001
PRODUCT_SERVICE_URL=http://localhost:3002
ORDER_SERVICE_URL=http://localhost:3003

# Redis for Bull Queue
REDIS_HOST=localhost
REDIS_PORT=6379

# API Keys
INTERNAL_API_KEY=workshop_internal_key_2023
```

### Step 2: Service Communication Utilities

Create a shared HTTP client utility that each service can use to communicate with others.

**Create `src/utils/service-client.ts` in each service:**

```typescript
import axios, { AxiosInstance, AxiosRequestConfig } from "axios";

export class ServiceClient {
  private client: AxiosInstance;

  constructor(baseURL: string, timeout: number = 5000) {
    this.client = axios.create({
      baseURL,
      timeout,
      headers: {
        "Content-Type": "application/json",
        "X-Internal-Key":
          process.env.INTERNAL_API_KEY || "workshop_internal_key_2023",
      },
    });

    // Request interceptor for logging
    this.client.interceptors.request.use(
      (config) => {
        console.log(
          `ğŸ”— Service call: ${config.method?.toUpperCase()} ${config.baseURL}${
            config.url
          }`
        );
        return config;
      },
      (error) => {
        console.error("âŒ Request interceptor error:", error);
        return Promise.reject(error);
      }
    );

    // Response interceptor for error handling
    this.client.interceptors.response.use(
      (response) => {
        console.log(
          `âœ… Service response: ${response.status} from ${response.config.url}`
        );
        return response;
      },
      (error) => {
        console.error(
          `âŒ Service error: ${error.response?.status} from ${error.config?.url}`
        );

        if (error.code === "ECONNREFUSED") {
          throw new Error("Service unavailable - connection refused");
        }

        if (error.response?.status === 404) {
          throw new Error("Service endpoint not found");
        }

        if (error.response?.status === 401) {
          throw new Error("Service authentication failed");
        }

        throw error;
      }
    );
  }

  async get<T>(url: string, config?: AxiosRequestConfig): Promise<T> {
    const response = await this.client.get(url, config);
    return response.data;
  }

  async post<T>(
    url: string,
    data: any,
    config?: AxiosRequestConfig
  ): Promise<T> {
    const response = await this.client.post(url, data, config);
    return response.data;
  }

  async put<T>(
    url: string,
    data: any,
    config?: AxiosRequestConfig
  ): Promise<T> {
    const response = await this.client.put(url, data, config);
    return response.data;
  }

  async delete<T>(url: string, config?: AxiosRequestConfig): Promise<T> {
    const response = await this.client.delete(url, config);
    return response.data;
  }

  // Method to add JWT token for authenticated requests
  setAuthToken(token: string) {
    this.client.defaults.headers.common["Authorization"] = `Bearer ${token}`;
  }

  // Method to remove auth token
  removeAuthToken() {
    delete this.client.defaults.headers.common["Authorization"];
  }
}

// Service client instances
export const userServiceClient = new ServiceClient(
  process.env.USER_SERVICE_URL || "http://localhost:3001"
);

export const productServiceClient = new ServiceClient(
  process.env.PRODUCT_SERVICE_URL || "http://localhost:3002"
);

export const orderServiceClient = new ServiceClient(
  process.env.ORDER_SERVICE_URL || "http://localhost:3003"
);

export const notificationServiceClient = new ServiceClient(
  process.env.NOTIFICATION_SERVICE_URL || "http://localhost:3004"
);
```

### Step 3: Inter-Service Authentication Middleware

Create middleware to handle internal service authentication.

**Create `src/middleware/internal-auth.middleware.ts`:**

```typescript
import { Request, Response, NextFunction } from "express";

export interface AuthenticatedRequest extends Request {
  isInternalCall?: boolean;
  user?: any;
}

export const internalAuthMiddleware = (
  req: AuthenticatedRequest,
  res: Response,
  next: NextFunction
) => {
  const internalKey = req.headers["x-internal-key"];
  const expectedKey =
    process.env.INTERNAL_API_KEY || "workshop_internal_key_2023";

  if (internalKey === expectedKey) {
    req.isInternalCall = true;
    console.log("ğŸ”’ Internal service call authenticated");
    return next();
  }

  // If not internal call, continue with normal flow
  next();
};

export const requireInternalAuth = (
  req: AuthenticatedRequest,
  res: Response,
  next: NextFunction
) => {
  const internalKey = req.headers["x-internal-key"];
  const expectedKey =
    process.env.INTERNAL_API_KEY || "workshop_internal_key_2023";

  if (internalKey !== expectedKey) {
    return res.status(401).json({
      success: false,
      error: "Internal authentication required",
    });
  }

  req.isInternalCall = true;
  next();
};
```

### Step 4: Enhanced Order Service with Service Communication

Update the Order Service to communicate with User and Product services.

**Update `src/services/order.service.ts` in Order Service:**

```typescript
import { OrderRepository } from "../repositories/order.repository";
import { OrderItemRepository } from "../repositories/order-item.repository";
import { Order, OrderStatus } from "../entities/order.entity";
import { OrderItem } from "../entities/order-item.entity";
import { CreateOrderDto } from "../dtos/create-order.dto";
import {
  userServiceClient,
  productServiceClient,
  notificationServiceClient,
} from "../utils/service-client";

export class OrderService {
  constructor(
    private orderRepository: OrderRepository,
    private orderItemRepository: OrderItemRepository
  ) {}

  async createOrder(
    orderData: CreateOrderDto,
    userToken?: string
  ): Promise<Order> {
    try {
      // Step 1: Validate user exists (call User Service)
      console.log("ğŸ” Validating user with User Service...");

      if (userToken) {
        userServiceClient.setAuthToken(userToken);
      }

      const userResponse = await userServiceClient.get(`/api/users/profile`);

      if (!userResponse.success) {
        throw new Error("User validation failed");
      }

      const user = userResponse.data.user;
      console.log(`âœ… User validated: ${user.email}`);

      // Step 2: Validate products and check stock (call Product Service)
      console.log("ğŸ” Validating products with Product Service...");

      const productValidations = await Promise.all(
        orderData.items.map(async (item) => {
          const productResponse = await productServiceClient.get(
            `/api/products/${item.productId}`
          );

          if (!productResponse.success) {
            throw new Error(`Product ${item.productId} not found`);
          }

          const product = productResponse.data.product;

          if (product.stock < item.quantity) {
            throw new Error(
              `Insufficient stock for product ${product.name}. Available: ${product.stock}, Requested: ${item.quantity}`
            );
          }

          return {
            product,
            quantity: item.quantity,
            price: product.price,
          };
        })
      );

      console.log(`âœ… All ${productValidations.length} products validated`);

      // Step 3: Create order
      const totalAmount = productValidations.reduce(
        (sum, item) => sum + item.price * item.quantity,
        0
      );

      const order = await this.orderRepository.create({
        userId: user._id || user.id,
        status: OrderStatus.PENDING,
        totalAmount,
      });

      // Step 4: Create order items
      const orderItems = await Promise.all(
        productValidations.map(async (item) => {
          return await this.orderItemRepository.create({
            orderId: order.id,
            productId: item.product.id,
            quantity: item.quantity,
            price: item.price,
            status: "pending",
          });
        })
      );

      // Step 5: Update product stock (call Product Service)
      console.log("ğŸ“¦ Updating product stock...");

      await Promise.all(
        productValidations.map(async (item) => {
          await productServiceClient.put(
            `/api/products/${item.product.id}/stock`,
            {
              quantity: -item.quantity, // Reduce stock
            }
          );
        })
      );

      console.log("âœ… Product stock updated");

      // Step 6: Send notification (call Notification Service)
      console.log("ğŸ“§ Sending order confirmation notification...");

      try {
        await notificationServiceClient.post("/api/notifications", {
          userId: user._id || user.id,
          title: "Order Confirmation",
          description: `Your order #${
            order.id
          } has been created successfully. Total: $${totalAmount.toFixed(2)}`,
          notificationType: "email",
        });

        console.log("âœ… Notification sent successfully");
      } catch (notificationError) {
        console.warn(
          "âš ï¸ Notification failed (non-critical):",
          notificationError.message
        );
        // Don't fail order creation if notification fails
      }

      // Step 7: Update order status
      await this.orderRepository.update(order.id, {
        status: OrderStatus.CONFIRMED,
      });

      // Return complete order with items
      return await this.getOrderById(order.id);
    } catch (error) {
      console.error("âŒ Order creation failed:", error.message);
      throw error;
    }
  }

  async getOrderById(id: string): Promise<Order | null> {
    const order = await this.orderRepository.findById(id);

    if (!order) {
      return null;
    }

    // Get order items
    const items = await this.orderItemRepository.findByOrderId(id);

    // Enrich with product information
    const enrichedItems = await Promise.all(
      items.map(async (item) => {
        try {
          const productResponse = await productServiceClient.get(
            `/api/products/${item.productId}`
          );

          return {
            ...item,
            product: productResponse.success
              ? productResponse.data.product
              : null,
          };
        } catch (error) {
          console.warn(
            `âš ï¸ Could not fetch product ${item.productId}:`,
            error.message
          );
          return {
            ...item,
            product: null,
          };
        }
      })
    );

    return {
      ...order,
      items: enrichedItems,
    };
  }

  async getUserOrders(userId: string): Promise<Order[]> {
    const orders = await this.orderRepository.findByUserId(userId);

    // Enrich each order with items and product information
    const enrichedOrders = await Promise.all(
      orders.map(async (order) => {
        const items = await this.orderItemRepository.findByOrderId(order.id);

        const enrichedItems = await Promise.all(
          items.map(async (item) => {
            try {
              const productResponse = await productServiceClient.get(
                `/api/products/${item.productId}`
              );

              return {
                ...item,
                product: productResponse.success
                  ? productResponse.data.product
                  : null,
              };
            } catch (error) {
              return {
                ...item,
                product: null,
              };
            }
          })
        );

        return {
          ...order,
          items: enrichedItems,
        };
      })
    );

    return enrichedOrders;
  }
}
```

### Step 5: Enhanced User Service Endpoints

Add internal endpoints for service-to-service communication.

**Update User Service routes (`src/routes/user.routes.ts`):**

```typescript
import express from "express";
import { UserController } from "../controllers/user.controller";
import { authMiddleware } from "../middleware/auth.middleware";
import {
  requireInternalAuth,
  internalAuthMiddleware,
} from "../middleware/internal-auth.middleware";

const router = express.Router();
const userController = new UserController();

// Public endpoints
router.post("/register", userController.register.bind(userController));
router.post("/login", userController.login.bind(userController));

// Protected user endpoints
router.get(
  "/profile",
  authMiddleware,
  userController.getProfile.bind(userController)
);
router.put(
  "/profile",
  authMiddleware,
  userController.updateProfile.bind(userController)
);

// Internal service endpoints (for service-to-service communication)
router.get(
  "/internal/:userId",
  requireInternalAuth,
  userController.getUserById.bind(userController)
);
router.post(
  "/internal/validate-token",
  requireInternalAuth,
  userController.validateToken.bind(userController)
);

export default router;
```

**Add methods to User Controller:**

```typescript
// Add these methods to UserController class

async getUserById(req: AuthenticatedRequest, res: Response) {
  try {
    const { userId } = req.params;

    const user = await this.userService.findById(userId);

    if (!user) {
      return res.status(404).json({
        success: false,
        error: 'User not found'
      });
    }

    // Return user data without password
    const { password, ...userData } = user;

    res.json({
      success: true,
      message: 'User retrieved successfully',
      data: { user: userData }
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
}

async validateToken(req: AuthenticatedRequest, res: Response) {
  try {
    const { token } = req.body;

    if (!token) {
      return res.status(400).json({
        success: false,
        error: 'Token required'
      });
    }

    const decoded = this.userService.validateJWT(token);
    const user = await this.userService.findById(decoded.userId);

    if (!user) {
      return res.status(404).json({
        success: false,
        error: 'User not found'
      });
    }

    const { password, ...userData } = user;

    res.json({
      success: true,
      message: 'Token validated successfully',
      data: { user: userData }
    });
  } catch (error) {
    res.status(401).json({
      success: false,
      error: 'Invalid token'
    });
  }
}
```

### Step 6: Docker Setup for Databases

Create a `docker-compose.yml` file in the section-2 root directory to run all required databases:

```yaml
version: "3.8"

services:
  # MongoDB for User and Notification services
  mongodb:
    image: mongo:latest
    restart: always
    ports:
      - "27017:27017"
    environment:
      MONGO_INITDB_ROOT_USERNAME: admin
      MONGO_INITDB_ROOT_PASSWORD: password
    volumes:
      - mongodb_data:/data/db

  # PostgreSQL for Product and Order services
  postgres:
    image: postgres:15-alpine
    restart: always
    ports:
      - "5432:5432"
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: password
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./init-databases.sql:/docker-entrypoint-initdb.d/init-databases.sql

  # Redis for Notification service queue
  redis:
    image: redis:alpine
    restart: always
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data

volumes:
  mongodb_data:
  postgres_data:
  redis_data:
```

**Create `init-databases.sql`:**

```sql
-- Create databases for each service
CREATE DATABASE product_service;
CREATE DATABASE order_service;

-- Grant permissions
GRANT ALL PRIVILEGES ON DATABASE product_service TO postgres;
GRANT ALL PRIVILEGES ON DATABASE order_service TO postgres;
```

### Step 7: Starting the Services

**Create a startup script `start-services.sh`:**

```bash
#!/bin/bash

echo "ğŸš€ Starting Workshop Microservices..."

# Function to check if port is in use
check_port() {
    if lsof -i :$1 >/dev/null 2>&1; then
        echo "âš ï¸  Port $1 is already in use"
        return 1
    fi
    return 0
}

# Start databases
echo "ğŸ“Š Starting databases..."
docker-compose up -d mongodb postgres redis

# Wait for databases to be ready
echo "â³ Waiting for databases to start..."
sleep 10

# Check required ports
echo "ğŸ” Checking ports..."
for port in 3001 3002 3003 3004; do
    if ! check_port $port; then
        echo "âŒ Port $port is in use. Please stop the service using this port."
        exit 1
    fi
done

# Start services in background
echo "ğŸŸ¢ Starting User Service on port 3001..."
cd user-service && npm run dev &
USER_PID=$!

echo "ğŸŸ¢ Starting Product Service on port 3002..."
cd ../product-service && npm run start:dev &
PRODUCT_PID=$!

echo "ğŸŸ¢ Starting Order Service on port 3003..."
cd ../order-service && npm run dev &
ORDER_PID=$!

echo "ğŸŸ¢ Starting Notification Service on port 3004..."
cd ../notification-service && npm run start:dev &
NOTIFICATION_PID=$!

# Wait a bit for services to start
sleep 5

echo "ğŸ“‹ Service Status:"
echo "ğŸ”¹ User Service: http://localhost:3001"
echo "ğŸ”¹ Product Service: http://localhost:3002"
echo "ğŸ”¹ Order Service: http://localhost:3003"
echo "ğŸ”¹ Notification Service: http://localhost:3004"
echo ""
echo "ğŸ“š API Documentation:"
echo "ğŸ”¹ User Service: http://localhost:3001/api-docs"
echo "ğŸ”¹ Product Service: http://localhost:3002/api"
echo "ğŸ”¹ Order Service: http://localhost:3003/api/docs"
echo "ğŸ”¹ Notification Service: http://localhost:3004/api-docs"
echo ""
echo "ğŸ’¾ Database UIs:"
echo "ğŸ”¹ MongoDB: Use MongoDB Compass - mongodb://localhost:27017"
echo "ğŸ”¹ PostgreSQL: Use your favorite client - localhost:5432"
echo ""
echo "ğŸ›‘ To stop all services: ./stop-services.sh"

# Save PIDs for cleanup
echo $USER_PID > .user-service.pid
echo $PRODUCT_PID > .product-service.pid
echo $ORDER_PID > .order-service.pid
echo $NOTIFICATION_PID > .notification-service.pid

# Keep script running
wait
```

**Create a stop script `stop-services.sh`:**

```bash
#!/bin/bash

echo "ğŸ›‘ Stopping Workshop Microservices..."

# Kill service processes
if [ -f .user-service.pid ]; then
    kill $(cat .user-service.pid) 2>/dev/null
    rm .user-service.pid
    echo "ğŸ”´ User Service stopped"
fi

if [ -f .product-service.pid ]; then
    kill $(cat .product-service.pid) 2>/dev/null
    rm .product-service.pid
    echo "ğŸ”´ Product Service stopped"
fi

if [ -f .order-service.pid ]; then
    kill $(cat .order-service.pid) 2>/dev/null
    rm .order-service.pid
    echo "ğŸ”´ Order Service stopped"
fi

if [ -f .notification-service.pid ]; then
    kill $(cat .notification-service.pid) 2>/dev/null
    rm .notification-service.pid
    echo "ğŸ”´ Notification Service stopped"
fi

# Stop databases
echo "ğŸ—„ï¸  Stopping databases..."
docker-compose down

echo "âœ… All services stopped"
```

### Step 8: Testing Service Communication

**Health Check Script `test-services.sh`:**

```bash
#!/bin/bash

echo "ğŸ§ª Testing Microservices Communication..."

# Test health endpoints
echo "1. Testing Health Endpoints:"
for port in 3001 3002 3003 3004; do
    echo -n "ğŸ”¹ Port $port: "
    if curl -s http://localhost:$port/health >/dev/null; then
        echo "âœ… Healthy"
    else
        echo "âŒ Not responding"
    fi
done

echo ""
echo "2. Testing Service Integration:"

# Create a test user
echo "ğŸ”¹ Creating test user..."
USER_RESPONSE=$(curl -s -X POST http://localhost:3001/api/users/register \
  -H "Content-Type: application/json" \
  -d '{
    "firstName": "John",
    "lastName": "Doe",
    "email": "john.doe@example.com",
    "password": "password123"
  }')

echo "User creation response: $USER_RESPONSE"

# Login to get token
echo "ğŸ”¹ Logging in..."
LOGIN_RESPONSE=$(curl -s -X POST http://localhost:3001/api/users/login \
  -H "Content-Type: application/json" \
  -d '{
    "email": "john.doe@example.com",
    "password": "password123"
  }')

echo "Login response: $LOGIN_RESPONSE"

# Extract token (you might need jq for this)
TOKEN=$(echo $LOGIN_RESPONSE | jq -r '.data.token' 2>/dev/null || echo "MANUAL_EXTRACT_NEEDED")

if [ "$TOKEN" != "MANUAL_EXTRACT_NEEDED" ] && [ "$TOKEN" != "null" ]; then
    echo "ğŸ”¹ Token obtained: ${TOKEN:0:20}..."

    # Test authenticated endpoint
    echo "ğŸ”¹ Testing authenticated profile endpoint..."
    curl -s -H "Authorization: Bearer $TOKEN" \
         -H "Content-Type: application/json" \
         http://localhost:3001/api/users/profile | jq .

    echo ""
    echo "ğŸ”¹ Testing order creation (this will test service communication)..."
    # Note: You'll need to create products first or use existing ones
    curl -s -X POST http://localhost:3003/api/orders \
         -H "Authorization: Bearer $TOKEN" \
         -H "Content-Type: application/json" \
         -d '{
           "items": [
             {
               "productId": "sample-product-id",
               "quantity": 1
             }
           ]
         }' | jq .
else
    echo "âš ï¸  Could not extract token. Please test manually."
fi

echo ""
echo "ğŸ¯ Manual Testing URLs:"
echo "ğŸ”¹ User Registration: POST http://localhost:3001/api/users/register"
echo "ğŸ”¹ User Login: POST http://localhost:3001/api/users/login"
echo "ğŸ”¹ Get Products: GET http://localhost:3002/api/products"
echo "ğŸ”¹ Create Order: POST http://localhost:3003/api/orders"
echo "ğŸ”¹ Send Notification: POST http://localhost:3004/api/notifications"
```

### Step 9: Testing the Complete Flow

**Create test data script `create-test-data.sh`:**

```bash
#!/bin/bash

echo "ğŸ“Š Creating Test Data..."

# Create category
echo "ğŸ”¹ Creating product category..."
CATEGORY_RESPONSE=$(curl -s -X POST http://localhost:3002/api/categories \
  -H "Content-Type: application/json" \
  -H "X-Internal-Key: workshop_internal_key_2023" \
  -d '{
    "name": "Electronics",
    "description": "Electronic devices and accessories"
  }')

echo "Category created: $CATEGORY_RESPONSE"

# Extract category ID
CATEGORY_ID=$(echo $CATEGORY_RESPONSE | jq -r '.data.category.id' 2>/dev/null || echo "electronics-category")

# Create products
echo "ğŸ”¹ Creating test products..."
PRODUCT1=$(curl -s -X POST http://localhost:3002/api/products \
  -H "Content-Type: application/json" \
  -H "X-Internal-Key: workshop_internal_key_2023" \
  -d '{
    "name": "Laptop Computer",
    "description": "High-performance laptop for development",
    "price": 999.99,
    "categoryId": "'$CATEGORY_ID'",
    "stock": 10,
    "tags": ["laptop", "computer", "development"]
  }')

echo "Product 1 created: $PRODUCT1"

PRODUCT2=$(curl -s -X POST http://localhost:3002/api/products \
  -H "Content-Type: application/json" \
  -H "X-Internal-Key: workshop_internal_key_2023" \
  -d '{
    "name": "Wireless Mouse",
    "description": "Ergonomic wireless mouse",
    "price": 29.99,
    "categoryId": "'$CATEGORY_ID'",
    "stock": 50,
    "tags": ["mouse", "wireless", "accessory"]
  }')

echo "Product 2 created: $PRODUCT2"

echo ""
echo "âœ… Test data created successfully!"
echo "ğŸ”¹ Category ID: $CATEGORY_ID"
echo "ğŸ”¹ Use these products to test order creation"
```

## Communication Flow Visualization

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚               ORDER CREATION COMMUNICATION FLOW        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                         â”‚
â”‚  User Action: Create Order                             â”‚
â”‚       â”‚                                                 â”‚
â”‚       â–¼                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  1. POST /orders    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚  â”‚   Client    â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ â”‚ Order Service   â”‚â”‚
â”‚  â”‚             â”‚                     â”‚ :3003           â”‚â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â”‚                                             â”‚           â”‚
â”‚                          2. Validate User  â”‚           â”‚
â”‚                                             â–¼           â”‚
â”‚                                      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚                                      â”‚ User Service    â”‚â”‚
â”‚                                      â”‚ :3001           â”‚â”‚
â”‚                                      â”‚ GET /profile    â”‚â”‚
â”‚                                      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â”‚                                             â”‚           â”‚
â”‚                                             â–¼           â”‚
â”‚                      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚                      â”‚ 3. Validate Products & Stock   â”‚â”‚
â”‚                      â”‚ GET /products/:id               â”‚â”‚
â”‚                      â”‚                                 â”‚â”‚
â”‚                      â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”‚â”‚
â”‚                      â”‚ â”‚ Product Service â”‚             â”‚â”‚
â”‚                      â”‚ â”‚ :3002           â”‚             â”‚â”‚
â”‚                      â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚â”‚
â”‚                      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â”‚                                             â”‚           â”‚
â”‚                                             â–¼           â”‚
â”‚                      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚                      â”‚ 4. Create Order & Items         â”‚â”‚
â”‚                      â”‚ 5. Update Stock                 â”‚â”‚
â”‚                      â”‚                                 â”‚â”‚
â”‚                      â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”‚â”‚
â”‚                      â”‚ â”‚ Order Service   â”‚             â”‚â”‚
â”‚                      â”‚ â”‚ Database Ops    â”‚             â”‚â”‚
â”‚                      â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚â”‚
â”‚                      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â”‚                                             â”‚           â”‚
â”‚                                             â–¼           â”‚
â”‚                      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚                      â”‚ 6. Send Notification            â”‚â”‚
â”‚                      â”‚ POST /notifications             â”‚â”‚
â”‚                      â”‚                                 â”‚â”‚
â”‚                      â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”‚â”‚
â”‚                      â”‚ â”‚Notification Svc â”‚             â”‚â”‚
â”‚                      â”‚ â”‚ :3004           â”‚             â”‚â”‚
â”‚                      â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚â”‚
â”‚                      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â”‚                                             â”‚           â”‚
â”‚                                             â–¼           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚  â”‚   Client    â”‚ â—€â”€â”€â”€ Order Created â”€â”€â”‚ Order Service   â”‚â”‚
â”‚  â”‚             â”‚                     â”‚ Response        â”‚â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â”‚                                                         â”‚
â”‚  Error Handling:                                       â”‚
â”‚  â€¢ Circuit breaker on service calls                    â”‚
â”‚  â€¢ Graceful degradation                                â”‚
â”‚  â€¢ Rollback on failure                                 â”‚
â”‚  â€¢ Comprehensive logging                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

This exercise demonstrates real-world microservice communication patterns, including authentication, validation, error handling, and asynchronous notifications. The hands-on approach shows both the benefits and challenges of distributed systems.

---

## References and Resources

### HTTP Client Libraries

- [Axios Documentation](https://axios-http.com/docs/intro) - Promise-based HTTP client for Node.js
- [Node.js HTTP Module](https://nodejs.org/api/http.html) - Native HTTP client capabilities
- [Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) - Modern alternative to XMLHttpRequest

### Service Communication Patterns

- [REST API Design](https://restfulapi.net/) - RESTful API design principles
- [Inter-Service Communication](https://microservices.io/patterns/communication-style/messaging.html) - Communication patterns
- [Service Discovery Patterns](https://microservices.io/patterns/service-registry.html) - Service discovery mechanisms

### Error Handling and Resilience

- [Circuit Breaker Pattern](https://martinfowler.com/bliki/CircuitBreaker.html) - Fault tolerance pattern
- [Retry Patterns](https://docs.microsoft.com/en-us/azure/architecture/patterns/retry) - Retry strategies for resilience
- [Timeout Patterns](https://microservices.io/patterns/reliability/timeout.html) - Timeout handling strategies

### Authentication and Security

- [JWT Tokens](https://jwt.io/) - JSON Web Token standard
- [OAuth 2.0](https://oauth.net/2/) - Authorization framework
- [API Security Best Practices](https://owasp.org/www-project-api-security/) - OWASP API security guidelines
