# Microservice Architecture

## Overview

Microservices architecture is a method of developing software systems as a suite of independently deployable, small, modular services. Each service runs a unique process and communicates via well-defined, lightweight mechanisms to serve a business goal.

## Learning Objectives

- Understand microservice architecture principles and patterns
- Learn when to use microservices vs monolithic architecture
- Understand service communication patterns
- Learn about service discovery and API gateways
- Understand deployment and operational considerations

## What are Microservices?

### Monolithic vs Microservices Architecture

```
┌─────────────────────────────────────────────────────────┐
│                 MONOLITHIC ARCHITECTURE                │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  ┌─────────────────────────────────────────────────────┐│
│  │                Single Application                   ││
│  │                                                     ││
│  │ ┌─────────────┐ ┌─────────────┐ ┌─────────────────┐││
│  │ │     UI      │ │  Business   │ │    Database     │││
│  │ │   Layer     │ │   Logic     │ │    Layer        │││
│  │ │             │ │   Layer     │ │                 │││
│  │ └─────────────┘ └─────────────┘ └─────────────────┘││
│  └─────────────────────────────────────────────────────┘│
│                                                         │
│  Characteristics:                                      │
│  • Single deployable unit                             │
│  • Shared database                                    │
│  • All components tightly coupled                     │
│  • Single technology stack                            │
│  • Centralized business logic                         │
└─────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────┐
│               MICROSERVICES ARCHITECTURE               │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────────────┐│
│  │ User Service│ │Product Svc  │ │ Notification Svc    ││
│  │             │ │             │ │                     ││
│  │ ┌─────────┐ │ │ ┌─────────┐ │ │ ┌─────────────────┐││
│  │ │   API   │ │ │ │   API   │ │ │ │      API        │││
│  │ └─────────┘ │ │ └─────────┘ │ │ └─────────────────┘││
│  │ ┌─────────┐ │ │ ┌─────────┐ │ │ ┌─────────────────┐││
│  │ │Business │ │ │ │Business │ │ │ │    Business     │││
│  │ │ Logic   │ │ │ │ Logic   │ │ │ │     Logic       │││
│  │ └─────────┘ │ │ └─────────┘ │ │ └─────────────────┘││
│  │ ┌─────────┐ │ │ ┌─────────┐ │ │ ┌─────────────────┐││
│  │ │MongoDB  │ │ │ │PostgreSQL│ │ │ │    MongoDB      │││
│  │ └─────────┘ │ │ └─────────┘ │ │ └─────────────────┘││
│  └─────────────┘ └─────────────┘ └─────────────────────┘│
│                                                         │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────────────┐│
│  │Order Service│ │API Gateway  │ │ Service Discovery   ││
│  │             │ │             │ │                     ││
│  │ ┌─────────┐ │ │ ┌─────────┐ │ │ ┌─────────────────┐││
│  │ │   API   │ │ │ │ Routing │ │ │ │    Registry     │││
│  │ └─────────┘ │ │ └─────────┘ │ │ └─────────────────┘││
│  │ ┌─────────┐ │ │ ┌─────────┐ │ │ ┌─────────────────┐││
│  │ │Business │ │ │ │Auth &   │ │ │ │ Health Checks   │││
│  │ │ Logic   │ │ │ │Security │ │ │ └─────────────────┘││
│  │ └─────────┘ │ │ └─────────┘ │                     ││
│  │ ┌─────────┐ │ │ ┌─────────┐ │                     ││
│  │ │PostgreSQL│ │ │ │Load Bal │ │                     ││
│  │ └─────────┘ │ │ └─────────┘ │                     ││
│  └─────────────┘ └─────────────┘ └─────────────────────┘│
│                                                         │
│  Characteristics:                                      │
│  • Multiple deployable units                          │
│  • Database per service                               │
│  • Loosely coupled services                           │
│  • Technology diversity                               │
│  • Decentralized business logic                       │
└─────────────────────────────────────────────────────────┘
```

## Core Principles of Microservices

### 1. Single Responsibility Principle

Each microservice should have a single business responsibility and do it well.

### 2. Decentralized Governance

```
┌─────────────────────────────────────────────────────────┐
│                DECENTRALIZED GOVERNANCE                │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  Team Ownership Model:                                 │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────────────┐│
│  │   Team A    │ │   Team B    │ │      Team C         ││
│  │             │ │             │ │                     ││
│  │ Owns User   │ │ Owns Product│ │ Owns Notification   ││
│  │ Service     │ │ Service     │ │ Service             ││
│  │             │ │             │ │                     ││
│  │ • DevOps    │ │ • DevOps    │ │ • DevOps            ││
│  │ • Testing   │ │ • Testing   │ │ • Testing           ││
│  │ • Monitoring│ │ • Monitoring│ │ • Monitoring        ││
│  │ • Deployment│ │ • Deployment│ │ • Deployment        ││
│  └─────────────┘ └─────────────┘ └─────────────────────┘│
│                                                         │
│  Technology Choices:                                   │
│  • Each team can choose their tech stack               │
│  • Different programming languages                     │
│  • Different databases                                 │
│  • Different frameworks                                │
└─────────────────────────────────────────────────────────┘
```

### 3. Failure Isolation

```
┌─────────────────────────────────────────────────────────┐
│                   FAILURE ISOLATION                    │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  Monolithic Failure:                                   │
│  ┌─────────────────────────────────────────────────────┐│
│  │ [User] [Product] [Order] [Notification] [Payment]  ││
│  │                    ❌                               ││
│  │        All services down due to one failure        ││
│  └─────────────────────────────────────────────────────┘│
│                                                         │
│  Microservice Failure:                                │
│  ┌───────────┐ ┌───────────┐ ┌───────────┐ ┌───────────┐│
│  │   User    │ │  Product  │ │   Order   │ │Notification││
│  │ Service ✅ │ │Service ✅ │ │Service ❌ │ │Service ✅  ││
│  └───────────┘ └───────────┘ └───────────┘ └───────────┘│
│       │              │             │             │       │
│       └──────────────┼─────────────┼─────────────┘       │
│                      │             │                     │
│                 Other services continue working          │
│                                                         │
│  Circuit Breaker Pattern:                              │
│  • Detect failures quickly                             │
│  • Prevent cascading failures                          │
│  • Provide fallback mechanisms                         │
│  • Allow services to recover gracefully                │
└─────────────────────────────────────────────────────────┘
```

## Microservice Communication Patterns

### 1. Synchronous Communication

```
┌─────────────────────────────────────────────────────────┐
│                SYNCHRONOUS COMMUNICATION               │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  Request-Response Pattern (HTTP/REST):                 │
│  ┌─────────────┐    HTTP Request    ┌─────────────────┐│
│  │   Client    │ ──────────────────▶ │ User Service    ││
│  │             │                    │                 ││
│  │             │ ◀────────────────── │ Return JSON     ││
│  └─────────────┘    HTTP Response   └─────────────────┘│
│                                                         │
│  Service-to-Service Communication:                     │
│  ┌─────────────┐                   ┌─────────────────┐ │
│  │Order Service│ ──── GET /user ──▶ │ User Service    │ │
│  │             │                    │                 │ │
│  │             │ ◀── User Data ──── │                 │ │
│  └─────────────┘                   └─────────────────┘ │
│        │                                               │
│        ▼ POST /product                                 │
│  ┌─────────────┐                   ┌─────────────────┐ │
│  │             │ ──────────────────▶ │Product Service  │ │
│  │             │                    │                 │ │
│  │             │ ◀────────────────── │                 │ │
│  └─────────────┘                   └─────────────────┘ │
│                                                         │
│  Advantages:                                           │
│  • Simple and intuitive                               │
│  • Immediate feedback                                  │
│  • Easy debugging                                     │
│                                                         │
│  Disadvantages:                                        │
│  • Tight coupling                                     │
│  • Service availability dependencies                  │
│  • Potential for cascading failures                   │
└─────────────────────────────────────────────────────────┘
```

### 2. Asynchronous Communication

```
┌─────────────────────────────────────────────────────────┐
│               ASYNCHRONOUS COMMUNICATION               │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  Event-Driven Architecture:                           │
│  ┌─────────────┐    Event        ┌─────────────────────┐│
│  │Order Service│ ──── Publish ──▶ │   Message Broker   ││
│  │             │                  │   (Kafka/RabbitMQ) ││
│  └─────────────┘                  └─────────────────────┘│
│                                            │             │
│                                            ▼             │
│  ┌─────────────┐                  ┌─────────────────────┐│
│  │Notification │ ◀── Subscribe ── │    Event Queue      ││
│  │   Service   │                  │                     ││
│  └─────────────┘                  └─────────────────────┘│
│                                                         │
│  Message Flow Example:                                 │
│  1. Order Created ────────────────────────┐            │
│  2. Event: "order.created" ───────────────┼──────────┐ │
│  3. Multiple Services Subscribe ──────────┼────────┐ │ │
│                                           │        │ │ │
│  ┌─────────────┐                         │        │ │ │
│  │ Inventory   │ ◀── Update Stock ────────┘        │ │ │
│  │ Service     │                                   │ │ │
│  └─────────────┘                                   │ │ │
│                                                     │ │ │
│  ┌─────────────┐                                   │ │ │
│  │ Email       │ ◀── Send Confirmation ────────────┘ │ │
│  │ Service     │                                     │ │
│  └─────────────┘                                     │ │
│                                                       │ │
│  ┌─────────────┐                                     │ │
│  │ Analytics   │ ◀── Track Event ────────────────────┘ │
│  │ Service     │                                       │
│  └─────────────┘                                       │
│                                                         │
│  Advantages:                                           │
│  • Loose coupling                                     │
│  • Better resilience                                  │
│  • Scalability                                        │
│                                                         │
│  Disadvantages:                                        │
│  • Eventual consistency                               │
│  • Complex debugging                                  │
│  • Message ordering challenges                        │
└─────────────────────────────────────────────────────────┘
```

## Microservice Architecture Patterns

### 1. API Gateway Pattern

```
┌─────────────────────────────────────────────────────────┐
│                   API GATEWAY PATTERN                  │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  Client Layer:                                         │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────────────┐│
│  │   Web App   │ │Mobile App   │ │   IoT Device        ││
│  └─────────────┘ └─────────────┘ └─────────────────────┘│
│         │               │                   │           │
│         └───────────────┼───────────────────┘           │
│                         ▼                               │
│  ┌─────────────────────────────────────────────────────┐│
│  │                 API GATEWAY                         ││
│  │                                                     ││
│  │ ┌─────────────┐ ┌─────────────┐ ┌─────────────────┐││
│  │ │  Routing    │ │ Rate Limit  │ │  Authentication │││
│  │ └─────────────┘ └─────────────┘ └─────────────────┘││
│  │                                                     ││
│  │ ┌─────────────┐ ┌─────────────┐ ┌─────────────────┐││
│  │ │Request/Resp │ │   Logging   │ │     Caching     │││
│  │ │Transformation│ │ Monitoring  │ │                 │││
│  │ └─────────────┘ └─────────────┘ └─────────────────┘││
│  └─────────────────────────────────────────────────────┘│
│         │               │               │               │
│         ▼               ▼               ▼               │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────────────┐│
│  │User Service │ │Product Svc  │ │ Order Service       ││
│  │:3001        │ │:3002        │ │ :3003               ││
│  └─────────────┘ └─────────────┘ └─────────────────────┘│
│                                                         │
│  Gateway Responsibilities:                             │
│  • Route requests to appropriate services              │
│  • Authentication and authorization                    │
│  • Request/response transformation                     │
│  • Rate limiting and throttling                       │
│  • Logging and monitoring                             │
│  • SSL termination                                    │
│  • Load balancing                                     │
└─────────────────────────────────────────────────────────┘
```

### 2. Service Discovery Pattern

```
┌─────────────────────────────────────────────────────────┐
│                SERVICE DISCOVERY PATTERN               │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  Service Registration:                                 │
│  ┌─────────────┐                   ┌─────────────────┐  │
│  │User Service │ ──── Register ───▶ │Service Registry │  │
│  │IP: 10.0.1.5 │                   │                 │  │
│  │Port: 3001   │                   │ User: 10.0.1.5  │  │
│  └─────────────┘                   │ Product: 10.0.1.6│  │
│                                     │ Order: 10.0.1.7 │  │
│  ┌─────────────┐                   │ Notify: 10.0.1.8│  │
│  │Product Svc  │ ──── Register ───▶ │                 │  │
│  │IP: 10.0.1.6 │                   └─────────────────┘  │
│  │Port: 3002   │                                        │
│  └─────────────┘                                        │
│                                                         │
│  Service Discovery:                                    │
│  ┌─────────────┐                   ┌─────────────────┐  │
│  │Order Service│ ── Lookup User ──▶ │Service Registry │  │
│  │             │                   │                 │  │
│  │             │ ◀─ Return IP ───── │                 │  │
│  └─────────────┘                   └─────────────────┘  │
│         │                                               │
│         ▼ Direct Call                                   │
│  ┌─────────────┐                                        │
│  │User Service │                                        │
│  │10.0.1.5:3001│                                        │
│  └─────────────┘                                        │
│                                                         │
│  Health Checking:                                      │
│  ┌─────────────┐                   ┌─────────────────┐  │
│  │Services     │ ──── Health ─────▶ │Service Registry │  │
│  │             │ ◀─── Check ────── │                 │  │
│  │             │                   │ Remove Failed   │  │
│  └─────────────┘                   │ Services        │  │
│                                     └─────────────────┘  │
└─────────────────────────────────────────────────────────┘
```

### 3. Circuit Breaker Pattern

```
┌─────────────────────────────────────────────────────────┐
│                CIRCUIT BREAKER PATTERN                 │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  Three States:                                         │
│                                                         │
│  1. CLOSED (Normal Operation):                         │
│  ┌─────────────┐     Success      ┌─────────────────┐   │
│  │Order Service│ ───────────────▶ │ User Service    │   │
│  │             │ ◀───────────── │ │                 │   │
│  └─────────────┘     Response     └─────────────────┘   │
│                                                         │
│  2. OPEN (Service Down):                               │
│  ┌─────────────┐       ❌         ┌─────────────────┐   │
│  │Order Service│ ─ ─ ─ ─ ─ ─ ─ ─ ▶ │ User Service    │   │
│  │             │                  │ (DOWN)          │   │
│  │ Returns     │                  │                 │   │
│  │ Fallback    │                  └─────────────────┘   │
│  └─────────────┘                                        │
│                                                         │
│  3. HALF-OPEN (Testing Recovery):                      │
│  ┌─────────────┐    Test Call     ┌─────────────────┐   │
│  │Order Service│ ───────────────▶ │ User Service    │   │
│  │             │                  │                 │   │
│  │ Monitor     │ ◀───────────── │ │ (Recovering)    │   │
│  │ Response    │                  │                 │   │
│  └─────────────┘                  └─────────────────┘   │
│                                                         │
│  State Transitions:                                    │
│  ┌─────────────────────────────────────────────────────┐│
│  │                                                     ││
│  │  CLOSED ──── Failure ───────▶ OPEN                 ││
│  │     ▲        Threshold            │                 ││
│  │     │                             │                 ││
│  │     │                             ▼                 ││
│  │  Success                      HALF-OPEN             ││
│  │     │                             │                 ││
│  │     └──────── Success ────────────┘                 ││
│  │                                                     ││
│  └─────────────────────────────────────────────────────┘│
│                                                         │
│  Fallback Strategies:                                  │
│  • Return cached data                                  │
│  • Return default/empty response                       │
│  • Redirect to alternative service                     │
│  • Queue request for later processing                  │
└─────────────────────────────────────────────────────────┘
```

## Benefits of Microservices

### 1. Scalability

```
┌─────────────────────────────────────────────────────────┐
│                    SCALABILITY BENEFITS                │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  Independent Scaling:                                  │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────────────┐│
│  │User Service │ │Product Svc  │ │ Order Service       ││
│  │             │ │             │ │                     ││
│  │ 1 Instance  │ │ 3 Instances │ │ 5 Instances         ││
│  │ (Low Load)  │ │(Medium Load)│ │ (High Load)         ││
│  └─────────────┘ └─────────────┘ └─────────────────────┘│
│                                                         │
│  Technology Optimization:                              │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────────────┐│
│  │User Service │ │Product Svc  │ │ Analytics Service   ││
│  │             │ │             │ │                     ││
│  │ Node.js     │ │ Python      │ │ Go Lang             ││
│  │ (Fast I/O)  │ │ (ML Ready)  │ │ (High Performance)  ││
│  └─────────────┘ └─────────────┘ └─────────────────────┘│
└─────────────────────────────────────────────────────────┘
```

### 2. Development Velocity

```
┌─────────────────────────────────────────────────────────┐
│              DEVELOPMENT VELOCITY BENEFITS             │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  Parallel Development:                                 │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────────────┐│
│  │   Team 1    │ │   Team 2    │ │      Team 3         ││
│  │             │ │             │ │                     ││
│  │ Develops    │ │ Develops    │ │ Develops            ││
│  │ User API    │ │ Product API │ │ Order API           ││
│  │             │ │             │ │                     ││
│  │ Sprint 1    │ │ Sprint 1    │ │ Sprint 1            ││
│  │ No Waiting  │ │ No Waiting  │ │ No Waiting          ││
│  └─────────────┘ └─────────────┘ └─────────────────────┘│
│                                                         │
│  Independent Deployment:                               │
│  ┌─────────────┐                                        │
│  │ User v1.2   │ ──── Deploy ────┐                     │
│  └─────────────┘                  │                     │
│                                   ▼                     │
│  ┌─────────────┐           ┌─────────────────────────┐  │
│  │ Product v1.0│           │     Production          │  │
│  │ (Unchanged) │           │                         │  │
│  └─────────────┘           │ ┌─────────┐ ┌─────────┐ │  │
│                             │ │User v1.2│ │Order v1.1│ │  │
│  ┌─────────────┐           │ └─────────┘ └─────────┘ │  │
│  │ Order v1.1  │           │ ┌─────────┐ ┌─────────┐ │  │
│  │ (Unchanged) │           │ │Prod v1.0│ │Notify v1│ │  │
│  └─────────────┘           │ └─────────┘ └─────────┘ │  │
│                             └─────────────────────────┘  │
└─────────────────────────────────────────────────────────┘
```

## Challenges and Considerations

### 1. Distributed System Complexity

- **Network Latency**: Service-to-service communication overhead
- **Data Consistency**: Managing transactions across services
- **Service Coordination**: Orchestrating business processes
- **Monitoring**: Tracking requests across multiple services

### 2. Operational Overhead

- **Deployment**: Managing multiple deployments
- **Logging**: Distributed logging and correlation
- **Security**: Service-to-service authentication
- **Testing**: Integration and end-to-end testing complexity

### 3. Data Management

```
┌─────────────────────────────────────────────────────────┐
│                 DATA MANAGEMENT CHALLENGES             │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  Database Per Service:                                 │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────────────┐│
│  │User Service │ │Product Svc  │ │ Order Service       ││
│  │             │ │             │ │                     ││
│  │ MongoDB     │ │ PostgreSQL  │ │ PostgreSQL          ││
│  │             │ │             │ │                     ││
│  │ User Data   │ │ Product     │ │ Order Data          ││
│  │ Only        │ │ Data Only   │ │ Only                ││
│  └─────────────┘ └─────────────┘ └─────────────────────┘│
│                                                         │
│  Challenges:                                           │
│  • No ACID transactions across services                │
│  • Data duplication for performance                    │
│  • Eventual consistency                                │
│  • Complex queries spanning services                   │
│                                                         │
│  Solutions:                                            │
│  • Event Sourcing                                     │
│  • SAGA Pattern                                       │
│  • CQRS (Command Query Responsibility Segregation)    │
│  • Distributed caching                                │
└─────────────────────────────────────────────────────────┘
```

## When to Use Microservices

### Decision Matrix

```
┌─────────────────────────────────────────────────────────┐
│              MICROSERVICES DECISION MATRIX             │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  Use Microservices When:                               │
│  ┌─────────────────────────────────────────────────────┐│
│  │ ✅ Large, complex applications                      ││
│  │ ✅ Multiple teams (6+ developers)                   ││
│  │ ✅ Different scalability requirements               ││
│  │ ✅ Technology diversity needed                      ││
│  │ ✅ Independent deployment requirements              ││
│  │ ✅ High availability requirements                   ││
│  │ ✅ Mature DevOps practices                          ││
│  │ ✅ Clear bounded contexts                           ││
│  └─────────────────────────────────────────────────────┘│
│                                                         │
│  Start with Monolith When:                            │
│  ┌─────────────────────────────────────────────────────┐│
│  │ ❌ Small team (1-5 developers)                      ││
│  │ ❌ Simple, well-defined requirements                ││
│  │ ❌ Limited operational expertise                    ││
│  │ ❌ Rapid prototyping needed                         ││
│  │ ❌ Unclear domain boundaries                        ││
│  │ ❌ Limited resources for infrastructure             ││
│  │ ❌ Tight coupling requirements                      ││
│  └─────────────────────────────────────────────────────┘│
│                                                         │
│  Migration Path:                                       │
│  Monolith → Modular Monolith → Microservices           │
│                                                         │
│  1. Start with well-structured monolith                │
│  2. Identify bounded contexts                          │
│  3. Extract services incrementally                     │
│  4. Implement proper monitoring                        │
│  5. Scale operational practices                        │
└─────────────────────────────────────────────────────────┘
```

## Microservices Best Practices

### 1. Service Design

- **Single Responsibility**: One business capability per service
- **Loose Coupling**: Minimize dependencies between services
- **High Cohesion**: Related functionality should be together
- **API-First Design**: Define contracts before implementation

### 2. Data Management

- **Database per Service**: Each service owns its data
- **Event-Driven Architecture**: Use events for service communication
- **Eventual Consistency**: Accept that data will be eventually consistent
- **Data Versioning**: Plan for schema evolution

### 3. Operational Excellence

- **Monitoring**: Comprehensive logging and metrics
- **Automated Deployment**: CI/CD pipelines for each service
- **Health Checks**: Implement proper health endpoints
- **Circuit Breakers**: Handle service failures gracefully

### 4. Security

- **Service-to-Service Authentication**: Secure internal communication
- **API Gateway**: Centralize security policies
- **Least Privilege**: Services should have minimal required permissions
- **Secrets Management**: Centralized secret management

## Implementation Architecture for Our Workshop

```
┌─────────────────────────────────────────────────────────┐
│            WORKSHOP MICROSERVICES ARCHITECTURE         │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  ┌─────────────────────────────────────────────────────┐│
│  │                 Client Layer                        ││
│  │ ┌─────────────┐ ┌─────────────┐ ┌─────────────────┐││
│  │ │   Web App   │ │Mobile App   │ │  Admin Panel    │││
│  │ └─────────────┘ └─────────────┘ └─────────────────┘││
│  └─────────────────────────────────────────────────────┘│
│                           │                             │
│                           ▼                             │
│  ┌─────────────────────────────────────────────────────┐│
│  │                API Gateway                          ││
│  │                (Port: 3000)                        ││
│  └─────────────────────────────────────────────────────┘│
│                           │                             │
│          ┌────────────────┼────────────────┐            │
│          │                │                │            │
│          ▼                ▼                ▼            │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────────────┐│
│  │User Service │ │Product Svc  │ │ Order Service       ││
│  │             │ │             │ │                     ││
│  │ Express.js  │ │ NestJS      │ │ Express.js          ││
│  │ MongoDB     │ │ PostgreSQL  │ │ PostgreSQL          ││
│  │ JWT Auth    │ │ TypeORM     │ │ TypeORM             ││
│  │ Port: 3001  │ │ Port: 3002  │ │ Port: 3003          ││
│  └─────────────┘ └─────────────┘ └─────────────────────┘│
│          │                                              │
│          ▼                                              │
│  ┌─────────────────────────────────────────────────────┐│
│  │            Notification Service                     ││
│  │                                                     ││
│  │ NestJS + Bull Queue + MongoDB                      ││
│  │ Kafka Consumer + AWS SES                           ││
│  │ Port: 3004                                         ││
│  └─────────────────────────────────────────────────────┘│
│                                                         │
│  Communication Patterns:                              │
│  • Synchronous: HTTP/REST API calls                   │
│  • Asynchronous: Kafka events                         │
│  • Authentication: JWT tokens                         │
│  • Service Discovery: Environment variables           │
└─────────────────────────────────────────────────────────┘
```

This architecture provides a practical foundation for understanding microservices concepts while keeping complexity manageable for a workshop environment.

---

## References and Resources

### Microservices Architecture

- [Microservices.io](https://microservices.io/) - Comprehensive microservices patterns and practices
- [Martin Fowler on Microservices](https://martinfowler.com/articles/microservices.html) - Foundational article on microservices
- [Microsoft Microservices Guide](https://docs.microsoft.com/en-us/azure/architecture/microservices/) - Enterprise microservices architecture

### Communication Patterns

- [API Gateway Pattern](https://microservices.io/patterns/apigateway.html) - Gateway pattern documentation
- [Circuit Breaker Pattern](https://martinfowler.com/bliki/CircuitBreaker.html) - Fault tolerance patterns
- [Event-Driven Architecture](https://martinfowler.com/articles/201701-event-driven.html) - Asynchronous communication patterns

### Tools and Technologies

- [Docker Documentation](https://docs.docker.com/) - Containerization for microservices
- [Kubernetes Documentation](https://kubernetes.io/docs/) - Container orchestration
- [Apache Kafka](https://kafka.apache.org/documentation/) - Event streaming platform
- [NGINX as API Gateway](https://www.nginx.com/learn/api-gateway/) - Load balancing and routing

### Best Practices and Patterns

- [12-Factor App Methodology](https://12factor.net/) - Principles for building microservices
- [Domain-Driven Design](https://domainlanguage.com/ddd/) - Service boundary identification
- [Building Microservices (Book)](https://www.oreilly.com/library/view/building-microservices/9781491950340/) - Comprehensive guide by Sam Newman
