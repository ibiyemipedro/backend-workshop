# Sending Files and Other Response Types

## Overview

Express.js provides multiple ways to send different types of responses beyond JSON. In this exercise, we'll explore various response types including files, streams, attachments, and different content types while extending our existing application.

## Learning Objectives

- Send different response types (JSON, HTML, XML, files)
- Handle file uploads and downloads
- Work with streams for large files
- Set appropriate headers and content types
- Implement file serving middleware
- Handle binary data and attachments

## Response Types Overview

### Common Response Types

```
┌─────────────────────────────────────────────────────────┐
│                 EXPRESS RESPONSE TYPES                  │
├─────────────────┬─────────────────┬─────────────────────┤
│     TEXT/JSON   │      FILES      │       STREAMS       │
│                 │                 │                     │
│ • res.json()    │ • res.sendFile()│ • res.pipe()        │
│ • res.send()    │ • res.download()│ • ReadableStream    │
│ • res.render()  │ • res.attachment│ • WritableStream    │
│ • res.status()  │ • File Upload   │ • Transform Stream  │
├─────────────────┼─────────────────┼─────────────────────┤
│    REDIRECTS    │     HEADERS     │      COOKIES        │
│                 │                 │                     │
│ • res.redirect()│ • res.set()     │ • res.cookie()      │
│ • res.location()│ • res.type()    │ • res.clearCookie() │
│ • res.vary()    │ • res.links()   │ • Signed Cookies    │
└─────────────────┴─────────────────┴─────────────────────┘
```

## Exercise: File Management API

Let's extend our application to handle various file operations and response types.

### Step 1: Setup File Handling Dependencies

Install required dependencies:

```bash
npm install multer sharp qrcode pdf-kit archiver mime-types
npm install -D @types/multer @types/mime-types
```

Create directory structure for file operations:

```
file-response-app/
├── src/
│   ├── uploads/           # Temporary upload storage
│   ├── public/           # Static files
│   │   ├── images/
│   │   ├── documents/
│   │   └── downloads/
│   ├── templates/        # HTML templates
│   ├── controllers/
│   │   └── file.controller.ts
│   ├── services/
│   │   └── file.service.ts
│   ├── middleware/
│   │   └── upload.middleware.ts
│   ├── utils/
│   │   ├── file.util.ts
│   │   └── stream.util.ts
│   └── routes/
│       └── file.routes.ts
```

### Step 2: File Upload Middleware

Create `src/middleware/upload.middleware.ts`:

```typescript
import multer from "multer";
import path from "path";
import fs from "fs";
import { Request } from "express";

// Ensure upload directories exist
const ensureDirectoryExists = (dirPath: string) => {
  if (!fs.existsSync(dirPath)) {
    fs.mkdirSync(dirPath, { recursive: true });
  }
};

// Storage configuration
const storage = multer.diskStorage({
  destination: (req: Request, file: Express.Multer.File, cb) => {
    let uploadPath = "src/uploads/";

    // Organize by file type
    if (file.mimetype.startsWith("image/")) {
      uploadPath += "images/";
    } else if (file.mimetype.includes("pdf")) {
      uploadPath += "documents/";
    } else {
      uploadPath += "misc/";
    }

    ensureDirectoryExists(uploadPath);
    cb(null, uploadPath);
  },
  filename: (req: Request, file: Express.Multer.File, cb) => {
    // Generate unique filename
    const uniqueSuffix = Date.now() + "-" + Math.round(Math.random() * 1e9);
    const extension = path.extname(file.originalname);
    const baseName = path.basename(file.originalname, extension);
    cb(null, `${baseName}-${uniqueSuffix}${extension}`);
  },
});

// File filter
const fileFilter = (
  req: Request,
  file: Express.Multer.File,
  cb: multer.FileFilterCallback
) => {
  // Define allowed file types
  const allowedTypes = [
    "image/jpeg",
    "image/png",
    "image/gif",
    "image/webp",
    "application/pdf",
    "text/plain",
    "text/csv",
    "application/json",
    "application/xml",
  ];

  if (allowedTypes.includes(file.mimetype)) {
    cb(null, true);
  } else {
    cb(new Error(`File type ${file.mimetype} is not allowed`));
  }
};

// Multer configuration
export const upload = multer({
  storage,
  fileFilter,
  limits: {
    fileSize: 10 * 1024 * 1024, // 10MB limit
    files: 5, // Maximum 5 files per upload
  },
});

// Specific upload configurations
export const uploadSingle = upload.single("file");
export const uploadMultiple = upload.array("files", 5);
export const uploadFields = upload.fields([
  { name: "profile", maxCount: 1 },
  { name: "documents", maxCount: 3 },
]);
```

### Step 3: File Utilities

Create `src/utils/file.util.ts`:

```typescript
import fs from "fs";
import path from "path";
import mime from "mime-types";
import { promisify } from "util";

const fsExists = promisify(fs.exists);
const fsUnlink = promisify(fs.unlink);
const fsStat = promisify(fs.stat);

export class FileUtil {
  static async getFileInfo(filePath: string): Promise<{
    exists: boolean;
    size?: number;
    mimeType?: string;
    extension?: string;
  }> {
    try {
      const exists = await fsExists(filePath);
      if (!exists) {
        return { exists: false };
      }

      const stats = await fsStat(filePath);
      const mimeType = mime.lookup(filePath) || "application/octet-stream";
      const extension = path.extname(filePath);

      return {
        exists: true,
        size: stats.size,
        mimeType,
        extension,
      };
    } catch (error) {
      return { exists: false };
    }
  }

  static async deleteFile(filePath: string): Promise<boolean> {
    try {
      await fsUnlink(filePath);
      return true;
    } catch (error) {
      return false;
    }
  }

  static sanitizeFileName(fileName: string): string {
    // Remove potentially dangerous characters
    return fileName
      .replace(/[^a-zA-Z0-9.-]/g, "_")
      .replace(/_{2,}/g, "_")
      .substring(0, 255);
  }

  static getContentDisposition(
    fileName: string,
    inline: boolean = false
  ): string {
    const sanitized = this.sanitizeFileName(fileName);
    const disposition = inline ? "inline" : "attachment";
    return `${disposition}; filename="${sanitized}"`;
  }

  static generateUniqueFileName(originalName: string): string {
    const extension = path.extname(originalName);
    const baseName = path.basename(originalName, extension);
    const timestamp = Date.now();
    const random = Math.round(Math.random() * 1000);

    return `${baseName}-${timestamp}-${random}${extension}`;
  }
}
```

Create `src/utils/stream.util.ts`:

```typescript
import { Readable, Writable, Transform } from "stream";
import { Response } from "express";

export class StreamUtil {
  // Create a readable stream from buffer
  static createReadableFromBuffer(buffer: Buffer): Readable {
    const readable = new Readable();
    readable.push(buffer);
    readable.push(null); // End of stream
    return readable;
  }

  // Create a transform stream that processes data
  static createTransformStream(
    transformer: (chunk: Buffer) => Buffer
  ): Transform {
    return new Transform({
      transform(chunk: Buffer, encoding, callback) {
        try {
          const transformed = transformer(chunk);
          callback(null, transformed);
        } catch (error) {
          callback(error);
        }
      },
    });
  }

  // Stream file to response with progress tracking
  static streamFileToResponse(
    readable: Readable,
    response: Response,
    options: {
      filename?: string;
      contentType?: string;
      inline?: boolean;
      onProgress?: (bytesWritten: number) => void;
    } = {}
  ): Promise<void> {
    return new Promise((resolve, reject) => {
      const { filename, contentType, inline = false, onProgress } = options;
      let bytesWritten = 0;

      // Set headers
      if (contentType) {
        response.setHeader("Content-Type", contentType);
      }

      if (filename) {
        const disposition = inline ? "inline" : "attachment";
        response.setHeader(
          "Content-Disposition",
          `${disposition}; filename="${filename}"`
        );
      }

      // Track progress
      if (onProgress) {
        readable.on("data", (chunk: Buffer) => {
          bytesWritten += chunk.length;
          onProgress(bytesWritten);
        });
      }

      // Handle stream events
      readable.on("error", reject);
      response.on("error", reject);
      response.on("close", resolve);

      // Pipe the stream
      readable.pipe(response);
    });
  }

  // Create a CSV stream
  static createCSVStream(data: any[]): Readable {
    const readable = new Readable({ objectMode: true });

    // Add CSV header
    if (data.length > 0) {
      const headers = Object.keys(data[0]).join(",") + "\n";
      readable.push(headers);
    }

    // Add data rows
    data.forEach((row) => {
      const csvRow =
        Object.values(row)
          .map((value) =>
            typeof value === "string" ? `"${value.replace(/"/g, '""')}"` : value
          )
          .join(",") + "\n";
      readable.push(csvRow);
    });

    readable.push(null); // End of stream
    return readable;
  }
}
```

### Step 4: File Service

Create `src/services/file.service.ts`:

```typescript
import fs from "fs";
import path from "path";
import { Readable } from "stream";
import sharp from "sharp";
import QRCode from "qrcode";
import PDFDocument from "pdfkit";
import archiver from "archiver";
import { FileUtil } from "../utils/file.util";
import { StreamUtil } from "../utils/stream.util";
import { logger } from "../utils/logger.util";

export interface FileMetadata {
  filename: string;
  originalName: string;
  mimetype: string;
  size: number;
  path: string;
  uploadedAt: Date;
}

export class FileService {
  private readonly publicDir = "src/public";
  private readonly uploadsDir = "src/uploads";

  constructor() {
    this.ensureDirectories();
  }

  private ensureDirectories(): void {
    [this.publicDir, this.uploadsDir].forEach((dir) => {
      if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
      }
    });
  }

  // Save uploaded file metadata
  async saveFileMetadata(file: Express.Multer.File): Promise<FileMetadata> {
    const metadata: FileMetadata = {
      filename: file.filename,
      originalName: file.originalname,
      mimetype: file.mimetype,
      size: file.size,
      path: file.path,
      uploadedAt: new Date(),
    };

    logger.info("File uploaded", {
      filename: metadata.filename,
      size: metadata.size,
      mimetype: metadata.mimetype,
    });

    return metadata;
  }

  // Process image (resize, convert format)
  async processImage(
    filePath: string,
    options: {
      width?: number;
      height?: number;
      format?: "jpeg" | "png" | "webp";
      quality?: number;
    } = {}
  ): Promise<Buffer> {
    try {
      const { width, height, format = "jpeg", quality = 80 } = options;

      let pipeline = sharp(filePath);

      if (width || height) {
        pipeline = pipeline.resize(width, height, {
          fit: "inside",
          withoutEnlargement: true,
        });
      }

      const buffer = await pipeline.toFormat(format, { quality }).toBuffer();

      logger.debug("Image processed", {
        originalPath: filePath,
        width,
        height,
        format,
        outputSize: buffer.length,
      });

      return buffer;
    } catch (error) {
      logger.error("Error processing image", { filePath, options, error });
      throw error;
    }
  }

  // Generate QR Code
  async generateQRCode(
    text: string,
    options: {
      format?: "png" | "svg";
      width?: number;
      color?: { dark: string; light: string };
    } = {}
  ): Promise<Buffer | string> {
    try {
      const { format = "png", width = 200, color } = options;

      const qrOptions = {
        width,
        ...(color && { color }),
      };

      if (format === "svg") {
        return await QRCode.toString(text, { type: "svg", ...qrOptions });
      } else {
        return await QRCode.toBuffer(text, qrOptions);
      }
    } catch (error) {
      logger.error("Error generating QR code", { text, options, error });
      throw error;
    }
  }

  // Generate PDF document
  async generatePDF(content: {
    title: string;
    body: string;
    metadata?: any;
  }): Promise<Buffer> {
    return new Promise((resolve, reject) => {
      try {
        const doc = new PDFDocument();
        const buffers: Buffer[] = [];

        doc.on("data", (buffer) => buffers.push(buffer));
        doc.on("end", () => resolve(Buffer.concat(buffers)));
        doc.on("error", reject);

        // Add content
        doc.fontSize(20).text(content.title, 100, 100);
        doc.fontSize(12).text(content.body, 100, 150);

        if (content.metadata) {
          doc.moveDown();
          doc.text("Metadata:", { underline: true });
          Object.entries(content.metadata).forEach(([key, value]) => {
            doc.text(`${key}: ${value}`);
          });
        }

        doc.end();

        logger.debug("PDF generated", {
          title: content.title,
          bodyLength: content.body.length,
        });
      } catch (error) {
        reject(error);
      }
    });
  }

  // Create ZIP archive
  async createZipArchive(
    files: { name: string; content: Buffer | string }[]
  ): Promise<Buffer> {
    return new Promise((resolve, reject) => {
      const archive = archiver("zip", { zlib: { level: 9 } });
      const buffers: Buffer[] = [];

      archive.on("data", (chunk) => buffers.push(chunk));
      archive.on("end", () => resolve(Buffer.concat(buffers)));
      archive.on("error", reject);

      files.forEach((file) => {
        if (Buffer.isBuffer(file.content)) {
          archive.append(file.content, { name: file.name });
        } else {
          archive.append(file.content, { name: file.name });
        }
      });

      archive.finalize();

      logger.debug("ZIP archive created", {
        fileCount: files.length,
        totalSize: buffers.length,
      });
    });
  }

  // Export data as CSV
  async exportToCSV(
    data: any[],
    filename: string
  ): Promise<{ path: string; size: number }> {
    const csvStream = StreamUtil.createCSVStream(data);
    const outputPath = path.join(this.publicDir, "downloads", filename);

    // Ensure downloads directory exists
    const downloadsDir = path.dirname(outputPath);
    if (!fs.existsSync(downloadsDir)) {
      fs.mkdirSync(downloadsDir, { recursive: true });
    }

    return new Promise((resolve, reject) => {
      const writeStream = fs.createWriteStream(outputPath);

      writeStream.on("finish", () => {
        const stats = fs.statSync(outputPath);
        resolve({ path: outputPath, size: stats.size });
      });

      writeStream.on("error", reject);
      csvStream.pipe(writeStream);
    });
  }

  // Clean up old files
  async cleanupOldFiles(
    directory: string,
    maxAgeMs: number = 24 * 60 * 60 * 1000
  ): Promise<number> {
    try {
      const files = fs.readdirSync(directory);
      let deletedCount = 0;

      for (const file of files) {
        const filePath = path.join(directory, file);
        const stats = fs.statSync(filePath);

        if (Date.now() - stats.mtime.getTime() > maxAgeMs) {
          await FileUtil.deleteFile(filePath);
          deletedCount++;
        }
      }

      logger.info("File cleanup completed", {
        directory,
        deletedCount,
        maxAgeHours: maxAgeMs / (60 * 60 * 1000),
      });

      return deletedCount;
    } catch (error) {
      logger.error("Error during file cleanup", { directory, error });
      throw error;
    }
  }
}
```

### Step 5: File Controller

Create `src/controllers/file.controller.ts`:

```typescript
import { Request, Response, NextFunction } from "express";
import { BaseController } from "./base.controller";
import { FileService } from "../services/file.service";
import { ResponseUtil } from "../utils/response.util";
import { FileUtil } from "../utils/file.util";
import { StreamUtil } from "../utils/stream.util";
import { HTTP_STATUS } from "../constants/http-status";
import fs from "fs";
import path from "path";
import { Readable } from "stream";

export class FileController extends BaseController {
  constructor(private fileService: FileService) {
    super();
  }

  // Upload single file
  uploadSingle = this.handleAsync(async (req: Request, res: Response) => {
    if (!req.file) {
      return ResponseUtil.error(
        res,
        "No file uploaded",
        HTTP_STATUS.BAD_REQUEST
      );
    }

    const metadata = await this.fileService.saveFileMetadata(req.file);
    this.logAction("file_upload", req.user?.id, {
      filename: metadata.filename,
    });

    return ResponseUtil.created(res, "File uploaded successfully", {
      file: metadata,
    });
  });

  // Upload multiple files
  uploadMultiple = this.handleAsync(async (req: Request, res: Response) => {
    if (!req.files || !Array.isArray(req.files) || req.files.length === 0) {
      return ResponseUtil.error(
        res,
        "No files uploaded",
        HTTP_STATUS.BAD_REQUEST
      );
    }

    const metadata = await Promise.all(
      req.files.map((file) => this.fileService.saveFileMetadata(file))
    );

    this.logAction("files_upload", req.user?.id, { count: metadata.length });

    return ResponseUtil.created(res, "Files uploaded successfully", {
      files: metadata,
    });
  });

  // Download file
  downloadFile = this.handleAsync(async (req: Request, res: Response) => {
    const { filename } = req.params;
    const filePath = path.join("src/uploads", filename);

    const fileInfo = await FileUtil.getFileInfo(filePath);
    if (!fileInfo.exists) {
      return this.handleNotFound(res, "File");
    }

    const disposition = FileUtil.getContentDisposition(filename, false);

    res.setHeader("Content-Disposition", disposition);
    res.setHeader("Content-Type", fileInfo.mimeType!);
    res.setHeader("Content-Length", fileInfo.size!);

    this.logAction("file_download", req.user?.id, { filename });

    return res.sendFile(path.resolve(filePath));
  });

  // View file inline (e.g., images in browser)
  viewFile = this.handleAsync(async (req: Request, res: Response) => {
    const { filename } = req.params;
    const filePath = path.join("src/uploads", filename);

    const fileInfo = await FileUtil.getFileInfo(filePath);
    if (!fileInfo.exists) {
      return this.handleNotFound(res, "File");
    }

    const disposition = FileUtil.getContentDisposition(filename, true);

    res.setHeader("Content-Disposition", disposition);
    res.setHeader("Content-Type", fileInfo.mimeType!);

    this.logAction("file_view", req.user?.id, { filename });

    return res.sendFile(path.resolve(filePath));
  });

  // Process and download image
  processImage = this.handleAsync(async (req: Request, res: Response) => {
    const { filename } = req.params;
    const { width, height, format, quality } = req.query;

    const filePath = path.join("src/uploads/images", filename);

    const fileInfo = await FileUtil.getFileInfo(filePath);
    if (!fileInfo.exists) {
      return this.handleNotFound(res, "Image");
    }

    const processedImage = await this.fileService.processImage(filePath, {
      width: width ? parseInt(width as string) : undefined,
      height: height ? parseInt(height as string) : undefined,
      format: format as "jpeg" | "png" | "webp",
      quality: quality ? parseInt(quality as string) : undefined,
    });

    const outputFormat = format || "jpeg";
    const outputFilename = `processed-${Date.now()}.${outputFormat}`;

    res.setHeader("Content-Type", `image/${outputFormat}`);
    res.setHeader(
      "Content-Disposition",
      `inline; filename="${outputFilename}"`
    );

    this.logAction("image_process", req.user?.id, {
      filename,
      width,
      height,
      format,
    });

    return res.send(processedImage);
  });

  // Generate QR Code
  generateQRCode = this.handleAsync(async (req: Request, res: Response) => {
    const { text } = req.body;
    const { format = "png", width } = req.query;

    if (!text) {
      return ResponseUtil.error(
        res,
        "Text is required",
        HTTP_STATUS.BAD_REQUEST
      );
    }

    const qrCode = await this.fileService.generateQRCode(text, {
      format: format as "png" | "svg",
      width: width ? parseInt(width as string) : undefined,
    });

    if (format === "svg") {
      res.setHeader("Content-Type", "image/svg+xml");
      return res.send(qrCode);
    } else {
      res.setHeader("Content-Type", "image/png");
      res.setHeader("Content-Disposition", 'inline; filename="qrcode.png"');
      return res.send(qrCode);
    }
  });

  // Generate and download PDF
  generatePDF = this.handleAsync(async (req: Request, res: Response) => {
    const { title, body, metadata } = req.body;

    if (!title || !body) {
      return ResponseUtil.error(
        res,
        "Title and body are required",
        HTTP_STATUS.BAD_REQUEST
      );
    }

    const pdfBuffer = await this.fileService.generatePDF({
      title,
      body,
      metadata,
    });
    const filename = `${FileUtil.sanitizeFileName(title)}-${Date.now()}.pdf`;

    res.setHeader("Content-Type", "application/pdf");
    res.setHeader("Content-Disposition", `attachment; filename="${filename}"`);
    res.setHeader("Content-Length", pdfBuffer.length);

    this.logAction("pdf_generate", req.user?.id, {
      title,
      size: pdfBuffer.length,
    });

    return res.send(pdfBuffer);
  });

  // Export data as CSV
  exportCSV = this.handleAsync(async (req: Request, res: Response) => {
    const { data, filename = "export.csv" } = req.body;

    if (!Array.isArray(data) || data.length === 0) {
      return ResponseUtil.error(
        res,
        "Data array is required",
        HTTP_STATUS.BAD_REQUEST
      );
    }

    const csvStream = StreamUtil.createCSVStream(data);
    const sanitizedFilename = FileUtil.sanitizeFileName(filename);

    res.setHeader("Content-Type", "text/csv");
    res.setHeader(
      "Content-Disposition",
      `attachment; filename="${sanitizedFilename}"`
    );

    this.logAction("csv_export", req.user?.id, {
      filename: sanitizedFilename,
      rows: data.length,
    });

    return await StreamUtil.streamFileToResponse(csvStream, res, {
      filename: sanitizedFilename,
      contentType: "text/csv",
    });
  });

  // Create and download ZIP archive
  createArchive = this.handleAsync(async (req: Request, res: Response) => {
    const { files, archiveName = "archive.zip" } = req.body;

    if (!Array.isArray(files) || files.length === 0) {
      return ResponseUtil.error(
        res,
        "Files array is required",
        HTTP_STATUS.BAD_REQUEST
      );
    }

    const zipBuffer = await this.fileService.createZipArchive(files);
    const sanitizedName = FileUtil.sanitizeFileName(archiveName);

    res.setHeader("Content-Type", "application/zip");
    res.setHeader(
      "Content-Disposition",
      `attachment; filename="${sanitizedName}"`
    );
    res.setHeader("Content-Length", zipBuffer.length);

    this.logAction("archive_create", req.user?.id, {
      archiveName: sanitizedName,
      fileCount: files.length,
    });

    return res.send(zipBuffer);
  });

  // Stream large file
  streamFile = this.handleAsync(async (req: Request, res: Response) => {
    const { filename } = req.params;
    const filePath = path.join("src/uploads", filename);

    const fileInfo = await FileUtil.getFileInfo(filePath);
    if (!fileInfo.exists) {
      return this.handleNotFound(res, "File");
    }

    const range = req.headers.range;
    const fileSize = fileInfo.size!;

    if (range) {
      // Handle range requests (for video/audio streaming)
      const parts = range.replace(/bytes=/, "").split("-");
      const start = parseInt(parts[0], 10);
      const end = parts[1] ? parseInt(parts[1], 10) : fileSize - 1;
      const chunksize = end - start + 1;

      const stream = fs.createReadStream(filePath, { start, end });

      res.status(206);
      res.setHeader("Content-Range", `bytes ${start}-${end}/${fileSize}`);
      res.setHeader("Accept-Ranges", "bytes");
      res.setHeader("Content-Length", chunksize);
      res.setHeader("Content-Type", fileInfo.mimeType!);

      stream.pipe(res);
    } else {
      // Stream entire file
      const stream = fs.createReadStream(filePath);

      res.setHeader("Content-Length", fileSize);
      res.setHeader("Content-Type", fileInfo.mimeType!);
      res.setHeader("Content-Disposition", `inline; filename="${filename}"`);

      stream.pipe(res);
    }

    this.logAction("file_stream", req.user?.id, {
      filename,
      hasRange: !!range,
    });
  });

  // Send custom HTML response
  sendHTML = this.handleAsync(async (req: Request, res: Response) => {
    const { title = "Custom Page", content = "Hello World!" } = req.body;

    const html = `
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>${title}</title>
        <style>
            body { font-family: Arial, sans-serif; margin: 40px; }
            .container { max-width: 800px; margin: 0 auto; }
            .header { border-bottom: 2px solid #333; padding-bottom: 20px; }
            .content { margin-top: 20px; line-height: 1.6; }
        </style>
    </head>
    <body>
        <div class="container">
            <div class="header">
                <h1>${title}</h1>
                <p>Generated at: ${new Date().toISOString()}</p>
            </div>
            <div class="content">
                ${content}
            </div>
        </div>
    </body>
    </html>
    `;

    res.setHeader("Content-Type", "text/html");
    return res.send(html);
  });

  // Send XML response
  sendXML = this.handleAsync(async (req: Request, res: Response) => {
    const { data } = req.body;

    const xml = `<?xml version="1.0" encoding="UTF-8"?>
<response>
    <timestamp>${new Date().toISOString()}</timestamp>
    <data>${JSON.stringify(data)}</data>
</response>`;

    res.setHeader("Content-Type", "application/xml");
    return res.send(xml);
  });
}
```

### Step 6: File Routes

Create `src/routes/file.routes.ts`:

```typescript
import { Router } from "express";
import { FileController } from "../controllers/file.controller";
import { FileService } from "../services/file.service";
import { uploadSingle, uploadMultiple } from "../middleware/upload.middleware";
import { authenticateToken } from "../middleware/auth.middleware";

const router = Router();

// Initialize dependencies
const fileService = new FileService();
const fileController = new FileController(fileService);

// File upload routes (require authentication)
router.post(
  "/upload/single",
  authenticateToken,
  uploadSingle,
  fileController.uploadSingle
);
router.post(
  "/upload/multiple",
  authenticateToken,
  uploadMultiple,
  fileController.uploadMultiple
);

// File download and view routes
router.get("/download/:filename", fileController.downloadFile);
router.get("/view/:filename", fileController.viewFile);
router.get("/stream/:filename", fileController.streamFile);

// Image processing
router.get("/image/process/:filename", fileController.processImage);

// Generate content
router.post("/generate/qr", fileController.generateQRCode);
router.post("/generate/pdf", fileController.generatePDF);
router.post(
  "/generate/archive",
  authenticateToken,
  fileController.createArchive
);

// Export data
router.post("/export/csv", authenticateToken, fileController.exportCSV);

// Custom responses
router.post("/response/html", fileController.sendHTML);
router.post("/response/xml", fileController.sendXML);

export default router;
```

### Step 7: Testing Different Response Types

Start the application and test various response types:

```bash
# Upload a single file
curl -X POST http://localhost:3000/api/v1/files/upload/single \
  -H "Authorization: Bearer YOUR_TOKEN" \
  -F "file=@/path/to/your/image.jpg"

# Download the uploaded file
curl -O http://localhost:3000/api/v1/files/download/filename.jpg

# View image in browser (inline)
curl http://localhost:3000/api/v1/files/view/filename.jpg

# Process image (resize and convert)
curl "http://localhost:3000/api/v1/files/image/process/filename.jpg?width=300&height=200&format=webp&quality=80"

# Generate QR Code
curl -X POST http://localhost:3000/api/v1/files/generate/qr \
  -H "Content-Type: application/json" \
  -d '{"text": "https://example.com"}' \
  --output qrcode.png

# Generate PDF
curl -X POST http://localhost:3000/api/v1/files/generate/pdf \
  -H "Content-Type: application/json" \
  -d '{"title": "Sample Report", "body": "This is a sample PDF document."}' \
  --output report.pdf

# Export data as CSV
curl -X POST http://localhost:3000/api/v1/files/export/csv \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer YOUR_TOKEN" \
  -d '{"data": [{"name": "John", "age": 30}, {"name": "Jane", "age": 25}], "filename": "users.csv"}' \
  --output users.csv

# Generate custom HTML page
curl -X POST http://localhost:3000/api/v1/files/response/html \
  -H "Content-Type: application/json" \
  -d '{"title": "Custom Page", "content": "<h2>Welcome!</h2><p>This is custom HTML content.</p>"}'

# Generate XML response
curl -X POST http://localhost:3000/api/v1/files/response/xml \
  -H "Content-Type: application/json" \
  -d '{"data": {"message": "Hello World", "timestamp": "2023-01-01T00:00:00Z"}}'
```

## Response Types and Methods Demonstrated

### 1. **File Operations**

```typescript
// Send file for download
res.sendFile(path.resolve(filePath));

// Send file inline (view in browser)
res.setHeader("Content-Disposition", 'inline; filename="image.jpg"');

// Stream file with range support (for large files/videos)
const stream = fs.createReadStream(filePath, { start, end });
stream.pipe(res);
```

### 2. **Different Content Types**

```typescript
// JSON response
res.json({ data: results });

// HTML response
res.setHeader("Content-Type", "text/html");
res.send(htmlString);

// XML response
res.setHeader("Content-Type", "application/xml");
res.send(xmlString);

// Binary data (images, PDFs)
res.setHeader("Content-Type", "image/png");
res.send(buffer);
```

### 3. **Streaming Responses**

```typescript
// Stream CSV data
const csvStream = StreamUtil.createCSVStream(data);
csvStream.pipe(res);

// Stream with progress tracking
await StreamUtil.streamFileToResponse(readable, res, options);
```

### 4. **Custom Headers and Attachments**

```typescript
// Set custom headers
res.setHeader("Content-Disposition", 'attachment; filename="report.pdf"');
res.setHeader("Content-Type", "application/pdf");
res.setHeader("Content-Length", buffer.length);

// Set cookies
res.cookie("download-token", token, { httpOnly: true });
```

## Best Practices Demonstrated

1. **File Security**: Validate file types and sanitize filenames
2. **Performance**: Use streams for large files
3. **Error Handling**: Proper error handling for file operations
4. **Memory Management**: Avoid loading large files into memory
5. **Content Negotiation**: Proper MIME types and headers
6. **Range Requests**: Support for partial content delivery
7. **File Organization**: Structured file storage and cleanup

This comprehensive file handling system demonstrates how Express.js can serve various response types while maintaining security, performance, and user experience best practices.

---

## References and Resources

### File Handling Libraries

- [Multer - File Upload](https://github.com/expressjs/multer)
- [Sharp - Image Processing](https://sharp.pixelplumbing.com/)
- [PDFKit - PDF Generation](http://pdfkit.org/)
- [Archiver - ZIP Creation](https://github.com/archiverjs/node-archiver)
- [QRCode - QR Code Generation](https://github.com/soldair/node-qrcode)

### Express.js Response Methods

- [Express Response Object](https://expressjs.com/en/api.html#res)
- [Express File Serving](https://expressjs.com/en/api.html#res.sendFile)
- [Express Static Files](https://expressjs.com/en/starter/static-files.html)

### Streaming and Performance

- [Node.js Streams](https://nodejs.org/api/stream.html)
- [HTTP Range Requests](https://developer.mozilla.org/en-US/docs/Web/HTTP/Range_requests)
- [Content-Disposition Header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Disposition)

### Security Considerations

- [File Upload Security](https://owasp.org/www-community/vulnerabilities/Unrestricted_File_Upload)
- [MIME Type Security](https://developer.mozilla.org/en-US/docs/Web/Security/Securing_your_site/MIME_type_security)
- [Content Security Policy](https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP)
