# NestJS with Swagger, TypeORM & PostgreSQL

## Overview

This exercise extends our basic NestJS application by adding professional documentation with Swagger, database integration using TypeORM with PostgreSQL, and implementing DTOs for request and response validation. You'll learn how to set up enterprise-grade features that are essential for production applications.

## Learning Objectives

- Set up Swagger documentation for automatic API documentation
- Integrate TypeORM with PostgreSQL database
- Create and use DTOs for request and response validation
- Understand entity relationships and database migrations
- Implement repository pattern with TypeORM
- Use environment configuration for different environments

## Prerequisites

- Completed basic NestJS application from previous topic (1.9.md)
- Docker installed for PostgreSQL
- Basic understanding of SQL and database concepts

## Exercise: Extending the Product Catalog with Database and Documentation

We'll enhance our product catalog API by adding PostgreSQL database, proper DTOs, and Swagger documentation.

### Step 1: Project Setup and Dependencies

Starting from our existing NestJS project, install required dependencies:

```bash
# Navigate to your existing NestJS project
cd nestjs-product-catalog

# Install TypeORM and PostgreSQL dependencies
npm install @nestjs/typeorm typeorm pg @nestjs/config

# Install development dependencies
npm install -D @types/pg

# Install Swagger dependencies
npm install @nestjs/swagger swagger-ui-express

# Install validation dependencies (if not already installed)
npm install class-validator class-transformer
```

### Step 2: Database Setup with Docker

Create `docker-compose.yml` in your project root:

```yaml
version: "3.8"

services:
  postgres:
    image: postgres:15-alpine
    restart: always
    environment:
      POSTGRES_USER: nestjs_user
      POSTGRES_PASSWORD: nestjs_password
      POSTGRES_DB: product_catalog
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./init.sql:/docker-entrypoint-initdb.d/init.sql

  pgadmin:
    image: dpage/pgadmin4:latest
    restart: always
    environment:
      PGADMIN_DEFAULT_EMAIL: admin@example.com
      PGADMIN_DEFAULT_PASSWORD: admin123
    ports:
      - "5050:80"
    depends_on:
      - postgres

volumes:
  postgres_data:
```

Create `init.sql` for initial database setup:

```sql
-- Create database if it doesn't exist
-- CREATE DATABASE product_catalog;

-- Create extensions
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- Initial setup completed
-- Tables will be created by TypeORM migrations
```

Start the database:

```bash
# Start PostgreSQL and pgAdmin
docker-compose up -d

# Verify containers are running
docker-compose ps
```

### Step 3: Environment Configuration

Create `.env` file:

```env
# Database Configuration
DB_HOST=localhost
DB_PORT=5432
DB_USERNAME=nestjs_user
DB_PASSWORD=nestjs_password
DB_NAME=product_catalog

# Application Configuration
PORT=3000
NODE_ENV=development

# JWT Configuration (for future use)
JWT_SECRET=your_jwt_secret_key_here
JWT_EXPIRES_IN=24h

# API Configuration
API_PREFIX=api/v1
```

Create `.env.example`:

```env
# Database Configuration
DB_HOST=localhost
DB_PORT=5432
DB_USERNAME=nestjs_user
DB_PASSWORD=nestjs_password
DB_NAME=product_catalog

# Application Configuration
PORT=3000
NODE_ENV=development

# JWT Configuration
JWT_SECRET=your_jwt_secret_key_here
JWT_EXPIRES_IN=24h

# API Configuration
API_PREFIX=api/v1
```

Add `.env` to your `.gitignore`:

```gitignore
# Environment files
.env
.env.local
.env.*.local

# Database
*.sqlite
*.db

# Logs
logs
*.log

# Dependencies
node_modules
dist
```

### Step 4: Database Configuration Module

Create `src/config/database.config.ts`:

```typescript
import { TypeOrmModuleOptions } from "@nestjs/typeorm";
import { ConfigService } from "@nestjs/config";
import { Product } from "../entities/product.entity";
import { Category } from "../entities/category.entity";

export const getDatabaseConfig = (
  configService: ConfigService
): TypeOrmModuleOptions => ({
  type: "postgres",
  host: configService.get<string>("DB_HOST"),
  port: configService.get<number>("DB_PORT"),
  username: configService.get<string>("DB_USERNAME"),
  password: configService.get<string>("DB_PASSWORD"),
  database: configService.get<string>("DB_NAME"),
  entities: [Product, Category],
  synchronize: configService.get<string>("NODE_ENV") === "development", // Only in development
  logging: configService.get<string>("NODE_ENV") === "development",
  migrations: ["dist/migrations/*{.ts,.js}"],
  migrationsRun: false, // Set to true if you want auto-run migrations
  ssl:
    configService.get<string>("NODE_ENV") === "production"
      ? { rejectUnauthorized: false }
      : false,
});
```

### Step 5: Create DTOs

Create `src/dto/create-category.dto.ts`:

```typescript
import { ApiProperty } from "@nestjs/swagger";
import { IsString, IsOptional, IsUUID, MaxLength } from "class-validator";

export class CreateCategoryDto {
  @ApiProperty({
    description: "Category name",
    example: "Electronics",
    maxLength: 100,
  })
  @IsString()
  @MaxLength(100, { message: "Name must not exceed 100 characters" })
  name: string;

  @ApiProperty({
    description: "Category description",
    example: "Electronic devices and accessories",
    maxLength: 500,
    required: false,
  })
  @IsOptional()
  @IsString()
  @MaxLength(500, { message: "Description must not exceed 500 characters" })
  description?: string;

  @ApiProperty({
    description: "Parent category ID for nested categories",
    example: "f47ac10b-58cc-4372-a567-0e02b2c3d479",
    required: false,
  })
  @IsOptional()
  @IsUUID(4, { message: "Parent category ID must be a valid UUID" })
  parentCategoryId?: string;

  @ApiProperty({
    description: "Category tags for filtering",
    example: ["gadgets", "technology"],
    required: false,
    type: [String],
  })
  @IsOptional()
  @IsString({ each: true })
  tags?: string[];
}
```

Create `src/dto/update-category.dto.ts`:

```typescript
import { ApiProperty, PartialType } from "@nestjs/swagger";
import { CreateCategoryDto } from "./create-category.dto";

export class UpdateCategoryDto extends PartialType(CreateCategoryDto) {
  @ApiProperty({
    description: "Category name",
    example: "Electronics & Gadgets",
    maxLength: 100,
    required: false,
  })
  name?: string;

  @ApiProperty({
    description: "Category description",
    example: "Updated description for electronic devices",
    maxLength: 500,
    required: false,
  })
  description?: string;

  @ApiProperty({
    description: "Parent category ID",
    example: "f47ac10b-58cc-4372-a567-0e02b2c3d479",
    required: false,
  })
  parentCategoryId?: string;

  @ApiProperty({
    description: "Category tags",
    example: ["electronics", "gadgets", "smart-devices"],
    required: false,
    type: [String],
  })
  tags?: string[];
}
```

Update `src/dto/create-product.dto.ts`:

```typescript
import { ApiProperty } from "@nestjs/swagger";
import {
  IsString,
  IsNumber,
  IsOptional,
  IsArray,
  IsUUID,
  Min,
  MaxLength,
} from "class-validator";

export class CreateProductDto {
  @ApiProperty({
    description: "Product name",
    example: "iPhone 14 Pro",
    maxLength: 100,
  })
  @IsString()
  @MaxLength(100, { message: "Name must not exceed 100 characters" })
  name: string;

  @ApiProperty({
    description: "Product description",
    example: "Latest iPhone with advanced camera system",
    maxLength: 1000,
  })
  @IsString()
  @MaxLength(1000, { message: "Description must not exceed 1000 characters" })
  description: string;

  @ApiProperty({
    description: "Product price in USD",
    example: 999.99,
    minimum: 0,
  })
  @IsNumber(
    { maxDecimalPlaces: 2 },
    { message: "Price must be a valid number with up to 2 decimal places" }
  )
  @Min(0, { message: "Price must be a positive number" })
  price: number;

  @ApiProperty({
    description: "Category ID",
    example: "f47ac10b-58cc-4372-a567-0e02b2c3d479",
  })
  @IsUUID(4, { message: "Category ID must be a valid UUID" })
  categoryId: string;

  @ApiProperty({
    description: "Product tags for filtering",
    example: ["smartphone", "apple", "ios"],
    required: false,
    type: [String],
  })
  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  tags?: string[];

  @ApiProperty({
    description: "Stock quantity",
    example: 50,
    minimum: 0,
    required: false,
  })
  @IsOptional()
  @IsNumber({}, { message: "Stock quantity must be a valid number" })
  @Min(0, { message: "Stock quantity must be non-negative" })
  stock?: number;

  @ApiProperty({
    description: "Product image URLs",
    example: [
      "https://example.com/image1.jpg",
      "https://example.com/image2.jpg",
    ],
    required: false,
    type: [String],
  })
  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  images?: string[];
}
```

Update `src/dto/update-product.dto.ts`:

```typescript
import { ApiProperty, PartialType } from "@nestjs/swagger";
import { CreateProductDto } from "./create-product.dto";

export class UpdateProductDto extends PartialType(CreateProductDto) {}
```

Create response DTOs `src/dto/response/category-response.dto.ts`:

```typescript
import { ApiProperty } from "@nestjs/swagger";

export class CategoryResponseDto {
  @ApiProperty({
    description: "Category ID",
    example: "f47ac10b-58cc-4372-a567-0e02b2c3d479",
  })
  id: string;

  @ApiProperty({
    description: "Category name",
    example: "Electronics",
  })
  name: string;

  @ApiProperty({
    description: "Category description",
    example: "Electronic devices and accessories",
    nullable: true,
  })
  description: string | null;

  @ApiProperty({
    description: "Parent category ID",
    example: "f47ac10b-58cc-4372-a567-0e02b2c3d479",
    nullable: true,
  })
  parentCategoryId: string | null;

  @ApiProperty({
    description: "Category tags",
    example: ["gadgets", "technology"],
    type: [String],
  })
  tags: string[];

  @ApiProperty({
    description: "Creation timestamp",
    example: "2023-10-01T10:00:00Z",
  })
  createdAt: Date;

  @ApiProperty({
    description: "Last update timestamp",
    example: "2023-10-01T10:00:00Z",
  })
  updatedAt: Date;

  @ApiProperty({
    description: "Number of products in this category",
    example: 15,
  })
  productCount?: number;
}
```

Create `src/dto/response/product-response.dto.ts`:

```typescript
import { ApiProperty } from "@nestjs/swagger";
import { CategoryResponseDto } from "./category-response.dto";

export class ProductResponseDto {
  @ApiProperty({
    description: "Product ID",
    example: "f47ac10b-58cc-4372-a567-0e02b2c3d479",
  })
  id: string;

  @ApiProperty({
    description: "Product name",
    example: "iPhone 14 Pro",
  })
  name: string;

  @ApiProperty({
    description: "Product description",
    example: "Latest iPhone with advanced camera system",
  })
  description: string;

  @ApiProperty({
    description: "Product price in USD",
    example: 999.99,
  })
  price: number;

  @ApiProperty({
    description: "Product tags",
    example: ["smartphone", "apple", "ios"],
    type: [String],
  })
  tags: string[];

  @ApiProperty({
    description: "Stock quantity",
    example: 50,
  })
  stock: number;

  @ApiProperty({
    description: "Product images",
    example: ["https://example.com/image1.jpg"],
    type: [String],
  })
  images: string[];

  @ApiProperty({
    description: "Creation timestamp",
    example: "2023-10-01T10:00:00Z",
  })
  createdAt: Date;

  @ApiProperty({
    description: "Last update timestamp",
    example: "2023-10-01T10:00:00Z",
  })
  updatedAt: Date;

  @ApiProperty({
    description: "Category information",
    type: CategoryResponseDto,
  })
  category: CategoryResponseDto;
}
```

### Step 6: Create Database Entities

Create `src/entities/category.entity.ts`:

```typescript
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  OneToMany,
} from "typeorm";
import { Product } from "./product.entity";

@Entity("categories")
export class Category {
  @PrimaryGeneratedColumn("uuid")
  id: string;

  @Column({ length: 100, unique: true })
  name: string;

  @Column({ length: 500, nullable: true })
  description: string;

  @Column({ name: "parent_category_id", nullable: true })
  parentCategoryId: string;

  @Column("simple-array", { nullable: true })
  tags: string[];

  @CreateDateColumn({ name: "created_at" })
  createdAt: Date;

  @UpdateDateColumn({ name: "updated_at" })
  updatedAt: Date;

  // Relations
  @OneToMany(() => Product, (product) => product.category)
  products: Product[];
}
```

Create `src/entities/product.entity.ts`:

```typescript
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  ManyToOne,
  JoinColumn,
} from "typeorm";
import { Category } from "./category.entity";

@Entity("products")
export class Product {
  @PrimaryGeneratedColumn("uuid")
  id: string;

  @Column({ length: 100 })
  name: string;

  @Column({ length: 1000 })
  description: string;

  @Column("decimal", { precision: 10, scale: 2 })
  price: number;

  @Column({ name: "category_id" })
  categoryId: string;

  @Column("simple-array", { nullable: true })
  tags: string[];

  @Column({ default: 0 })
  stock: number;

  @Column("simple-array", { nullable: true })
  images: string[];

  @Column({ name: "is_active", default: true })
  isActive: boolean;

  @CreateDateColumn({ name: "created_at" })
  createdAt: Date;

  @UpdateDateColumn({ name: "updated_at" })
  updatedAt: Date;

  // Relations
  @ManyToOne(() => Category, (category) => category.products)
  @JoinColumn({ name: "category_id" })
  category: Category;
}
```

### Step 7: Create Services with TypeORM

Create `src/categories/categories.service.ts`:

```typescript
import {
  Injectable,
  NotFoundException,
  ConflictException,
} from "@nestjs/common";
import { InjectRepository } from "@nestjs/typeorm";
import { Repository } from "typeorm";
import { Category } from "../entities/category.entity";
import { CreateCategoryDto } from "../dto/create-category.dto";
import { UpdateCategoryDto } from "../dto/update-category.dto";

@Injectable()
export class CategoriesService {
  constructor(
    @InjectRepository(Category)
    private categoriesRepository: Repository<Category>
  ) {}

  async create(createCategoryDto: CreateCategoryDto): Promise<Category> {
    // Check if category name already exists
    const existingCategory = await this.categoriesRepository.findOne({
      where: { name: createCategoryDto.name },
    });

    if (existingCategory) {
      throw new ConflictException(
        `Category with name "${createCategoryDto.name}" already exists`
      );
    }

    // Validate parent category if provided
    if (createCategoryDto.parentCategoryId) {
      const parentCategory = await this.categoriesRepository.findOne({
        where: { id: createCategoryDto.parentCategoryId },
      });

      if (!parentCategory) {
        throw new NotFoundException(
          `Parent category with ID ${createCategoryDto.parentCategoryId} not found`
        );
      }
    }

    const category = this.categoriesRepository.create(createCategoryDto);
    return await this.categoriesRepository.save(category);
  }

  async findAll(): Promise<Category[]> {
    return await this.categoriesRepository.find({
      relations: ["products"],
      order: { createdAt: "DESC" },
    });
  }

  async findOne(id: string): Promise<Category> {
    const category = await this.categoriesRepository.findOne({
      where: { id },
      relations: ["products"],
    });

    if (!category) {
      throw new NotFoundException(`Category with ID ${id} not found`);
    }

    return category;
  }

  async update(
    id: string,
    updateCategoryDto: UpdateCategoryDto
  ): Promise<Category> {
    const category = await this.findOne(id);

    // Check for name conflicts if name is being updated
    if (updateCategoryDto.name && updateCategoryDto.name !== category.name) {
      const existingCategory = await this.categoriesRepository.findOne({
        where: { name: updateCategoryDto.name },
      });

      if (existingCategory) {
        throw new ConflictException(
          `Category with name "${updateCategoryDto.name}" already exists`
        );
      }
    }

    // Validate parent category if being updated
    if (updateCategoryDto.parentCategoryId) {
      const parentCategory = await this.categoriesRepository.findOne({
        where: { id: updateCategoryDto.parentCategoryId },
      });

      if (!parentCategory) {
        throw new NotFoundException(
          `Parent category with ID ${updateCategoryDto.parentCategoryId} not found`
        );
      }
    }

    await this.categoriesRepository.update(id, updateCategoryDto);
    return await this.findOne(id);
  }

  async remove(id: string): Promise<void> {
    const category = await this.findOne(id);

    // Check if category has products
    const productCount = category.products?.length || 0;
    if (productCount > 0) {
      throw new ConflictException(
        `Cannot delete category with ${productCount} associated products`
      );
    }

    await this.categoriesRepository.delete(id);
  }

  async getProductCount(categoryId: string): Promise<number> {
    const category = await this.categoriesRepository.findOne({
      where: { id: categoryId },
      relations: ["products"],
    });

    return category?.products?.length || 0;
  }
}
```

Update `src/products/products.service.ts`:

```typescript
import {
  Injectable,
  NotFoundException,
  BadRequestException,
} from "@nestjs/common";
import { InjectRepository } from "@nestjs/typeorm";
import { Repository } from "typeorm";
import { Product } from "../entities/product.entity";
import { Category } from "../entities/category.entity";
import { CreateProductDto } from "../dto/create-product.dto";
import { UpdateProductDto } from "../dto/update-product.dto";

export interface ProductFilter {
  categoryId?: string;
  minPrice?: number;
  maxPrice?: number;
  search?: string;
  tags?: string[];
}

@Injectable()
export class ProductsService {
  constructor(
    @InjectRepository(Product)
    private productsRepository: Repository<Product>,
    @InjectRepository(Category)
    private categoriesRepository: Repository<Category>
  ) {}

  async create(createProductDto: CreateProductDto): Promise<Product> {
    // Verify category exists
    const category = await this.categoriesRepository.findOne({
      where: { id: createProductDto.categoryId },
    });

    if (!category) {
      throw new NotFoundException(
        `Category with ID ${createProductDto.categoryId} not found`
      );
    }

    // Check for duplicate product name
    const existingProduct = await this.productsRepository.findOne({
      where: { name: createProductDto.name, isActive: true },
    });

    if (existingProduct) {
      throw new BadRequestException(
        `Product with name "${createProductDto.name}" already exists`
      );
    }

    const product = this.productsRepository.create({
      ...createProductDto,
      stock: createProductDto.stock || 0,
      tags: createProductDto.tags || [],
      images: createProductDto.images || [],
    });

    return await this.productsRepository.save(product);
  }

  async findAll(filter?: ProductFilter): Promise<Product[]> {
    const queryBuilder = this.productsRepository
      .createQueryBuilder("product")
      .leftJoinAndSelect("product.category", "category")
      .where("product.isActive = :isActive", { isActive: true });

    if (filter) {
      if (filter.categoryId) {
        queryBuilder.andWhere("product.categoryId = :categoryId", {
          categoryId: filter.categoryId,
        });
      }

      if (filter.minPrice !== undefined) {
        queryBuilder.andWhere("product.price >= :minPrice", {
          minPrice: filter.minPrice,
        });
      }

      if (filter.maxPrice !== undefined) {
        queryBuilder.andWhere("product.price <= :maxPrice", {
          maxPrice: filter.maxPrice,
        });
      }

      if (filter.search) {
        queryBuilder.andWhere(
          "(LOWER(product.name) LIKE LOWER(:search) OR LOWER(product.description) LIKE LOWER(:search))",
          { search: `%${filter.search}%` }
        );
      }

      if (filter.tags && filter.tags.length > 0) {
        queryBuilder.andWhere("product.tags && :tags", { tags: filter.tags });
      }
    }

    return await queryBuilder.orderBy("product.createdAt", "DESC").getMany();
  }

  async findOne(id: string): Promise<Product> {
    const product = await this.productsRepository.findOne({
      where: { id, isActive: true },
      relations: ["category"],
    });

    if (!product) {
      throw new NotFoundException(`Product with ID ${id} not found`);
    }

    return product;
  }

  async update(
    id: string,
    updateProductDto: UpdateProductDto
  ): Promise<Product> {
    const product = await this.findOne(id);

    // Verify category exists if being updated
    if (updateProductDto.categoryId) {
      const category = await this.categoriesRepository.findOne({
        where: { id: updateProductDto.categoryId },
      });

      if (!category) {
        throw new NotFoundException(
          `Category with ID ${updateProductDto.categoryId} not found`
        );
      }
    }

    // Check for name conflicts if name is being updated
    if (updateProductDto.name && updateProductDto.name !== product.name) {
      const existingProduct = await this.productsRepository.findOne({
        where: { name: updateProductDto.name, isActive: true },
      });

      if (existingProduct) {
        throw new BadRequestException(
          `Product with name "${updateProductDto.name}" already exists`
        );
      }
    }

    await this.productsRepository.update(id, updateProductDto);
    return await this.findOne(id);
  }

  async remove(id: string): Promise<void> {
    await this.findOne(id); // Verify product exists

    // Soft delete
    await this.productsRepository.update(id, { isActive: false });
  }

  async updateStock(id: string, quantity: number): Promise<Product> {
    const product = await this.findOne(id);

    if (product.stock + quantity < 0) {
      throw new BadRequestException("Insufficient stock");
    }

    await this.productsRepository.update(id, {
      stock: product.stock + quantity,
    });

    return await this.findOne(id);
  }
}
```

### Step 8: Create Controllers with Swagger Documentation

Create `src/categories/categories.controller.ts`:

```typescript
import {
  Controller,
  Get,
  Post,
  Body,
  Param,
  Put,
  Delete,
  ParseUUIDPipe,
  UsePipes,
  ValidationPipe,
} from "@nestjs/common";
import {
  ApiTags,
  ApiOperation,
  ApiResponse,
  ApiParam,
  ApiBody,
} from "@nestjs/swagger";
import { CategoriesService } from "./categories.service";
import { CreateCategoryDto } from "../dto/create-category.dto";
import { UpdateCategoryDto } from "../dto/update-category.dto";
import { CategoryResponseDto } from "../dto/response/category-response.dto";

@ApiTags("Categories")
@Controller("categories")
export class CategoriesController {
  constructor(private readonly categoriesService: CategoriesService) {}

  @Post()
  @ApiOperation({ summary: "Create a new category" })
  @ApiBody({ type: CreateCategoryDto })
  @ApiResponse({
    status: 201,
    description: "Category created successfully",
    type: CategoryResponseDto,
  })
  @ApiResponse({
    status: 409,
    description: "Category with this name already exists",
  })
  @UsePipes(new ValidationPipe({ transform: true, whitelist: true }))
  async create(@Body() createCategoryDto: CreateCategoryDto) {
    const category = await this.categoriesService.create(createCategoryDto);

    return {
      success: true,
      message: "Category created successfully",
      data: { category },
    };
  }

  @Get()
  @ApiOperation({ summary: "Get all categories" })
  @ApiResponse({
    status: 200,
    description: "Categories retrieved successfully",
    type: [CategoryResponseDto],
  })
  async findAll() {
    const categories = await this.categoriesService.findAll();

    return {
      success: true,
      message: "Categories retrieved successfully",
      data: {
        categories,
        count: categories.length,
      },
    };
  }

  @Get(":id")
  @ApiOperation({ summary: "Get category by ID" })
  @ApiParam({
    name: "id",
    description: "Category UUID",
    example: "f47ac10b-58cc-4372-a567-0e02b2c3d479",
  })
  @ApiResponse({
    status: 200,
    description: "Category retrieved successfully",
    type: CategoryResponseDto,
  })
  @ApiResponse({
    status: 404,
    description: "Category not found",
  })
  async findOne(@Param("id", ParseUUIDPipe) id: string) {
    const category = await this.categoriesService.findOne(id);

    return {
      success: true,
      message: "Category retrieved successfully",
      data: { category },
    };
  }

  @Put(":id")
  @ApiOperation({ summary: "Update category" })
  @ApiParam({
    name: "id",
    description: "Category UUID",
    example: "f47ac10b-58cc-4372-a567-0e02b2c3d479",
  })
  @ApiBody({ type: UpdateCategoryDto })
  @ApiResponse({
    status: 200,
    description: "Category updated successfully",
    type: CategoryResponseDto,
  })
  @ApiResponse({
    status: 404,
    description: "Category not found",
  })
  @ApiResponse({
    status: 409,
    description: "Category name already exists",
  })
  @UsePipes(new ValidationPipe({ transform: true, whitelist: true }))
  async update(
    @Param("id", ParseUUIDPipe) id: string,
    @Body() updateCategoryDto: UpdateCategoryDto
  ) {
    const category = await this.categoriesService.update(id, updateCategoryDto);

    return {
      success: true,
      message: "Category updated successfully",
      data: { category },
    };
  }

  @Delete(":id")
  @ApiOperation({ summary: "Delete category" })
  @ApiParam({
    name: "id",
    description: "Category UUID",
    example: "f47ac10b-58cc-4372-a567-0e02b2c3d479",
  })
  @ApiResponse({
    status: 200,
    description: "Category deleted successfully",
  })
  @ApiResponse({
    status: 404,
    description: "Category not found",
  })
  @ApiResponse({
    status: 409,
    description: "Cannot delete category with associated products",
  })
  async remove(@Param("id", ParseUUIDPipe) id: string) {
    await this.categoriesService.remove(id);

    return {
      success: true,
      message: "Category deleted successfully",
    };
  }
}
```

Update `src/products/products.controller.ts`:

```typescript
import {
  Controller,
  Get,
  Post,
  Body,
  Param,
  Put,
  Delete,
  Query,
  ParseUUIDPipe,
  UsePipes,
  ValidationPipe,
} from "@nestjs/common";
import {
  ApiTags,
  ApiOperation,
  ApiResponse,
  ApiParam,
  ApiBody,
  ApiQuery,
} from "@nestjs/swagger";
import { ProductsService } from "./products.service";
import { CreateProductDto } from "../dto/create-product.dto";
import { UpdateProductDto } from "../dto/update-product.dto";
import { ProductResponseDto } from "../dto/response/product-response.dto";

@ApiTags("Products")
@Controller("products")
export class ProductsController {
  constructor(private readonly productsService: ProductsService) {}

  @Post()
  @ApiOperation({ summary: "Create a new product" })
  @ApiBody({ type: CreateProductDto })
  @ApiResponse({
    status: 201,
    description: "Product created successfully",
    type: ProductResponseDto,
  })
  @ApiResponse({
    status: 400,
    description: "Product with this name already exists",
  })
  @ApiResponse({
    status: 404,
    description: "Category not found",
  })
  @UsePipes(new ValidationPipe({ transform: true, whitelist: true }))
  async create(@Body() createProductDto: CreateProductDto) {
    const product = await this.productsService.create(createProductDto);

    return {
      success: true,
      message: "Product created successfully",
      data: { product },
    };
  }

  @Get()
  @ApiOperation({ summary: "Get all products with optional filtering" })
  @ApiQuery({
    name: "categoryId",
    required: false,
    description: "Filter by category ID",
  })
  @ApiQuery({
    name: "minPrice",
    required: false,
    description: "Minimum price filter",
    type: Number,
  })
  @ApiQuery({
    name: "maxPrice",
    required: false,
    description: "Maximum price filter",
    type: Number,
  })
  @ApiQuery({
    name: "search",
    required: false,
    description: "Search in name and description",
  })
  @ApiQuery({
    name: "tags",
    required: false,
    description: "Filter by tags (comma-separated)",
  })
  @ApiResponse({
    status: 200,
    description: "Products retrieved successfully",
    type: [ProductResponseDto],
  })
  async findAll(@Query() query: any) {
    const filter = {
      categoryId: query.categoryId,
      minPrice: query.minPrice ? parseFloat(query.minPrice) : undefined,
      maxPrice: query.maxPrice ? parseFloat(query.maxPrice) : undefined,
      search: query.search,
      tags: query.tags
        ? query.tags.split(",").map((tag: string) => tag.trim())
        : undefined,
    };

    const products = await this.productsService.findAll(filter);

    return {
      success: true,
      message: "Products retrieved successfully",
      data: {
        products,
        count: products.length,
      },
    };
  }

  @Get(":id")
  @ApiOperation({ summary: "Get product by ID" })
  @ApiParam({
    name: "id",
    description: "Product UUID",
    example: "f47ac10b-58cc-4372-a567-0e02b2c3d479",
  })
  @ApiResponse({
    status: 200,
    description: "Product retrieved successfully",
    type: ProductResponseDto,
  })
  @ApiResponse({
    status: 404,
    description: "Product not found",
  })
  async findOne(@Param("id", ParseUUIDPipe) id: string) {
    const product = await this.productsService.findOne(id);

    return {
      success: true,
      message: "Product retrieved successfully",
      data: { product },
    };
  }

  @Put(":id")
  @ApiOperation({ summary: "Update product" })
  @ApiParam({
    name: "id",
    description: "Product UUID",
    example: "f47ac10b-58cc-4372-a567-0e02b2c3d479",
  })
  @ApiBody({ type: UpdateProductDto })
  @ApiResponse({
    status: 200,
    description: "Product updated successfully",
    type: ProductResponseDto,
  })
  @ApiResponse({
    status: 404,
    description: "Product or category not found",
  })
  @ApiResponse({
    status: 400,
    description: "Product name already exists",
  })
  @UsePipes(new ValidationPipe({ transform: true, whitelist: true }))
  async update(
    @Param("id", ParseUUIDPipe) id: string,
    @Body() updateProductDto: UpdateProductDto
  ) {
    const product = await this.productsService.update(id, updateProductDto);

    return {
      success: true,
      message: "Product updated successfully",
      data: { product },
    };
  }

  @Delete(":id")
  @ApiOperation({ summary: "Delete product (soft delete)" })
  @ApiParam({
    name: "id",
    description: "Product UUID",
    example: "f47ac10b-58cc-4372-a567-0e02b2c3d479",
  })
  @ApiResponse({
    status: 200,
    description: "Product deleted successfully",
  })
  @ApiResponse({
    status: 404,
    description: "Product not found",
  })
  async remove(@Param("id", ParseUUIDPipe) id: string) {
    await this.productsService.remove(id);

    return {
      success: true,
      message: "Product deleted successfully",
    };
  }

  @Put(":id/stock")
  @ApiOperation({ summary: "Update product stock" })
  @ApiParam({
    name: "id",
    description: "Product UUID",
    example: "f47ac10b-58cc-4372-a567-0e02b2c3d479",
  })
  @ApiBody({
    schema: {
      type: "object",
      properties: {
        quantity: {
          type: "number",
          description: "Quantity to add/subtract from current stock",
          example: -5,
        },
      },
    },
  })
  @ApiResponse({
    status: 200,
    description: "Stock updated successfully",
    type: ProductResponseDto,
  })
  @ApiResponse({
    status: 400,
    description: "Insufficient stock",
  })
  @ApiResponse({
    status: 404,
    description: "Product not found",
  })
  async updateStock(
    @Param("id", ParseUUIDPipe) id: string,
    @Body() body: { quantity: number }
  ) {
    const product = await this.productsService.updateStock(id, body.quantity);

    return {
      success: true,
      message: "Stock updated successfully",
      data: { product },
    };
  }
}
```

### Step 9: Create Modules

Create `src/categories/categories.module.ts`:

```typescript
import { Module } from "@nestjs/common";
import { TypeOrmModule } from "@nestjs/typeorm";
import { CategoriesController } from "./categories.controller";
import { CategoriesService } from "./categories.service";
import { Category } from "../entities/category.entity";

@Module({
  imports: [TypeOrmModule.forFeature([Category])],
  controllers: [CategoriesController],
  providers: [CategoriesService],
  exports: [CategoriesService],
})
export class CategoriesModule {}
```

Update `src/products/products.module.ts`:

```typescript
import { Module } from "@nestjs/common";
import { TypeOrmModule } from "@nestjs/typeorm";
import { ProductsController } from "./products.controller";
import { ProductsService } from "./products.service";
import { Product } from "../entities/product.entity";
import { Category } from "../entities/category.entity";

@Module({
  imports: [TypeOrmModule.forFeature([Product, Category])],
  controllers: [ProductsController],
  providers: [ProductsService],
  exports: [ProductsService],
})
export class ProductsModule {}
```

### Step 10: Update Main Application Module

Update `src/app.module.ts`:

```typescript
import { Module } from "@nestjs/common";
import { TypeOrmModule } from "@nestjs/typeorm";
import { ConfigModule, ConfigService } from "@nestjs/config";
import { AppController } from "./app.controller";
import { AppService } from "./app.service";
import { ProductsModule } from "./products/products.module";
import { CategoriesModule } from "./categories/categories.module";
import { getDatabaseConfig } from "./config/database.config";

@Module({
  imports: [
    ConfigModule.forRoot({
      isGlobal: true,
      envFilePath: ".env",
    }),
    TypeOrmModule.forRootAsync({
      imports: [ConfigModule],
      useFactory: getDatabaseConfig,
      inject: [ConfigService],
    }),
    ProductsModule,
    CategoriesModule,
  ],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}
```

### Step 11: Setup Swagger Documentation

Update `src/main.ts`:

```typescript
import { NestFactory } from "@nestjs/core";
import { ValidationPipe } from "@nestjs/common";
import { DocumentBuilder, SwaggerModule } from "@nestjs/swagger";
import { ConfigService } from "@nestjs/config";
import { AppModule } from "./app.module";
import { HttpExceptionFilter } from "./filters/http-exception.filter";

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  const configService = app.get(ConfigService);

  // Global validation pipe
  app.useGlobalPipes(
    new ValidationPipe({
      transform: true,
      whitelist: true,
      forbidNonWhitelisted: true,
      transformOptions: {
        enableImplicitConversion: true,
      },
    })
  );

  // Global exception filter
  app.useGlobalFilters(new HttpExceptionFilter());

  // Enable CORS
  app.enableCors();

  // API prefix
  const apiPrefix = configService.get<string>("API_PREFIX") || "api/v1";
  app.setGlobalPrefix(apiPrefix);

  // Swagger configuration
  const config = new DocumentBuilder()
    .setTitle("Product Catalog API")
    .setDescription(
      "A comprehensive product catalog management system built with NestJS, TypeORM, and PostgreSQL"
    )
    .setVersion("1.0")
    .addTag("Products", "Product management operations")
    .addTag("Categories", "Category management operations")
    .addServer(
      `http://localhost:${configService.get("PORT", 3000)}`,
      "Development server"
    )
    .build();

  const document = SwaggerModule.createDocument(app, config);
  SwaggerModule.setup("api", app, document, {
    customSiteTitle: "Product Catalog API Documentation",
    customCss: ".swagger-ui .topbar { display: none }",
    swaggerOptions: {
      persistAuthorization: true,
      docExpansion: "none",
      filter: true,
      showRequestDuration: true,
    },
  });

  const port = configService.get("PORT", 3000);
  await app.listen(port);

  console.log("üöÄ NestJS application is running on http://localhost:" + port);
  console.log(
    "üìö API documentation available at http://localhost:" + port + "/api"
  );
  console.log(
    "üóÉÔ∏è  API endpoints available at http://localhost:" + port + "/" + apiPrefix
  );
  console.log("üêò PostgreSQL running on http://localhost:5432");
  console.log("üìä PgAdmin available at http://localhost:5050");
}
bootstrap();
```

### Step 12: Database Seeding

Create `src/database/seed.ts`:

```typescript
import { NestFactory } from "@nestjs/core";
import { AppModule } from "../app.module";
import { CategoriesService } from "../categories/categories.service";
import { ProductsService } from "../products/products.service";

async function seed() {
  const app = await NestFactory.createApplicationContext(AppModule);

  const categoriesService = app.get(CategoriesService);
  const productsService = app.get(ProductsService);

  try {
    // Create categories
    console.log("Creating categories...");

    const electronicsCategory = await categoriesService.create({
      name: "Electronics",
      description: "Electronic devices and accessories",
      tags: ["gadgets", "technology", "digital"],
    });

    const clothingCategory = await categoriesService.create({
      name: "Clothing",
      description: "Apparel and fashion items",
      tags: ["fashion", "apparel", "wear"],
    });

    const homeCategory = await categoriesService.create({
      name: "Home & Garden",
      description: "Home improvement and garden supplies",
      tags: ["home", "garden", "furniture"],
    });

    console.log("Categories created successfully!");

    // Create products
    console.log("Creating products...");

    const products = [
      {
        name: "iPhone 14 Pro",
        description:
          "Latest iPhone with advanced camera system and A16 Bionic chip",
        price: 999.99,
        categoryId: electronicsCategory.id,
        tags: ["smartphone", "apple", "ios"],
        stock: 50,
        images: [
          "https://example.com/iphone-1.jpg",
          "https://example.com/iphone-2.jpg",
        ],
      },
      {
        name: "Samsung Galaxy S23",
        description:
          "Premium Android smartphone with exceptional camera quality",
        price: 849.99,
        categoryId: electronicsCategory.id,
        tags: ["smartphone", "samsung", "android"],
        stock: 75,
        images: ["https://example.com/galaxy-1.jpg"],
      },
      {
        name: 'MacBook Pro 14"',
        description:
          "Professional laptop with M2 Pro chip for demanding workflows",
        price: 1999.99,
        categoryId: electronicsCategory.id,
        tags: ["laptop", "apple", "professional"],
        stock: 25,
        images: ["https://example.com/macbook-1.jpg"],
      },
      {
        name: "Classic T-Shirt",
        description: "Comfortable cotton t-shirt in various colors",
        price: 19.99,
        categoryId: clothingCategory.id,
        tags: ["t-shirt", "casual", "cotton"],
        stock: 200,
        images: ["https://example.com/tshirt-1.jpg"],
      },
      {
        name: "Denim Jeans",
        description: "Premium denim jeans with perfect fit",
        price: 79.99,
        categoryId: clothingCategory.id,
        tags: ["jeans", "denim", "casual"],
        stock: 150,
        images: ["https://example.com/jeans-1.jpg"],
      },
      {
        name: "Office Chair",
        description: "Ergonomic office chair with lumbar support",
        price: 299.99,
        categoryId: homeCategory.id,
        tags: ["chair", "office", "furniture"],
        stock: 30,
        images: ["https://example.com/chair-1.jpg"],
      },
    ];

    for (const productData of products) {
      await productsService.create(productData);
    }

    console.log("Products created successfully!");
    console.log("Seeding completed!");
  } catch (error) {
    console.error("Error during seeding:", error);
  } finally {
    await app.close();
  }
}

seed();
```

Add seed script to `package.json`:

```json
{
  "scripts": {
    "seed": "ts-node src/database/seed.ts"
  }
}
```

### Step 13: Testing the Enhanced Application

Start the application:

```bash
# Make sure PostgreSQL is running
docker-compose up -d

# Start the application
npm run start:dev

# (Optional) Run seeding
npm run seed
```

Test the new features:

```bash
# Create a category
curl -X POST http://localhost:3000/api/v1/categories \
  -H "Content-Type: application/json" \
  -d '{
    "name": "Books",
    "description": "Books and educational materials",
    "tags": ["education", "reading", "books"]
  }'

# Get all categories
curl http://localhost:3000/api/v1/categories

# Create a product with the new category
curl -X POST http://localhost:3000/api/v1/products \
  -H "Content-Type: application/json" \
  -d '{
    "name": "Programming Book",
    "description": "Comprehensive guide to NestJS development",
    "price": 49.99,
    "categoryId": "YOUR_CATEGORY_ID_HERE",
    "tags": ["programming", "nestjs", "typescript"],
    "stock": 100,
    "images": ["https://example.com/book.jpg"]
  }'

# Get products with filtering
curl "http://localhost:3000/api/v1/products?categoryId=YOUR_CATEGORY_ID&minPrice=20&maxPrice=100"
```

Access the Swagger documentation:

- Open `http://localhost:3000/api` in your browser
- Explore the interactive API documentation
- Test endpoints directly from the Swagger UI

Access pgAdmin:

- Open `http://localhost:5050` in your browser
- Login with email: `admin@example.com`, password: `admin123`
- Connect to the PostgreSQL database using the credentials from `.env`

## Key Features Implemented

1. **PostgreSQL Integration**: Full database integration with TypeORM
2. **Entity Relationships**: Category-Product relationship with foreign keys
3. **DTOs with Validation**: Request and response DTOs with class-validator
4. **Swagger Documentation**: Automatic API documentation with examples
5. **Environment Configuration**: Configurable settings for different environments
6. **Database Seeding**: Sample data creation for testing
7. **Advanced Querying**: Filtering, searching, and sorting capabilities
8. **Error Handling**: Comprehensive exception handling with meaningful messages
9. **UUIDs**: Using UUIDs for entity identifiers
10. **Soft Deletes**: Implementing soft delete pattern for products

This enhanced application demonstrates how NestJS provides excellent tooling for building enterprise-grade APIs with minimal configuration while maintaining type safety and excellent developer experience.

---

## References and Resources

### NestJS with TypeORM

- [NestJS Database Guide](https://docs.nestjs.com/techniques/database) - Official database integration guide
- [TypeORM Documentation](https://typeorm.io/) - Complete TypeORM documentation
- [NestJS TypeORM Integration](https://docs.nestjs.com/recipes/sql-typeorm) - Specific TypeORM setup guide

### Swagger/OpenAPI Documentation

- [NestJS Swagger](https://docs.nestjs.com/openapi/introduction) - Official Swagger integration
- [OpenAPI Specification](https://swagger.io/specification/) - OpenAPI standard documentation
- [Swagger UI](https://swagger.io/tools/swagger-ui/) - Interactive API documentation

### Validation and DTOs

- [NestJS Validation](https://docs.nestjs.com/techniques/validation) - Built-in validation techniques
- [Class Validator](https://github.com/typestack/class-validator) - Decorator-based validation
- [Class Transformer](https://github.com/typestack/class-transformer) - Object transformation

### PostgreSQL and Database Management

- [PostgreSQL Documentation](https://www.postgresql.org/docs/) - Official PostgreSQL docs
- [pgAdmin Documentation](https://www.pgadmin.org/docs/) - Database administration tool
- [Docker PostgreSQL](https://hub.docker.com/_/postgres) - Official PostgreSQL Docker image

### Configuration and Environment

- [NestJS Configuration](https://docs.nestjs.com/techniques/configuration) - Environment configuration
- [TypeORM Configuration](https://typeorm.io/data-source-options) - Database configuration options
