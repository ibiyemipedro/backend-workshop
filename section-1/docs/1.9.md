# Basic NestJS Application

## Overview

NestJS is a progressive Node.js framework that builds upon Express.js, providing a more opinionated, TypeScript-first approach to building scalable server-side applications. In this exercise, we'll create a simple NestJS application to understand its core concepts including decorators, dependency injection, modules, and HTTP exceptions.

## Learning Objectives

- Set up a basic NestJS application
- Understand NestJS decorators (@Controller, @Injectable, @Get, etc.)
- Implement dependency injection
- Work with modules and providers
- Handle HTTP exceptions
- Use built-in pipes and guards
- Create a simple CRUD API

## NestJS vs Express.js

### Architecture Comparison

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    EXPRESS.JS                           â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚ â”‚   Routes    â”‚ â”‚ Controllers â”‚ â”‚     Services        â”‚â”‚
â”‚ â”‚             â”‚ â”‚             â”‚ â”‚                     â”‚â”‚
â”‚ â”‚ Flexible    â”‚ â”‚ Functions   â”‚ â”‚ Manual DI           â”‚â”‚
â”‚ â”‚ Manual      â”‚ â”‚ Middleware  â”‚ â”‚ Custom Structure    â”‚â”‚
â”‚ â”‚ Setup       â”‚ â”‚ Chain       â”‚ â”‚                     â”‚â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     NESTJS                              â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚ â”‚   Modules   â”‚ â”‚ Controllers â”‚ â”‚     Providers       â”‚â”‚
â”‚ â”‚             â”‚ â”‚             â”‚ â”‚                     â”‚â”‚
â”‚ â”‚ @Module()   â”‚ â”‚ @Controller â”‚ â”‚ @Injectable()       â”‚â”‚
â”‚ â”‚ Decorators  â”‚ â”‚ Decorators  â”‚ â”‚ Auto DI             â”‚â”‚
â”‚ â”‚ Organized   â”‚ â”‚ Classes     â”‚ â”‚ Services/Guards     â”‚â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Key Differences

| Feature                  | Express.js            | NestJS                  |
| ------------------------ | --------------------- | ----------------------- |
| **Language**             | JavaScript/TypeScript | TypeScript-first        |
| **Architecture**         | Minimalist, flexible  | Opinionated, structured |
| **Dependency Injection** | Manual                | Built-in, automatic     |
| **Decorators**           | None                  | Extensive use           |
| **Learning Curve**       | Easy                  | Moderate                |
| **Enterprise Features**  | Add manually          | Built-in                |

## Exercise: Building a Product Catalog API

Let's create a simple product catalog API using NestJS to demonstrate its core concepts.

### Step 1: Project Setup

Create a new NestJS project:

```bash
# Install NestJS CLI globally
npm install -g @nestjs/cli

# Create new project
nest new nestjs-product-catalog
cd nestjs-product-catalog

# Install additional dependencies
npm install class-validator class-transformer
```

The NestJS CLI creates this structure:

```
nestjs-product-catalog/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ app.controller.ts
â”‚   â”œâ”€â”€ app.controller.spec.ts
â”‚   â”œâ”€â”€ app.module.ts
â”‚   â”œâ”€â”€ app.service.ts
â”‚   â””â”€â”€ main.ts
â”œâ”€â”€ test/
â”œâ”€â”€ package.json
â”œâ”€â”€ nest-cli.json
â””â”€â”€ tsconfig.json
```

### Step 2: Understanding NestJS Core Concepts

Let's examine the generated files to understand NestJS structure:

**`src/main.ts` - Application Bootstrap:**

```typescript
import { NestFactory } from "@nestjs/core";
import { AppModule } from "./app.module";

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  await app.listen(3000);
}
bootstrap();
```

**`src/app.module.ts` - Root Module:**

```typescript
import { Module } from "@nestjs/common";
import { AppController } from "./app.controller";
import { AppService } from "./app.service";

@Module({
  imports: [], // Other modules
  controllers: [AppController], // Controllers in this module
  providers: [AppService], // Services/providers in this module
  exports: [], // Services to export for other modules
})
export class AppModule {}
```

**`src/app.controller.ts` - Controller:**

```typescript
import { Controller, Get } from "@nestjs/common";
import { AppService } from "./app.service";

@Controller() // Decorator - defines this as a controller
export class AppController {
  constructor(private readonly appService: AppService) {} // Dependency injection

  @Get() // Decorator - handles GET requests to root path
  getHello(): string {
    return this.appService.getHello();
  }
}
```

**`src/app.service.ts` - Service:**

```typescript
import { Injectable } from "@nestjs/common";

@Injectable() // Decorator - makes this class injectable
export class AppService {
  getHello(): string {
    return "Hello World!";
  }
}
```

### Step 3: Creating DTOs (Data Transfer Objects)

Create `src/dto/create-product.dto.ts`:

```typescript
import {
  IsString,
  IsNumber,
  IsOptional,
  IsArray,
  Min,
  MaxLength,
} from "class-validator";

export class CreateProductDto {
  @IsString()
  @MaxLength(100, { message: "Name must not exceed 100 characters" })
  name: string;

  @IsString()
  @MaxLength(500, { message: "Description must not exceed 500 characters" })
  description: string;

  @IsNumber(
    { maxDecimalPlaces: 2 },
    { message: "Price must be a valid number with up to 2 decimal places" }
  )
  @Min(0, { message: "Price must be a positive number" })
  price: number;

  @IsString()
  @MaxLength(50, { message: "Category must not exceed 50 characters" })
  category: string;

  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  tags?: string[];

  @IsOptional()
  @IsNumber({}, { message: "Stock quantity must be a valid number" })
  @Min(0, { message: "Stock quantity must be non-negative" })
  stock?: number;
}
```

Create `src/dto/update-product.dto.ts`:

```typescript
import {
  IsString,
  IsNumber,
  IsOptional,
  IsArray,
  Min,
  MaxLength,
} from "class-validator";

export class UpdateProductDto {
  @IsOptional()
  @IsString()
  @MaxLength(100, { message: "Name must not exceed 100 characters" })
  name?: string;

  @IsOptional()
  @IsString()
  @MaxLength(500, { message: "Description must not exceed 500 characters" })
  description?: string;

  @IsOptional()
  @IsNumber(
    { maxDecimalPlaces: 2 },
    { message: "Price must be a valid number with up to 2 decimal places" }
  )
  @Min(0, { message: "Price must be a positive number" })
  price?: number;

  @IsOptional()
  @IsString()
  @MaxLength(50, { message: "Category must not exceed 50 characters" })
  category?: string;

  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  tags?: string[];

  @IsOptional()
  @IsNumber({}, { message: "Stock quantity must be a valid number" })
  @Min(0, { message: "Stock quantity must be non-negative" })
  stock?: number;
}
```

### Step 4: Creating Interfaces and Entities

Create `src/interfaces/product.interface.ts`:

```typescript
export interface Product {
  id: string;
  name: string;
  description: string;
  price: number;
  category: string;
  tags: string[];
  stock: number;
  createdAt: Date;
  updatedAt: Date;
  isActive: boolean;
}

export interface ProductFilter {
  category?: string;
  minPrice?: number;
  maxPrice?: number;
  search?: string;
  tags?: string[];
}
```

### Step 5: Creating the Product Service

Create `src/products/products.service.ts`:

```typescript
import {
  Injectable,
  NotFoundException,
  BadRequestException,
} from "@nestjs/common";
import { Product, ProductFilter } from "../interfaces/product.interface";
import { CreateProductDto } from "../dto/create-product.dto";
import { UpdateProductDto } from "../dto/update-product.dto";
import { v4 as uuidv4 } from "uuid";

@Injectable()
export class ProductsService {
  private products: Product[] = [
    {
      id: "1",
      name: "Laptop Computer",
      description: "High-performance laptop for professional use",
      price: 1299.99,
      category: "electronics",
      tags: ["computer", "laptop", "work"],
      stock: 15,
      createdAt: new Date("2023-01-01"),
      updatedAt: new Date("2023-01-01"),
      isActive: true,
    },
    {
      id: "2",
      name: "Wireless Headphones",
      description: "Premium noise-cancelling wireless headphones",
      price: 299.99,
      category: "electronics",
      tags: ["audio", "wireless", "headphones"],
      stock: 25,
      createdAt: new Date("2023-01-02"),
      updatedAt: new Date("2023-01-02"),
      isActive: true,
    },
    {
      id: "3",
      name: "Coffee Mug",
      description: "Ceramic coffee mug with company logo",
      price: 12.99,
      category: "office",
      tags: ["mug", "coffee", "ceramic"],
      stock: 100,
      createdAt: new Date("2023-01-03"),
      updatedAt: new Date("2023-01-03"),
      isActive: true,
    },
  ];

  findAll(filter?: ProductFilter): Product[] {
    let filteredProducts = this.products.filter((product) => product.isActive);

    if (filter) {
      if (filter.category) {
        filteredProducts = filteredProducts.filter(
          (product) =>
            product.category.toLowerCase() === filter.category!.toLowerCase()
        );
      }

      if (filter.minPrice !== undefined) {
        filteredProducts = filteredProducts.filter(
          (product) => product.price >= filter.minPrice!
        );
      }

      if (filter.maxPrice !== undefined) {
        filteredProducts = filteredProducts.filter(
          (product) => product.price <= filter.maxPrice!
        );
      }

      if (filter.search) {
        const searchLower = filter.search.toLowerCase();
        filteredProducts = filteredProducts.filter(
          (product) =>
            product.name.toLowerCase().includes(searchLower) ||
            product.description.toLowerCase().includes(searchLower) ||
            product.tags.some((tag) => tag.toLowerCase().includes(searchLower))
        );
      }

      if (filter.tags && filter.tags.length > 0) {
        filteredProducts = filteredProducts.filter((product) =>
          filter.tags!.some((tag) => product.tags.includes(tag))
        );
      }
    }

    return filteredProducts;
  }

  findOne(id: string): Product {
    const product = this.products.find((p) => p.id === id && p.isActive);
    if (!product) {
      throw new NotFoundException(`Product with ID ${id} not found`);
    }
    return product;
  }

  create(createProductDto: CreateProductDto): Product {
    // Check if product name already exists
    const existingProduct = this.products.find(
      (p) =>
        p.name.toLowerCase() === createProductDto.name.toLowerCase() &&
        p.isActive
    );

    if (existingProduct) {
      throw new BadRequestException(
        `Product with name "${createProductDto.name}" already exists`
      );
    }

    const newProduct: Product = {
      id: uuidv4(),
      name: createProductDto.name,
      description: createProductDto.description,
      price: createProductDto.price,
      category: createProductDto.category,
      tags: createProductDto.tags || [],
      stock: createProductDto.stock || 0,
      createdAt: new Date(),
      updatedAt: new Date(),
      isActive: true,
    };

    this.products.push(newProduct);
    return newProduct;
  }

  update(id: string, updateProductDto: UpdateProductDto): Product {
    const productIndex = this.products.findIndex(
      (p) => p.id === id && p.isActive
    );

    if (productIndex === -1) {
      throw new NotFoundException(`Product with ID ${id} not found`);
    }

    // Check for name conflicts if name is being updated
    if (updateProductDto.name) {
      const existingProduct = this.products.find(
        (p) =>
          p.name.toLowerCase() === updateProductDto.name!.toLowerCase() &&
          p.id !== id &&
          p.isActive
      );

      if (existingProduct) {
        throw new BadRequestException(
          `Product with name "${updateProductDto.name}" already exists`
        );
      }
    }

    const updatedProduct: Product = {
      ...this.products[productIndex],
      ...updateProductDto,
      updatedAt: new Date(),
    };

    this.products[productIndex] = updatedProduct;
    return updatedProduct;
  }

  remove(id: string): void {
    const productIndex = this.products.findIndex(
      (p) => p.id === id && p.isActive
    );

    if (productIndex === -1) {
      throw new NotFoundException(`Product with ID ${id} not found`);
    }

    // Soft delete
    this.products[productIndex].isActive = false;
    this.products[productIndex].updatedAt = new Date();
  }

  // Additional business methods
  updateStock(id: string, quantity: number): Product {
    const product = this.findOne(id);

    if (product.stock + quantity < 0) {
      throw new BadRequestException("Insufficient stock");
    }

    const productIndex = this.products.findIndex((p) => p.id === id);
    this.products[productIndex].stock += quantity;
    this.products[productIndex].updatedAt = new Date();

    return this.products[productIndex];
  }

  getCategories(): string[] {
    const categories = this.products
      .filter((p) => p.isActive)
      .map((p) => p.category);

    return Array.from(new Set(categories)).sort();
  }

  getStatistics(): {
    totalProducts: number;
    totalValue: number;
    categories: any[];
  } {
    const activeProducts = this.products.filter((p) => p.isActive);

    const totalProducts = activeProducts.length;
    const totalValue = activeProducts.reduce(
      (sum, product) => sum + product.price * product.stock,
      0
    );

    const categoryStats = activeProducts.reduce((acc, product) => {
      if (!acc[product.category]) {
        acc[product.category] = { count: 0, totalValue: 0 };
      }
      acc[product.category].count++;
      acc[product.category].totalValue += product.price * product.stock;
      return acc;
    }, {} as any);

    const categories = Object.entries(categoryStats).map(([name, stats]) => ({
      name,
      ...stats,
    }));

    return { totalProducts, totalValue, categories };
  }
}
```

### Step 6: Creating the Product Controller

Create `src/products/products.controller.ts`:

```typescript
import {
  Controller,
  Get,
  Post,
  Body,
  Param,
  Put,
  Delete,
  Query,
  HttpStatus,
  HttpException,
  UsePipes,
  ValidationPipe,
  ParseUUIDPipe,
} from "@nestjs/common";
import { ProductsService } from "./products.service";
import { CreateProductDto } from "../dto/create-product.dto";
import { UpdateProductDto } from "../dto/update-product.dto";
import { ProductFilter } from "../interfaces/product.interface";

@Controller("products") // Base route: /products
export class ProductsController {
  constructor(private readonly productsService: ProductsService) {}

  @Get()
  findAll(@Query() query: any) {
    try {
      const filter: ProductFilter = {
        category: query.category,
        minPrice: query.minPrice ? parseFloat(query.minPrice) : undefined,
        maxPrice: query.maxPrice ? parseFloat(query.maxPrice) : undefined,
        search: query.search,
        tags: query.tags
          ? Array.isArray(query.tags)
            ? query.tags
            : [query.tags]
          : undefined,
      };

      const products = this.productsService.findAll(filter);

      return {
        success: true,
        message: "Products retrieved successfully",
        data: {
          products,
          count: products.length,
        },
      };
    } catch (error) {
      throw new HttpException(
        "Error retrieving products",
        HttpStatus.INTERNAL_SERVER_ERROR
      );
    }
  }

  @Get("categories")
  getCategories() {
    try {
      const categories = this.productsService.getCategories();

      return {
        success: true,
        message: "Categories retrieved successfully",
        data: { categories },
      };
    } catch (error) {
      throw new HttpException(
        "Error retrieving categories",
        HttpStatus.INTERNAL_SERVER_ERROR
      );
    }
  }

  @Get("statistics")
  getStatistics() {
    try {
      const stats = this.productsService.getStatistics();

      return {
        success: true,
        message: "Statistics retrieved successfully",
        data: stats,
      };
    } catch (error) {
      throw new HttpException(
        "Error retrieving statistics",
        HttpStatus.INTERNAL_SERVER_ERROR
      );
    }
  }

  @Get(":id")
  findOne(@Param("id") id: string) {
    try {
      const product = this.productsService.findOne(id);

      return {
        success: true,
        message: "Product retrieved successfully",
        data: { product },
      };
    } catch (error) {
      // NestJS automatically converts known exceptions
      throw error;
    }
  }

  @Post()
  @UsePipes(new ValidationPipe({ transform: true, whitelist: true }))
  create(@Body() createProductDto: CreateProductDto) {
    try {
      const product = this.productsService.create(createProductDto);

      return {
        success: true,
        message: "Product created successfully",
        data: { product },
      };
    } catch (error) {
      throw error;
    }
  }

  @Put(":id")
  @UsePipes(new ValidationPipe({ transform: true, whitelist: true }))
  update(@Param("id") id: string, @Body() updateProductDto: UpdateProductDto) {
    try {
      const product = this.productsService.update(id, updateProductDto);

      return {
        success: true,
        message: "Product updated successfully",
        data: { product },
      };
    } catch (error) {
      throw error;
    }
  }

  @Delete(":id")
  remove(@Param("id") id: string) {
    try {
      this.productsService.remove(id);

      return {
        success: true,
        message: "Product deleted successfully",
      };
    } catch (error) {
      throw error;
    }
  }

  @Put(":id/stock")
  @UsePipes(new ValidationPipe({ transform: true }))
  updateStock(@Param("id") id: string, @Body() body: { quantity: number }) {
    try {
      if (typeof body.quantity !== "number") {
        throw new HttpException(
          "Quantity must be a number",
          HttpStatus.BAD_REQUEST
        );
      }

      const product = this.productsService.updateStock(id, body.quantity);

      return {
        success: true,
        message: "Stock updated successfully",
        data: { product },
      };
    } catch (error) {
      throw error;
    }
  }
}
```

### Step 7: Creating the Products Module

Create `src/products/products.module.ts`:

```typescript
import { Module } from "@nestjs/common";
import { ProductsController } from "./products.controller";
import { ProductsService } from "./products.service";

@Module({
  controllers: [ProductsController],
  providers: [ProductsService],
  exports: [ProductsService], // Export service for use in other modules
})
export class ProductsModule {}
```

### Step 8: Adding Global Pipes and Exception Filters

Update `src/main.ts`:

```typescript
import { NestFactory } from "@nestjs/core";
import { AppModule } from "./app.module";
import { ValidationPipe } from "@nestjs/common";
import { HttpExceptionFilter } from "./filters/http-exception.filter";

async function bootstrap() {
  const app = await NestFactory.create(AppModule);

  // Global validation pipe
  app.useGlobalPipes(
    new ValidationPipe({
      transform: true, // Automatically transform payloads
      whitelist: true, // Strip properties not in DTO
      forbidNonWhitelisted: true, // Throw error for unknown properties
      transformOptions: {
        enableImplicitConversion: true, // Convert string to number automatically
      },
    })
  );

  // Global exception filter
  app.useGlobalFilters(new HttpExceptionFilter());

  // Enable CORS
  app.enableCors();

  // API prefix
  app.setGlobalPrefix("api/v1");

  await app.listen(3000);
  console.log("ðŸš€ NestJS application is running on http://localhost:3000");
  console.log("ðŸ“š API endpoints available at http://localhost:3000/api/v1");
}
bootstrap();
```

Create `src/filters/http-exception.filter.ts`:

```typescript
import {
  ExceptionFilter,
  Catch,
  ArgumentsHost,
  HttpException,
  HttpStatus,
} from "@nestjs/common";
import { Request, Response } from "express";

@Catch()
export class HttpExceptionFilter implements ExceptionFilter {
  catch(exception: unknown, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse<Response>();
    const request = ctx.getRequest<Request>();

    let status = HttpStatus.INTERNAL_SERVER_ERROR;
    let message = "Internal server error";
    let error = "Internal Server Error";

    if (exception instanceof HttpException) {
      status = exception.getStatus();
      const exceptionResponse = exception.getResponse();

      if (typeof exceptionResponse === "object" && exceptionResponse !== null) {
        message = (exceptionResponse as any).message || exception.message;
        error = (exceptionResponse as any).error || exception.message;

        // Handle validation errors
        if (Array.isArray(message)) {
          message = message.join(", ");
        }
      } else {
        message = exception.message;
      }
    }

    const errorResponse = {
      success: false,
      statusCode: status,
      message,
      error,
      timestamp: new Date().toISOString(),
      path: request.url,
      method: request.method,
    };

    console.error("Exception caught:", {
      ...errorResponse,
      stack: exception instanceof Error ? exception.stack : "No stack trace",
    });

    response.status(status).json(errorResponse);
  }
}
```

### Step 9: Update App Module

Update `src/app.module.ts`:

```typescript
import { Module } from "@nestjs/common";
import { AppController } from "./app.controller";
import { AppService } from "./app.service";
import { ProductsModule } from "./products/products.module";

@Module({
  imports: [ProductsModule],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}
```

Update `src/app.controller.ts` to provide API information:

```typescript
import { Controller, Get } from "@nestjs/common";
import { AppService } from "./app.service";

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Get()
  getApiInfo() {
    return {
      message: "NestJS Product Catalog API",
      version: "1.0.0",
      timestamp: new Date().toISOString(),
      endpoints: {
        products: {
          "GET /api/v1/products": "Get all products with optional filtering",
          "GET /api/v1/products/:id": "Get product by ID",
          "POST /api/v1/products": "Create new product",
          "PUT /api/v1/products/:id": "Update product",
          "DELETE /api/v1/products/:id": "Delete product",
          "PUT /api/v1/products/:id/stock": "Update product stock",
        },
        utility: {
          "GET /api/v1/products/categories": "Get all product categories",
          "GET /api/v1/products/statistics": "Get product statistics",
        },
      },
    };
  }

  @Get("health")
  getHealth() {
    return {
      status: "OK",
      timestamp: new Date().toISOString(),
      uptime: process.uptime(),
    };
  }
}
```

### Step 10: Testing the NestJS Application

Start the application:

```bash
npm run start:dev
```

Test the endpoints:

```bash
# Get all products
curl http://localhost:3000/api/v1/products

# Get products with filters
curl "http://localhost:3000/api/v1/products?category=electronics&minPrice=100&maxPrice=1500"

# Search products
curl "http://localhost:3000/api/v1/products?search=laptop"

# Get specific product
curl http://localhost:3000/api/v1/products/1

# Create new product
curl -X POST http://localhost:3000/api/v1/products \
  -H "Content-Type: application/json" \
  -d '{
    "name": "Smartphone",
    "description": "Latest model smartphone with advanced features",
    "price": 899.99,
    "category": "electronics",
    "tags": ["phone", "mobile", "smartphone"],
    "stock": 50
  }'

# Update product
curl -X PUT http://localhost:3000/api/v1/products/1 \
  -H "Content-Type: application/json" \
  -d '{
    "price": 1199.99,
    "stock": 20
  }'

# Update stock
curl -X PUT http://localhost:3000/api/v1/products/1/stock \
  -H "Content-Type: application/json" \
  -d '{"quantity": -5}'

# Get categories
curl http://localhost:3000/api/v1/products/categories

# Get statistics
curl http://localhost:3000/api/v1/products/statistics

# Test validation (should fail)
curl -X POST http://localhost:3000/api/v1/products \
  -H "Content-Type: application/json" \
  -d '{
    "name": "",
    "price": -10
  }'
```

## Key NestJS Concepts Demonstrated

### 1. **Decorators**

#### Class Decorators

```typescript
@Controller('products')  // Defines controller with route prefix
@Injectable()           // Makes class injectable as dependency
@Module({...})          // Defines a module
```

#### Method Decorators

```typescript
@Get()                  // HTTP GET method
@Post()                 // HTTP POST method
@Put(':id')            // HTTP PUT with parameter
@UsePipes(ValidationPipe) // Apply pipe to method
```

#### Parameter Decorators

```typescript
@Body() createDto: CreateDto     // Extract request body
@Param('id') id: string         // Extract route parameter
@Query() query: any             // Extract query parameters
```

### 2. **Dependency Injection**

```typescript
// Automatic injection in constructor
constructor(private readonly productsService: ProductsService) {}
```

### 3. **Validation with Pipes**

```typescript
// Built-in validation using class-validator
@IsString()
@MaxLength(100)
name: string;

// Global validation pipe
app.useGlobalPipes(new ValidationPipe());
```

### 4. **Exception Handling**

```typescript
// Built-in HTTP exceptions
throw new NotFoundException(`Product with ID ${id} not found`);
throw new BadRequestException('Invalid data');

// Custom exception filter
@Catch()
export class HttpExceptionFilter implements ExceptionFilter
```

### 5. **Modules and Organization**

```typescript
@Module({
  imports: [],      // Other modules to import
  controllers: [],  // Controllers in this module
  providers: [],    // Services and providers
  exports: []       // Services to export
})
```

## NestJS Benefits Demonstrated

1. **Type Safety**: Full TypeScript support with decorators
2. **Automatic Validation**: Built-in validation with class-validator
3. **Dependency Injection**: Automatic and clean DI container
4. **Exception Handling**: Built-in HTTP exceptions and filters
5. **Modular Architecture**: Clear separation with modules
6. **Decorator Pattern**: Clean, readable code with decorators
7. **Enterprise Ready**: Built-in features for scalable applications

This NestJS application demonstrates how the framework provides a more structured, opinionated approach to building Node.js applications while maintaining flexibility and performance.

---

## References and Resources

### NestJS Documentation

- [NestJS Official Documentation](https://docs.nestjs.com/)
- [NestJS First Steps](https://docs.nestjs.com/first-steps)
- [NestJS Controllers](https://docs.nestjs.com/controllers)
- [NestJS Providers](https://docs.nestjs.com/providers)
- [NestJS Modules](https://docs.nestjs.com/modules)

### TypeScript and Decorators

- [TypeScript Decorators](https://www.typescriptlang.org/docs/handbook/decorators.html)
- [Class Validator Documentation](https://github.com/typestack/class-validator)
- [Class Transformer Documentation](https://github.com/typestack/class-transformer)

### Advanced NestJS Features

- [NestJS Pipes](https://docs.nestjs.com/pipes)
- [NestJS Guards](https://docs.nestjs.com/guards)
- [NestJS Exception Filters](https://docs.nestjs.com/exception-filters)
- [NestJS Interceptors](https://docs.nestjs.com/interceptors)

### Architecture and Best Practices

- [NestJS Architecture](https://docs.nestjs.com/fundamentals/application-lifecycle)
- [NestJS Testing](https://docs.nestjs.com/fundamentals/testing)
- [Enterprise Node.js with NestJS](https://trilon.io/blog/nestjs-enterprise-nodejs)
