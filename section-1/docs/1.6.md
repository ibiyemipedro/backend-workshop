# Models and Database Operations with MongoDB & Mongoose

## Overview

In this exercise, we'll add a database layer to our Express application using MongoDB and Mongoose ORM. We'll learn how to create models, implement CRUD operations, and integrate database operations into our repository pattern.

## Learning Objectives

- Set up MongoDB with Docker
- Understand Mongoose ODM (Object Document Mapper)
- Create Mongoose models and schemas
- Implement repository pattern with database operations
- Perform CRUD operations with proper error handling
- Work with database relationships and validation

## MongoDB vs SQL Databases

### Document-Oriented vs Relational

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    SQL Database                         â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚ â”‚   Users     â”‚ â”‚   Posts     â”‚ â”‚     Comments        â”‚â”‚
â”‚ â”‚   Table     â”‚ â”‚   Table     â”‚ â”‚      Table          â”‚â”‚
â”‚ â”‚             â”‚ â”‚             â”‚ â”‚                     â”‚â”‚
â”‚ â”‚ id â”‚ name   â”‚ â”‚ id â”‚ title  â”‚ â”‚ id â”‚ content â”‚ user â”‚â”‚
â”‚ â”‚ 1  â”‚ John   â”‚ â”‚ 1  â”‚ Post1  â”‚ â”‚ 1  â”‚ Great!  â”‚  1  â”‚â”‚
â”‚ â”‚ 2  â”‚ Jane   â”‚ â”‚ 2  â”‚ Post2  â”‚ â”‚ 2  â”‚ Nice    â”‚  2  â”‚â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 MongoDB Database                        â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚                 Users Collection                    â”‚ â”‚
â”‚ â”‚ {                                                   â”‚ â”‚
â”‚ â”‚   _id: ObjectId("..."),                            â”‚ â”‚
â”‚ â”‚   name: "John",                                     â”‚ â”‚
â”‚ â”‚   email: "john@example.com",                       â”‚ â”‚
â”‚ â”‚   posts: [                                          â”‚ â”‚
â”‚ â”‚     { title: "Post1", content: "..." },           â”‚ â”‚
â”‚ â”‚     { title: "Post2", content: "..." }            â”‚ â”‚
â”‚ â”‚   ],                                                â”‚ â”‚
â”‚ â”‚   comments: [                                       â”‚ â”‚
â”‚ â”‚     { content: "Great!", postId: "..." }          â”‚ â”‚
â”‚ â”‚   ]                                                 â”‚ â”‚
â”‚ â”‚ }                                                   â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Exercise: User Management with MongoDB

Let's rebuild our user management system with a real database backend.

### Step 1: Environment Setup

First, install the required dependencies:

```bash
npm install mongoose bcryptjs
npm install -D @types/mongoose
```

Create a `docker-compose.yml` for MongoDB:

```yaml
version: "3.8"
services:
  mongodb:
    image: mongo:6.0
    container_name: express_mongodb
    restart: unless-stopped
    ports:
      - "27017:27017"
    environment:
      MONGO_INITDB_ROOT_USERNAME: admin
      MONGO_INITDB_ROOT_PASSWORD: password123
      MONGO_INITDB_DATABASE: express_app
    volumes:
      - mongodb_data:/data/db
      - ./mongo-init:/docker-entrypoint-initdb.d
    networks:
      - express_network

  mongo-express:
    image: mongo-express:1.0.0-alpha
    container_name: express_mongo_ui
    restart: unless-stopped
    ports:
      - "8081:8081"
    environment:
      ME_CONFIG_MONGODB_ADMINUSERNAME: admin
      ME_CONFIG_MONGODB_ADMINPASSWORD: password123
      ME_CONFIG_MONGODB_SERVER: mongodb
      ME_CONFIG_MONGODB_PORT: 27017
      ME_CONFIG_BASICAUTH_USERNAME: admin
      ME_CONFIG_BASICAUTH_PASSWORD: admin
    depends_on:
      - mongodb
    networks:
      - express_network

volumes:
  mongodb_data:

networks:
  express_network:
    driver: bridge
```

Update `.env` file:

```env
NODE_ENV=development
PORT=3000
JWT_SECRET=your_jwt_secret_key_here
JWT_EXPIRES_IN=7d
LOG_LEVEL=info

# MongoDB Configuration
MONGODB_URI=mongodb://admin:password123@localhost:27017/express_app?authSource=admin
MONGODB_DB_NAME=express_app
```

### Step 2: Database Configuration

Create `src/config/database.ts`:

```typescript
import mongoose from "mongoose";
import { logger } from "../utils/logger.util";

export class DatabaseConfig {
  private static instance: DatabaseConfig;
  private isConnected: boolean = false;

  private constructor() {}

  static getInstance(): DatabaseConfig {
    if (!DatabaseConfig.instance) {
      DatabaseConfig.instance = new DatabaseConfig();
    }
    return DatabaseConfig.instance;
  }

  async connect(): Promise<void> {
    if (this.isConnected) {
      logger.info("Database already connected");
      return;
    }

    try {
      const mongoUri = process.env.MONGODB_URI!;

      await mongoose.connect(mongoUri, {
        maxPoolSize: 10, // Maintain up to 10 socket connections
        serverSelectionTimeoutMS: 5000, // Keep trying to send operations for 5 seconds
        socketTimeoutMS: 45000, // Close sockets after 45 seconds of inactivity
        bufferCommands: false, // Disable mongoose buffering
      });

      this.isConnected = true;
      logger.info("Connected to MongoDB successfully");

      // Handle connection events
      mongoose.connection.on("error", (error) => {
        logger.error("MongoDB connection error:", error);
      });

      mongoose.connection.on("disconnected", () => {
        logger.warn("MongoDB disconnected");
        this.isConnected = false;
      });

      mongoose.connection.on("reconnected", () => {
        logger.info("MongoDB reconnected");
        this.isConnected = true;
      });
    } catch (error) {
      logger.error("Failed to connect to MongoDB:", error);
      process.exit(1);
    }
  }

  async disconnect(): Promise<void> {
    if (!this.isConnected) {
      logger.info("Database not connected");
      return;
    }

    try {
      await mongoose.disconnect();
      this.isConnected = false;
      logger.info("Disconnected from MongoDB");
    } catch (error) {
      logger.error("Error disconnecting from MongoDB:", error);
    }
  }

  getConnectionStatus(): boolean {
    return this.isConnected;
  }
}

export const dbConfig = DatabaseConfig.getInstance();
```

### Step 3: Mongoose Models and Schemas

Create `src/models/base.model.ts`:

```typescript
import { Schema, Document, Model, Query } from "mongoose";

export interface IBaseDocument extends Document {
  _id: any;
  createdAt: Date;
  updatedAt: Date;
}

export interface BaseModelMethods {
  toJSON(): any;
}

export interface BaseModelStatics<T extends IBaseDocument> {
  findByIdAndUpdateSafe(id: string, update: any): Query<T | null, T>;
  findActiveRecords(): Query<T[], T>;
}

export const baseSchemaOptions = {
  timestamps: true, // Automatically add createdAt and updatedAt
  toJSON: {
    transform: function (doc: any, ret: any) {
      ret.id = ret._id;
      delete ret._id;
      delete ret.__v;
      return ret;
    },
  },
  toObject: {
    transform: function (doc: any, ret: any) {
      ret.id = ret._id;
      delete ret._id;
      delete ret.__v;
      return ret;
    },
  },
};

export function addBaseSchema<T extends IBaseDocument>(schema: Schema<T>) {
  // Add common static methods
  schema.statics.findByIdAndUpdateSafe = function (id: string, update: any) {
    return this.findByIdAndUpdate(
      id,
      { ...update, updatedAt: new Date() },
      { new: true, runValidators: true }
    );
  };

  schema.statics.findActiveRecords = function () {
    return this.find({ isActive: { $ne: false } });
  };

  // Add common instance methods
  schema.methods.toJSON = function () {
    const obj = this.toObject();
    obj.id = obj._id;
    delete obj._id;
    delete obj.__v;
    return obj;
  };

  return schema;
}
```

Create `src/models/user.model.ts`:

```typescript
import { Schema, model, Document, Model } from "mongoose";
import bcrypt from "bcryptjs";
import {
  IBaseDocument,
  BaseModelMethods,
  BaseModelStatics,
  baseSchemaOptions,
  addBaseSchema,
} from "./base.model";

export enum UserRole {
  ADMIN = "admin",
  USER = "user",
  MODERATOR = "moderator",
}

export interface IAddress {
  street: string;
  city: string;
  state: string;
  zipCode: string;
  country: string;
  isPreferred?: boolean;
}

export interface IUser extends IBaseDocument, BaseModelMethods {
  firstName: string;
  lastName: string;
  email: string;
  password: string;
  role: UserRole;
  isActive: boolean;
  addresses: IAddress[];
  lastLoginAt?: Date;
  emailVerified: boolean;
  phoneNumber?: string;
  dateOfBirth?: Date;
  avatar?: string;
  preferences: {
    notifications: boolean;
    newsletter: boolean;
    darkMode: boolean;
  };
}

export interface IUserMethods extends BaseModelMethods {
  comparePassword(candidatePassword: string): Promise<boolean>;
  getFullName(): string;
  getPreferredAddress(): IAddress | null;
  updateLastLogin(): Promise<IUser>;
}

export interface UserModel
  extends Model<IUser, {}, IUserMethods>,
    BaseModelStatics<IUser> {
  findByEmail(email: string): Promise<IUser | null>;
  findActiveUsers(): Promise<IUser[]>;
  findUsersByRole(role: UserRole): Promise<IUser[]>;
}

const AddressSchema = new Schema<IAddress>(
  {
    street: { type: String, required: true, trim: true },
    city: { type: String, required: true, trim: true },
    state: { type: String, required: true, trim: true },
    zipCode: { type: String, required: true, trim: true },
    country: { type: String, required: true, trim: true },
    isPreferred: { type: Boolean, default: false },
  },
  { _id: false }
);

const UserSchema = new Schema<IUser, UserModel, IUserMethods>(
  {
    firstName: {
      type: String,
      required: [true, "First name is required"],
      trim: true,
      maxlength: [50, "First name cannot exceed 50 characters"],
    },
    lastName: {
      type: String,
      required: [true, "Last name is required"],
      trim: true,
      maxlength: [50, "Last name cannot exceed 50 characters"],
    },
    email: {
      type: String,
      required: [true, "Email is required"],
      unique: true,
      lowercase: true,
      trim: true,
      match: [
        /^\w+([.-]?\w+)*@\w+([.-]?\w+)*(\.\w{2,3})+$/,
        "Please provide a valid email",
      ],
    },
    password: {
      type: String,
      required: [true, "Password is required"],
      minlength: [6, "Password must be at least 6 characters"],
      select: false, // Don't include password in queries by default
    },
    role: {
      type: String,
      enum: Object.values(UserRole),
      default: UserRole.USER,
    },
    isActive: {
      type: Boolean,
      default: true,
      index: true,
    },
    addresses: [AddressSchema],
    lastLoginAt: {
      type: Date,
      default: null,
    },
    emailVerified: {
      type: Boolean,
      default: false,
    },
    phoneNumber: {
      type: String,
      trim: true,
      validate: {
        validator: function (v: string) {
          return !v || /^\+?[\d\s-()]+$/.test(v);
        },
        message: "Please provide a valid phone number",
      },
    },
    dateOfBirth: {
      type: Date,
      validate: {
        validator: function (v: Date) {
          return !v || v < new Date();
        },
        message: "Date of birth must be in the past",
      },
    },
    avatar: {
      type: String,
      trim: true,
    },
    preferences: {
      notifications: { type: Boolean, default: true },
      newsletter: { type: Boolean, default: false },
      darkMode: { type: Boolean, default: false },
    },
  },
  baseSchemaOptions
);

// Apply base schema enhancements
addBaseSchema(UserSchema);

// Indexes
UserSchema.index({ email: 1 });
UserSchema.index({ role: 1 });
UserSchema.index({ isActive: 1 });
UserSchema.index({ createdAt: -1 });

// Pre-save middleware to hash password
UserSchema.pre("save", async function (next) {
  if (!this.isModified("password")) return next();

  try {
    const salt = await bcrypt.genSalt(12);
    this.password = await bcrypt.hash(this.password, salt);
    next();
  } catch (error) {
    next(error as any);
  }
});

// Pre-update middleware to hash password
UserSchema.pre(["findOneAndUpdate", "updateOne"], async function (next) {
  const update = this.getUpdate() as any;

  if (update.password) {
    try {
      const salt = await bcrypt.genSalt(12);
      update.password = await bcrypt.hash(update.password, salt);
      next();
    } catch (error) {
      next(error as any);
    }
  } else {
    next();
  }
});

// Instance methods
UserSchema.methods.comparePassword = async function (
  candidatePassword: string
): Promise<boolean> {
  return bcrypt.compare(candidatePassword, this.password);
};

UserSchema.methods.getFullName = function (): string {
  return `${this.firstName} ${this.lastName}`;
};

UserSchema.methods.getPreferredAddress = function (): IAddress | null {
  const preferredAddress = this.addresses.find((addr) => addr.isPreferred);
  return (
    preferredAddress || (this.addresses.length > 0 ? this.addresses[0] : null)
  );
};

UserSchema.methods.updateLastLogin = async function (): Promise<IUser> {
  this.lastLoginAt = new Date();
  return this.save();
};

// Static methods
UserSchema.statics.findByEmail = function (email: string) {
  return this.findOne({ email: email.toLowerCase() });
};

UserSchema.statics.findActiveUsers = function () {
  return this.find({ isActive: true });
};

UserSchema.statics.findUsersByRole = function (role: UserRole) {
  return this.find({ role });
};

// Custom toJSON to exclude password and include virtual fields
UserSchema.methods.toJSON = function () {
  const userObject = this.toObject();
  delete userObject.password;
  userObject.id = userObject._id;
  delete userObject._id;
  delete userObject.__v;
  return userObject;
};

export const User = model<IUser, UserModel>("User", UserSchema);
```

### Step 4: Repository Implementation with Database

Create `src/repositories/user.repository.ts`:

```typescript
import {
  FilterQuery,
  UpdateQuery,
  QueryOptions as MongoQueryOptions,
} from "mongoose";
import { User, IUser, UserRole } from "../models/user.model";
import { QueryOptions, PaginationMeta } from "../types/common.types";
import {
  CreateUserRequest,
  UpdateUserRequest,
  UserFilterOptions,
} from "../types/user.types";
import { logger } from "../utils/logger.util";

export class UserRepository {
  async findAll(
    options: QueryOptions = {}
  ): Promise<{ data: IUser[]; meta: PaginationMeta }> {
    try {
      const {
        page = 1,
        limit = 10,
        sortBy = "createdAt",
        sortOrder = "desc",
        search,
      } = options;

      // Build filter query
      const filter: FilterQuery<IUser> = {};

      if (search) {
        filter.$or = [
          { firstName: { $regex: search, $options: "i" } },
          { lastName: { $regex: search, $options: "i" } },
          { email: { $regex: search, $options: "i" } },
        ];
      }

      // Build sort object
      const sort: { [key: string]: 1 | -1 } = {};
      sort[sortBy] = sortOrder === "asc" ? 1 : -1;

      // Execute queries
      const [data, total] = await Promise.all([
        User.find(filter)
          .sort(sort)
          .limit(limit)
          .skip((page - 1) * limit)
          .exec(),
        User.countDocuments(filter),
      ]);

      // Calculate pagination metadata
      const totalPages = Math.ceil(total / limit);
      const meta: PaginationMeta = {
        page,
        limit,
        total,
        totalPages,
        hasNext: page < totalPages,
        hasPrev: page > 1,
      };

      logger.debug("Users retrieved from database", {
        count: data.length,
        total,
        page,
        limit,
      });

      return { data, meta };
    } catch (error) {
      logger.error("Error retrieving users from database", error);
      throw error;
    }
  }

  async findById(id: string): Promise<IUser | null> {
    try {
      const user = await User.findById(id).exec();
      logger.debug("User retrieved by ID", { id, found: !!user });
      return user;
    } catch (error) {
      logger.error("Error retrieving user by ID", { id, error });
      throw error;
    }
  }

  async findByEmail(email: string): Promise<IUser | null> {
    try {
      const user = await User.findByEmail(email).select("+password").exec();
      logger.debug("User retrieved by email", { email, found: !!user });
      return user;
    } catch (error) {
      logger.error("Error retrieving user by email", { email, error });
      throw error;
    }
  }

  async create(userData: CreateUserRequest): Promise<IUser> {
    try {
      const user = new User(userData);
      const savedUser = await user.save();

      logger.info("User created in database", {
        id: savedUser._id,
        email: savedUser.email,
        role: savedUser.role,
      });

      return savedUser;
    } catch (error) {
      logger.error("Error creating user in database", {
        userData: { ...userData, password: "[REDACTED]" },
        error,
      });
      throw error;
    }
  }

  async update(
    id: string,
    updateData: UpdateUserRequest
  ): Promise<IUser | null> {
    try {
      const user = await User.findByIdAndUpdate(
        id,
        { ...updateData, updatedAt: new Date() },
        { new: true, runValidators: true }
      ).exec();

      logger.info("User updated in database", {
        id,
        updatedFields: Object.keys(updateData),
        found: !!user,
      });

      return user;
    } catch (error) {
      logger.error("Error updating user in database", {
        id,
        updateData,
        error,
      });
      throw error;
    }
  }

  async delete(id: string): Promise<boolean> {
    try {
      const result = await User.findByIdAndDelete(id).exec();

      logger.info("User deleted from database", {
        id,
        deleted: !!result,
      });

      return !!result;
    } catch (error) {
      logger.error("Error deleting user from database", { id, error });
      throw error;
    }
  }

  async softDelete(id: string): Promise<boolean> {
    try {
      const result = await User.findByIdAndUpdate(
        id,
        { isActive: false, updatedAt: new Date() },
        { new: true }
      ).exec();

      logger.info("User soft deleted in database", {
        id,
        deleted: !!result,
      });

      return !!result;
    } catch (error) {
      logger.error("Error soft deleting user in database", { id, error });
      throw error;
    }
  }

  async findByFilters(
    filters: UserFilterOptions,
    options: QueryOptions = {}
  ): Promise<{ data: IUser[]; meta: PaginationMeta }> {
    try {
      const {
        page = 1,
        limit = 10,
        sortBy = "createdAt",
        sortOrder = "desc",
      } = options;

      // Build filter query
      const filter: FilterQuery<IUser> = {};

      if (filters.role) {
        filter.role = filters.role;
      }

      if (filters.isActive !== undefined) {
        filter.isActive = filters.isActive;
      }

      if (filters.search) {
        filter.$or = [
          { firstName: { $regex: filters.search, $options: "i" } },
          { lastName: { $regex: filters.search, $options: "i" } },
          { email: { $regex: filters.search, $options: "i" } },
        ];
      }

      // Build sort object
      const sort: { [key: string]: 1 | -1 } = {};
      sort[sortBy] = sortOrder === "asc" ? 1 : -1;

      // Execute queries
      const [data, total] = await Promise.all([
        User.find(filter)
          .sort(sort)
          .limit(limit)
          .skip((page - 1) * limit)
          .exec(),
        User.countDocuments(filter),
      ]);

      // Calculate pagination metadata
      const totalPages = Math.ceil(total / limit);
      const meta: PaginationMeta = {
        page,
        limit,
        total,
        totalPages,
        hasNext: page < totalPages,
        hasPrev: page > 1,
      };

      logger.debug("Users retrieved by filters from database", {
        filters,
        count: data.length,
        total,
        page,
        limit,
      });

      return { data, meta };
    } catch (error) {
      logger.error("Error retrieving users by filters from database", {
        filters,
        options,
        error,
      });
      throw error;
    }
  }

  async count(filter: FilterQuery<IUser> = {}): Promise<number> {
    try {
      const count = await User.countDocuments(filter);
      logger.debug("User count retrieved from database", { filter, count });
      return count;
    } catch (error) {
      logger.error("Error counting users in database", { filter, error });
      throw error;
    }
  }

  async findUsersByRole(role: UserRole): Promise<IUser[]> {
    try {
      const users = await User.findUsersByRole(role);
      logger.debug("Users retrieved by role from database", {
        role,
        count: users.length,
      });
      return users;
    } catch (error) {
      logger.error("Error retrieving users by role from database", {
        role,
        error,
      });
      throw error;
    }
  }

  async updateLastLogin(id: string): Promise<IUser | null> {
    try {
      const user = await User.findById(id);
      if (!user) return null;

      await user.updateLastLogin();
      logger.debug("User last login updated", { id });
      return user;
    } catch (error) {
      logger.error("Error updating user last login", { id, error });
      throw error;
    }
  }

  // Database-specific operations
  async createIndexes(): Promise<void> {
    try {
      await User.createIndexes();
      logger.info("Database indexes created for User collection");
    } catch (error) {
      logger.error("Error creating database indexes", error);
      throw error;
    }
  }

  async aggregateUserStats(): Promise<any[]> {
    try {
      const stats = await User.aggregate([
        {
          $group: {
            _id: "$role",
            count: { $sum: 1 },
            activeCount: {
              $sum: { $cond: [{ $eq: ["$isActive", true] }, 1, 0] },
            },
            lastCreated: { $max: "$createdAt" },
          },
        },
        {
          $sort: { _id: 1 },
        },
      ]);

      logger.debug("User statistics aggregated from database", { stats });
      return stats;
    } catch (error) {
      logger.error("Error aggregating user statistics", error);
      throw error;
    }
  }
}
```

### Step 5: Updated Service Layer

Create `src/services/user.service.ts`:

```typescript
import { UserRepository } from "../repositories/user.repository";
import { IUser, UserRole } from "../models/user.model";
import {
  CreateUserRequest,
  UpdateUserRequest,
  UserFilterOptions,
  AuthUser,
} from "../types/user.types";
import { QueryOptions } from "../types/common.types";
import jwt from "jsonwebtoken";
import { logger } from "../utils/logger.util";

export class UserService {
  constructor(private userRepository: UserRepository) {}

  async getAllUsers(options?: QueryOptions) {
    return await this.userRepository.findAll(options);
  }

  async getUserById(id: string): Promise<IUser | null> {
    return await this.userRepository.findById(id);
  }

  async getUserByEmail(email: string): Promise<IUser | null> {
    return await this.userRepository.findByEmail(email);
  }

  async getUsersByFilters(filters: UserFilterOptions, options?: QueryOptions) {
    return await this.userRepository.findByFilters(filters, options);
  }

  async createUser(userData: CreateUserRequest): Promise<IUser> {
    // Check if user already exists
    const existingUser = await this.userRepository.findByEmail(userData.email);
    if (existingUser) {
      throw new Error("User with this email already exists");
    }

    // Validate business rules
    await this.validateUserCreation(userData);

    return await this.userRepository.create(userData);
  }

  async updateUser(
    id: string,
    updateData: UpdateUserRequest
  ): Promise<IUser | null> {
    // Check if user exists
    const existingUser = await this.userRepository.findById(id);
    if (!existingUser) {
      return null;
    }

    // If email is being updated, check for conflicts
    if (updateData.email && updateData.email !== existingUser.email) {
      const emailExists = await this.userRepository.findByEmail(
        updateData.email
      );
      if (emailExists) {
        throw new Error("Email is already in use by another user");
      }
    }

    // Validate business rules
    await this.validateUserUpdate(id, updateData);

    return await this.userRepository.update(id, updateData);
  }

  async deleteUser(id: string): Promise<boolean> {
    const user = await this.userRepository.findById(id);
    if (!user) {
      return false;
    }

    // Business rule: Cannot delete admin users if they're the last admin
    if (user.role === UserRole.ADMIN) {
      const adminCount = await this.userRepository.count({
        role: UserRole.ADMIN,
        isActive: true,
      });
      if (adminCount <= 1) {
        throw new Error("Cannot delete the last admin user");
      }
    }

    return await this.userRepository.delete(id);
  }

  async softDeleteUser(id: string): Promise<boolean> {
    const user = await this.userRepository.findById(id);
    if (!user) {
      return false;
    }

    // Business rule: Cannot deactivate admin users if they're the last admin
    if (user.role === UserRole.ADMIN) {
      const adminCount = await this.userRepository.count({
        role: UserRole.ADMIN,
        isActive: true,
      });
      if (adminCount <= 1) {
        throw new Error("Cannot deactivate the last admin user");
      }
    }

    return await this.userRepository.softDelete(id);
  }

  async authenticateUser(
    email: string,
    password: string
  ): Promise<{ user: AuthUser; token: string } | null> {
    const user = await this.userRepository.findByEmail(email);

    if (!user || !user.isActive) {
      logger.warn("Authentication failed - user not found or inactive", {
        email,
      });
      return null;
    }

    const isPasswordValid = await user.comparePassword(password);
    if (!isPasswordValid) {
      logger.warn("Authentication failed - invalid password", { email });
      return null;
    }

    // Update last login
    await this.userRepository.updateLastLogin(user._id.toString());

    const authUser: AuthUser = {
      id: user._id.toString(),
      email: user.email,
      firstName: user.firstName,
      lastName: user.lastName,
      role: user.role,
    };

    const token = jwt.sign(
      { userId: user._id.toString() },
      process.env.JWT_SECRET!,
      { expiresIn: process.env.JWT_EXPIRES_IN || "7d" }
    );

    logger.info("User authenticated successfully", {
      userId: user._id,
      email: user.email,
    });

    return { user: authUser, token };
  }

  async changePassword(
    userId: string,
    currentPassword: string,
    newPassword: string
  ): Promise<boolean> {
    const user = await this.userRepository.findByEmail(userId);
    if (!user) {
      return false;
    }

    const isCurrentPasswordValid = await user.comparePassword(currentPassword);
    if (!isCurrentPasswordValid) {
      return false;
    }

    await this.userRepository.update(userId, { password: newPassword });

    logger.info("Password changed successfully", { userId });
    return true;
  }

  async getUserStats(): Promise<any[]> {
    return await this.userRepository.aggregateUserStats();
  }

  async getUsersByRole(role: UserRole): Promise<IUser[]> {
    return await this.userRepository.findUsersByRole(role);
  }

  // Utility methods
  excludePassword(user: IUser): Omit<IUser, "password"> {
    return user.toJSON();
  }

  excludePasswordFromArray(users: IUser[]): Omit<IUser, "password">[] {
    return users.map((user) => this.excludePassword(user));
  }

  private async validateUserCreation(
    userData: CreateUserRequest
  ): Promise<void> {
    // Add custom business validation rules here
    if (userData.role === UserRole.ADMIN) {
      // Additional validation for admin creation
      logger.info("Admin user creation attempt", { email: userData.email });
    }

    // Example: Validate email domain for certain roles
    if (
      userData.role === UserRole.ADMIN &&
      !userData.email.endsWith("@company.com")
    ) {
      throw new Error("Admin users must use company email domain");
    }
  }

  private async validateUserUpdate(
    id: string,
    updateData: UpdateUserRequest
  ): Promise<void> {
    // Add custom business validation rules here
    if (updateData.role === UserRole.ADMIN) {
      logger.info("Admin role assignment attempt", { userId: id });
    }
  }
}
```

### Step 6: Updated Application Setup

Update `src/server.ts` to include database connection:

```typescript
import app from "./app";
import { logger } from "./utils/logger.util";
import { dbConfig } from "./config/database";

const PORT = process.env.PORT || 3000;

async function startServer() {
  try {
    // Connect to database
    await dbConfig.connect();

    // Start the server
    const server = app.listen(PORT, () => {
      logger.info(`ğŸš€ Server running on http://localhost:${PORT}`);
      logger.info(`ğŸ“š API Documentation: http://localhost:${PORT}/`);
      logger.info(`ğŸ¥ Health Check: http://localhost:${PORT}/api/v1/health`);
      logger.info(`ğŸŒ Environment: ${process.env.NODE_ENV}`);
      logger.info(`ğŸ’¾ Database: Connected to MongoDB`);
    });

    // Graceful shutdown handling
    const gracefulShutdown = async (signal: string) => {
      logger.info(`${signal} received. Starting graceful shutdown...`);

      server.close(async () => {
        logger.info("HTTP server closed");

        try {
          await dbConfig.disconnect();
          logger.info("Database disconnected");
          process.exit(0);
        } catch (error) {
          logger.error("Error during database disconnection:", error);
          process.exit(1);
        }
      });
    };

    process.on("SIGTERM", () => gracefulShutdown("SIGTERM"));
    process.on("SIGINT", () => gracefulShutdown("SIGINT"));
  } catch (error) {
    logger.error("Failed to start server:", error);
    process.exit(1);
  }
}

// Handle uncaught exceptions
process.on("uncaughtException", (error) => {
  logger.error("Uncaught Exception:", error);
  process.exit(1);
});

// Handle unhandled promise rejections
process.on("unhandledRejection", (reason, promise) => {
  logger.error("Unhandled Rejection:", { reason, promise });
  process.exit(1);
});

startServer();
```

### Step 7: Testing the Database Integration

Start MongoDB using Docker:

```bash
docker-compose up -d
```

Install and run the application:

```bash
npm install
npm run dev
```

Test the database operations:

```bash
# Create a user
curl -X POST http://localhost:3000/api/v1/users/register \
  -H "Content-Type: application/json" \
  -d '{
    "firstName": "John",
    "lastName": "Doe",
    "email": "john@company.com",
    "password": "Password123",
    "role": "admin"
  }'

# Login and get token
curl -X POST http://localhost:3000/api/v1/users/login \
  -H "Content-Type: application/json" \
  -d '{
    "email": "john@company.com",
    "password": "Password123"
  }'

# Get all users with pagination
curl "http://localhost:3000/api/v1/users?page=1&limit=5&sortBy=createdAt&sortOrder=desc" \
  -H "Authorization: Bearer YOUR_TOKEN_HERE"

# Search users
curl "http://localhost:3000/api/v1/users?search=john" \
  -H "Authorization: Bearer YOUR_TOKEN_HERE"

# Update a user
curl -X PUT http://localhost:3000/api/v1/users/USER_ID \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer YOUR_TOKEN_HERE" \
  -d '{
    "firstName": "Johnny",
    "preferences": {
      "notifications": true,
      "newsletter": true,
      "darkMode": false
    }
  }'
```

## Key MongoDB & Mongoose Concepts Demonstrated

### 1. **Schema Design**

```typescript
const UserSchema = new Schema({
  firstName: { type: String, required: true, trim: true },
  email: { type: String, unique: true, lowercase: true },
});
```

### 2. **Validation**

```typescript
email: {
  match: [
    /^\w+([.-]?\w+)*@\w+([.-]?\w+)*(\.\w{2,3})+$/,
    "Please provide a valid email",
  ];
}
```

### 3. **Middleware (Hooks)**

```typescript
UserSchema.pre("save", async function (next) {
  if (!this.isModified("password")) return next();
  this.password = await bcrypt.hash(this.password, 12);
  next();
});
```

### 4. **Instance Methods**

```typescript
UserSchema.methods.comparePassword = async function (password: string) {
  return bcrypt.compare(password, this.password);
};
```

### 5. **Static Methods**

```typescript
UserSchema.statics.findByEmail = function (email: string) {
  return this.findOne({ email });
};
```

### 6. **Indexes**

```typescript
UserSchema.index({ email: 1 });
UserSchema.index({ role: 1 });
```

### 7. **Aggregation Pipeline**

```typescript
const stats = await User.aggregate([
  { $group: { _id: "$role", count: { $sum: 1 } } },
]);
```

## Database Best Practices Demonstrated

1. **Schema Validation**: Built-in and custom validators
2. **Password Security**: Hashing with bcrypt
3. **Indexing**: Performance optimization
4. **Connection Management**: Proper connect/disconnect
5. **Error Handling**: Database-specific error handling
6. **Data Transformation**: JSON serialization control
7. **Pagination**: Efficient data retrieval
8. **Aggregation**: Complex queries for analytics

This implementation provides a solid foundation for working with MongoDB in Express.js applications while maintaining clean architecture and proper error handling.

---

## References and Resources

### MongoDB & Mongoose

- [MongoDB Official Documentation](https://docs.mongodb.com/)
- [Mongoose Official Documentation](https://mongoosejs.com/docs/)
- [Mongoose Schema Types](https://mongoosejs.com/docs/schematypes.html)
- [Mongoose Middleware](https://mongoosejs.com/docs/middleware.html)
- [Mongoose Validation](https://mongoosejs.com/docs/validation.html)

### Database Design Patterns

- [MongoDB Schema Design Patterns](https://www.mongodb.com/blog/post/building-with-patterns-a-summary)
- [NoSQL Data Modeling](https://highlyscalable.wordpress.com/2012/03/01/nosql-data-modeling-techniques/)
- [Repository Pattern](https://martinfowler.com/eaaCatalog/repository.html)

### Performance and Optimization

- [MongoDB Indexing Strategies](https://docs.mongodb.com/manual/applications/indexes/)
- [MongoDB Performance Best Practices](https://docs.mongodb.com/manual/administration/performance-notes/)
- [Mongoose Performance Tips](https://mongoosejs.com/docs/tutorials/lean.html)

### Security

- [MongoDB Security](https://docs.mongodb.com/manual/security/)
- [Password Hashing with bcrypt](https://github.com/kelektiv/node.bcrypt.js)
- [Input Validation](https://mongoosejs.com/docs/validation.html)
