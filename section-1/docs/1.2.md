# The Building Blocks of an API

## Overview

Understanding how information flows through a backend application is crucial for building robust APIs. This section covers the complete journey of a request from the frontend to the database and back.

## API Request-Response Flow

### Complete End-to-End Flow

```
┌─────────────┐    1. HTTP Request    ┌─────────────────────────────────────┐
│  FRONTEND   │─────────────────────▶│             BACKEND                 │
│             │                      │                                     │
│ • React     │                      │  2. Server Initialization          │
│ • Vue       │                      │  ┌─────────────────────────────────┐│
│ • Angular   │                      │  │ • Express App                   ││
│ • Mobile    │                      │  │ • Middleware Loading            ││
│ • Postman   │                      │  │ • Route Registration           ││
└─────────────┘                      │  │ • Error Handler Setup          ││
       ▲                             │  └─────────────────────────────────┘│
       │                             │               │                     │
       │                             │               ▼                     │
       │                             │  3. Request Routing                │
       │                             │  ┌─────────────────────────────────┐│
       │                             │  │ • URL Pattern Matching          ││
       │                             │  │ • HTTP Method Validation        ││
       │                             │  │ • Route Parameters Extraction   ││
       │                             │  └─────────────────────────────────┘│
       │                             │               │                     │
       │                             │               ▼                     │
       │                             │  4. Middleware Chain               │
       │                             │  ┌─────────────────────────────────┐│
       │                             │  │ • Authentication Check          ││
       │                             │  │ • CORS Headers                  ││
       │                             │  │ • Request Parsing               ││
       │                             │  │ • Rate Limiting                 ││
       │                             │  │ • Custom Middleware             ││
       │                             │  └─────────────────────────────────┘│
       │                             │               │                     │
       │                             │               ▼                     │
       │                             │  5. Controller Layer               │
       │                             │  ┌─────────────────────────────────┐│
       │                             │  │ • Request Validation            ││
       │                             │  │ • Input Sanitization            ││
       │                             │  │ • Business Logic Orchestration  ││
       │                             │  └─────────────────────────────────┘│
       │                             │               │                     │
       │                             │               ▼                     │
       │                             │  6. Service Layer                  │
       │                             │  ┌─────────────────────────────────┐│
       │                             │  │ • Business Logic                ││
       │                             │  │ • Data Transformation           ││
       │                             │  │ • External API Calls            ││
       │                             │  │ • Caching Logic                 ││
       │                             │  └─────────────────────────────────┘│
       │                             │               │                     │
       │                             │               ▼                     │
       │                             │  7. Repository/Data Layer          │
       │                             │  ┌─────────────────────────────────┐│
       │                             │  │ • Database Query Building       ││
       │                             │  │ • ORM Operations                ││
       │                             │  │ • Data Mapping                  ││
       │                             │  └─────────────────────────────────┘│
       │                             │               │                     │
       │                             └───────────────┼─────────────────────┘
       │                                             ▼
       │                             ┌─────────────────────────────────────┐
       │                             │            DATABASE                 │
       │                             │                                     │
       │                             │ 8. Database Operations             │
       │                             │ ┌─────────────────────────────────┐ │
       │                             │ │ • Query Execution               │ │
       │                             │ │ • Data Retrieval/Storage        │ │
       │                             │ │ • Relationship Handling         │ │
       │                             │ │ • Transaction Management        │ │
       │                             │ └─────────────────────────────────┘ │
       │                             │               │                     │
       │                             └───────────────┼─────────────────────┘
       │                                             │
       │    9. Response Journey (Reverse Flow)       │
       │◄────────────────────────────────────────────┘
    10. HTTP Response
```

## Layer-by-Layer Breakdown

### 1. Server Initialization Layer

#### Purpose

Set up the application environment and configure the server.

```typescript
// Express Application Setup
import express from "express";
import cors from "cors";
import helmet from "helmet";

const app = express();

// Global Middleware
app.use(helmet()); // Security headers
app.use(cors()); // Cross-origin requests
app.use(express.json()); // Parse JSON bodies
app.use(express.urlencoded({ extended: true }));

// Routes Registration
app.use("/api/users", userRoutes);
app.use("/api/products", productRoutes);

// Error Handler
app.use(errorHandler);

app.listen(3000);
```

#### Responsibilities

- **Environment Setup**: Load configuration, environment variables
- **Middleware Registration**: Global middleware setup
- **Route Registration**: Connect routes to handlers
- **Error Handler Setup**: Global error handling

### 2. Routing Layer

#### Purpose

Match incoming requests to appropriate handlers based on URL patterns and HTTP methods.

```typescript
// Route Definition
import { Router } from "express";
const router = Router();

// HTTP Method + URL Pattern → Handler
router.get("/users", getAllUsers); // GET /api/users
router.get("/users/:id", getUserById); // GET /api/users/123
router.post("/users", createUser); // POST /api/users
router.put("/users/:id", updateUser); // PUT /api/users/123
router.delete("/users/:id", deleteUser); // DELETE /api/users/123

// Route with Query Parameters
router.get("/users", getUsersWithFilters); // GET /api/users?age=25&city=NYC
```

#### URL Pattern Matching

```
Request: GET /api/users/123/orders/456
         │   │    │     │   │      │
         │   │    │     │   │      └─ Order ID parameter
         │   │    │     │   └─ Resource (orders)
         │   │    │     └─ User ID parameter
         │   │    └─ Resource (users)
         │   └─ API prefix
         └─ HTTP Method

Matched Route: /api/users/:userId/orders/:orderId
```

### 3. Middleware Chain

#### Purpose

Execute cross-cutting concerns that affect multiple routes.

```typescript
// Middleware Execution Order
app.use((req, res, next) => {
  console.log(`${req.method} ${req.path} - ${new Date()}`);
  next(); // Continue to next middleware
});

// Authentication Middleware
const authenticateToken = (req, res, next) => {
  const token = req.headers.authorization?.split(" ")[1];

  if (!token) {
    return res.status(401).json({ error: "Access token required" });
  }

  try {
    const user = jwt.verify(token, process.env.JWT_SECRET);
    req.user = user;
    next(); // Continue to controller
  } catch (error) {
    res.status(403).json({ error: "Invalid token" });
  }
};

// Route with Middleware
router.get("/profile", authenticateToken, getUserProfile);
```

#### Common Middleware Types

```
┌─────────────────────────────────────────────────────────┐
│                  MIDDLEWARE TYPES                       │
├─────────────────┬─────────────────┬─────────────────────┤
│   SECURITY      │   PROCESSING    │     VALIDATION      │
│                 │                 │                     │
│ • Authentication│ • Body Parsing  │ • Input Validation  │
│ • Authorization │ • File Upload   │ • Schema Validation │
│ • Rate Limiting │ • Compression   │ • Sanitization      │
│ • CORS          │ • Logging       │ • Type Checking     │
│ • Helmet        │ • Caching       │                     │
└─────────────────┴─────────────────┴─────────────────────┘
```

### 4. Controller Layer

#### Purpose

Handle HTTP-specific logic and orchestrate business operations.

```typescript
// User Controller
export class UserController {
  async createUser(req: Request, res: Response, next: NextFunction) {
    try {
      // 1. Input Validation
      const { error, value } = userSchema.validate(req.body);
      if (error) {
        return res.status(400).json({
          error: "Validation failed",
          details: error.details,
        });
      }

      // 2. Sanitize Input
      const sanitizedData = sanitizeUserInput(value);

      // 3. Business Logic Delegation
      const user = await this.userService.createUser(sanitizedData);

      // 4. Response Formatting
      res.status(201).json({
        status: "success",
        data: { user },
        message: "User created successfully",
      });
    } catch (error) {
      next(error); // Pass to error handler
    }
  }
}
```

#### Controller Responsibilities

- **Request Validation**: Ensure incoming data is valid
- **Input Sanitization**: Clean and secure user input
- **Service Orchestration**: Call appropriate business logic
- **Response Formatting**: Structure the HTTP response
- **Error Handling**: Catch and forward errors

### 5. Service Layer

#### Purpose

Contain business logic and coordinate between controllers and data access.

```typescript
// User Service
export class UserService {
  constructor(
    private userRepository: UserRepository,
    private emailService: EmailService,
    private cacheService: CacheService
  ) {}

  async createUser(userData: CreateUserDTO): Promise<User> {
    // 1. Business Rule Validation
    await this.validateUserBusinessRules(userData);

    // 2. Data Transformation
    const processedData = {
      ...userData,
      email: userData.email.toLowerCase(),
      password: await this.hashPassword(userData.password),
      role: userData.role || UserRole.USER,
      createdAt: new Date(),
    };

    // 3. Database Operation
    const user = await this.userRepository.create(processedData);

    // 4. Side Effects
    await this.emailService.sendWelcomeEmail(user.email);
    await this.cacheService.invalidateUserCache();

    // 5. External API Calls (if needed)
    await this.notificationService.sendUserRegisteredEvent(user.id);

    return user;
  }

  private async validateUserBusinessRules(
    userData: CreateUserDTO
  ): Promise<void> {
    const existingUser = await this.userRepository.findByEmail(userData.email);
    if (existingUser) {
      throw new ConflictError("Email already exists");
    }
  }
}
```

#### Service Layer Responsibilities

- **Business Logic**: Core application rules and processes
- **Data Transformation**: Convert between different data formats
- **External Integrations**: Third-party API calls
- **Caching Logic**: Performance optimization
- **Event Handling**: System events and notifications

### 6. Repository/Data Access Layer

#### Purpose

Abstract database operations and provide a clean interface for data access.

```typescript
// User Repository
export class UserRepository {
  constructor(private db: Database) {}

  async create(userData: Partial<User>): Promise<User> {
    const query = `
      INSERT INTO users (first_name, last_name, email, password, role, created_at)
      VALUES ($1, $2, $3, $4, $5, $6)
      RETURNING *
    `;

    const values = [
      userData.firstName,
      userData.lastName,
      userData.email,
      userData.password,
      userData.role,
      userData.createdAt,
    ];

    const result = await this.db.query(query, values);
    return this.mapToUser(result.rows[0]);
  }

  async findByEmail(email: string): Promise<User | null> {
    const query = "SELECT * FROM users WHERE email = $1";
    const result = await this.db.query(query, [email]);

    return result.rows.length > 0 ? this.mapToUser(result.rows[0]) : null;
  }

  private mapToUser(row: any): User {
    return {
      id: row.id,
      firstName: row.first_name,
      lastName: row.last_name,
      email: row.email,
      role: row.role,
      createdAt: row.created_at,
      updatedAt: row.updated_at,
    };
  }
}
```

#### Repository Responsibilities

- **Query Building**: Construct database queries
- **Data Mapping**: Convert between database and application models
- **Connection Management**: Handle database connections
- **Transaction Support**: Manage database transactions

### 7. Database Layer

#### Purpose

Store, retrieve, and manage application data persistently.

```sql
-- Database Schema
CREATE TABLE users (
  id SERIAL PRIMARY KEY,
  first_name VARCHAR(50) NOT NULL,
  last_name VARCHAR(50) NOT NULL,
  email VARCHAR(255) UNIQUE NOT NULL,
  password VARCHAR(255) NOT NULL,
  role VARCHAR(20) DEFAULT 'user',
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Indexes for Performance
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_role ON users(role);
```

#### Database Operations Flow

```
Application Request
        │
        ▼
┌─────────────────┐
│ Connection Pool │ ← Manages concurrent connections
└─────────────────┘
        │
        ▼
┌─────────────────┐
│ Query Planning  │ ← Optimizes query execution
└─────────────────┘
        │
        ▼
┌─────────────────┐
│ Query Execution │ ← Executes SQL commands
└─────────────────┘
        │
        ▼
┌─────────────────┐
│ Data Retrieval  │ ← Fetches/modifies data
└─────────────────┘
        │
        ▼
┌─────────────────┐
│ Result Mapping  │ ← Converts to application format
└─────────────────┘
```

## Error Handling Throughout the Flow

### Error Types and Handling

```typescript
// Error Types Hierarchy
class AppError extends Error {
  constructor(
    public message: string,
    public statusCode: number,
    public isOperational: boolean = true
  ) {
    super(message);
  }
}

class ValidationError extends AppError {
  constructor(message: string) {
    super(message, 400);
  }
}

class NotFoundError extends AppError {
  constructor(resource: string) {
    super(`${resource} not found`, 404);
  }
}

class ConflictError extends AppError {
  constructor(message: string) {
    super(message, 409);
  }
}

// Global Error Handler
const errorHandler = (
  error: Error,
  req: Request,
  res: Response,
  next: NextFunction
) => {
  if (error instanceof AppError) {
    return res.status(error.statusCode).json({
      status: "error",
      message: error.message,
    });
  }

  // Unhandled errors
  console.error("Unhandled error:", error);
  res.status(500).json({
    status: "error",
    message: "Internal server error",
  });
};
```

### Error Propagation Flow

```
Controller Layer    │ Catches and formats errors
       ▲            │
Service Layer       │ Throws business logic errors
       ▲            │
Repository Layer    │ Throws data access errors
       ▲            │
Database Layer      │ Throws connection/query errors
```

## Authentication and Authorization Flow

### JWT Authentication Process

```
1. User Login Request
        │
        ▼
2. Validate Credentials
        │
        ▼
3. Generate JWT Token
        │
        ▼
4. Return Token to Client
        │
        ▼
5. Client Stores Token
        │
        ▼
6. Include Token in Subsequent Requests
        │
        ▼
7. Middleware Validates Token
        │
        ▼
8. Extract User Info from Token
        │
        ▼
9. Continue to Controller
```

### Authorization Middleware

```typescript
const authorizeRole = (roles: string[]) => {
  return (req: Request, res: Response, next: NextFunction) => {
    if (!req.user) {
      return res.status(401).json({ error: "Authentication required" });
    }

    if (!roles.includes(req.user.role)) {
      return res.status(403).json({ error: "Insufficient permissions" });
    }

    next();
  };
};

// Usage
router.delete(
  "/users/:id",
  authenticateToken,
  authorizeRole(["admin"]),
  deleteUser
);
```

## Data Flow Patterns

### Request Data Transformation

```
Raw HTTP Request
       │
       ▼ (Parsing)
Request Object { body, params, query }
       │
       ▼ (Validation)
Validated DTO
       │
       ▼ (Business Logic)
Domain Model
       │
       ▼ (Persistence)
Database Entity
```

### Response Data Transformation

```
Database Entity
       │
       ▼ (Mapping)
Domain Model
       │
       ▼ (Serialization)
Response DTO
       │
       ▼ (Formatting)
HTTP Response
```

## Performance Considerations

### Caching Strategy

```
Request → Cache Check → Cache Hit? → Return Cached Data
              │              │
              ▼              │
         Cache Miss          │
              │              │
              ▼              │
      Execute Business       │
           Logic             │
              │              │
              ▼              │
        Store in Cache ──────┘
              │
              ▼
        Return Fresh Data
```

### Database Optimization

- **Connection Pooling**: Reuse database connections
- **Query Optimization**: Use indexes and efficient queries
- **Lazy Loading**: Load related data only when needed
- **Pagination**: Limit result set size

---

## References and Resources

### HTTP and REST

- [HTTP Methods - MDN](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods)
- [HTTP Status Codes](https://httpstatuses.com/)
- [REST API Design Guide](https://restfulapi.net/)

### Authentication & Authorization

- [JWT.io - JSON Web Tokens](https://jwt.io/)
- [OAuth 2.0 Guide](https://oauth.net/2/)
- [Express Authentication Best Practices](https://expressjs.com/en/advanced/best-practice-security.html)

### Error Handling

- [Error Handling in Express.js](https://expressjs.com/en/guide/error-handling.html)
- [Node.js Error Handling Best Practices](https://github.com/goldbergyoni/nodebestpractices#-2-error-handling-practices)

### Performance & Caching

- [Node.js Performance Best Practices](https://github.com/goldbergyoni/nodebestpractices#-5-performance-practices)
- [Redis Caching Guide](https://redis.io/docs/manual/patterns/caching/)
- [Database Connection Pooling](https://github.com/brianc/node-postgres/wiki/pg-pool)
