# Express App Structure - Best Practices

## Overview

In this exercise, we'll refactor our Express application to follow industry best practices using the route-controller-service-repository pattern. This architectural pattern provides clear separation of concerns and makes applications more maintainable and testable.

## Learning Objectives

- Understand the layered architecture pattern
- Implement route-controller-service-repository structure
- Create proper folder organization
- Build utility functions and custom middleware
- Focus on a single domain (users) for clarity

## The Layered Architecture Pattern

### Architecture Overview

```
┌─────────────────────────────────────────────────────────┐
│                    CLIENT REQUEST                       │
└─────────────────┬───────────────────────────────────────┘
                  │
                  ▼
┌─────────────────────────────────────────────────────────┐
│                ROUTE LAYER                              │
│ • HTTP method mapping                                   │
│ • URL pattern matching                                  │
│ • Middleware orchestration                              │
└─────────────────┬───────────────────────────────────────┘
                  │
                  ▼
┌─────────────────────────────────────────────────────────┐
│              CONTROLLER LAYER                           │
│ • Request/Response handling                             │
│ • Input validation                                      │
│ • Data transformation                                   │
│ • Error handling                                        │
└─────────────────┬───────────────────────────────────────┘
                  │
                  ▼
┌─────────────────────────────────────────────────────────┐
│               SERVICE LAYER                             │
│ • Business logic                                        │
│ • Data processing                                       │
│ • External API calls                                    │
│ • Business rules validation                             │
└─────────────────┬───────────────────────────────────────┘
                  │
                  ▼
┌─────────────────────────────────────────────────────────┐
│             REPOSITORY LAYER                            │
│ • Data access abstraction                               │
│ • Database operations                                   │
│ • Query building                                        │
│ • Data mapping                                          │
└─────────────────┬───────────────────────────────────────┘
                  │
                  ▼
┌─────────────────────────────────────────────────────────┐
│                  DATABASE                               │
└─────────────────────────────────────────────────────────┘
```

### Benefits of This Structure

1. **Separation of Concerns**: Each layer has a specific responsibility
2. **Testability**: Easy to unit test individual layers
3. **Maintainability**: Changes in one layer don't affect others
4. **Reusability**: Services and repositories can be reused
5. **Scalability**: Easy to add new features or modify existing ones

## Exercise: User Management System

Let's build a comprehensive user management system following best practices.

### Step 1: Project Structure Setup

Create the following organized folder structure:

```
structured-express-app/
├── src/
│   ├── app.ts                      # Main application
│   ├── server.ts                   # Server startup
│   ├── config/
│   │   ├── database.ts             # Database configuration
│   │   └── app.config.ts           # Application configuration
│   ├── controllers/
│   │   ├── base.controller.ts      # Base controller class
│   │   └── user.controller.ts      # User controller
│   ├── services/
│   │   ├── base.service.ts         # Base service class
│   │   └── user.service.ts         # User service
│   ├── repositories/
│   │   ├── base.repository.ts      # Base repository interface
│   │   └── user.repository.ts      # User repository
│   ├── routes/
│   │   ├── index.ts                # Route aggregator
│   │   └── user.routes.ts          # User routes
│   ├── middleware/
│   │   ├── auth.middleware.ts      # Authentication
│   │   ├── validation.middleware.ts # Validation
│   │   ├── error.middleware.ts     # Error handling
│   │   └── logging.middleware.ts   # Request logging
│   ├── utils/
│   │   ├── response.util.ts        # Response utilities
│   │   ├── validator.util.ts       # Validation schemas
│   │   ├── logger.util.ts          # Logging utility
│   │   └── auth.util.ts            # Authentication utilities
│   ├── types/
│   │   ├── user.types.ts           # User-related types
│   │   └── common.types.ts         # Common types
│   └── constants/
│       └── http-status.ts          # HTTP status constants
├── .env
├── package.json
└── tsconfig.json
```

### Step 2: Core Types and Constants

Create `src/types/common.types.ts`:

```typescript
export interface ApiResponse<T = any> {
  success: boolean;
  message: string;
  data?: T;
  error?: string;
  timestamp: string;
  pagination?: PaginationMeta;
}

export interface PaginationMeta {
  page: number;
  limit: number;
  total: number;
  totalPages: number;
  hasNext: boolean;
  hasPrev: boolean;
}

export interface QueryOptions {
  page?: number;
  limit?: number;
  sortBy?: string;
  sortOrder?: "asc" | "desc";
  search?: string;
}

export interface BaseEntity {
  id: number;
  createdAt: Date;
  updatedAt: Date;
}
```

Create `src/types/user.types.ts`:

```typescript
import { BaseEntity } from "./common.types";

export interface User extends BaseEntity {
  firstName: string;
  lastName: string;
  email: string;
  password: string;
  role: UserRole;
  isActive: boolean;
  lastLoginAt?: Date;
}

export enum UserRole {
  ADMIN = "admin",
  USER = "user",
  MODERATOR = "moderator",
}

export interface CreateUserRequest {
  firstName: string;
  lastName: string;
  email: string;
  password: string;
  role?: UserRole;
}

export interface UpdateUserRequest {
  firstName?: string;
  lastName?: string;
  email?: string;
  role?: UserRole;
  isActive?: boolean;
}

export interface LoginRequest {
  email: string;
  password: string;
}

export interface AuthUser {
  id: number;
  email: string;
  firstName: string;
  lastName: string;
  role: UserRole;
}

export interface UserFilterOptions {
  role?: UserRole;
  isActive?: boolean;
  search?: string;
}

declare global {
  namespace Express {
    interface Request {
      user?: AuthUser;
    }
  }
}
```

Create `src/constants/http-status.ts`:

```typescript
export const HTTP_STATUS = {
  OK: 200,
  CREATED: 201,
  NO_CONTENT: 204,
  BAD_REQUEST: 400,
  UNAUTHORIZED: 401,
  FORBIDDEN: 403,
  NOT_FOUND: 404,
  CONFLICT: 409,
  UNPROCESSABLE_ENTITY: 422,
  INTERNAL_SERVER_ERROR: 500,
} as const;

export const HTTP_MESSAGES = {
  OK: "Success",
  CREATED: "Created successfully",
  NO_CONTENT: "No content",
  BAD_REQUEST: "Bad request",
  UNAUTHORIZED: "Unauthorized",
  FORBIDDEN: "Forbidden",
  NOT_FOUND: "Resource not found",
  CONFLICT: "Resource already exists",
  UNPROCESSABLE_ENTITY: "Validation failed",
  INTERNAL_SERVER_ERROR: "Internal server error",
} as const;
```

### Step 3: Utility Classes

Create `src/utils/response.util.ts`:

```typescript
import { Response } from "express";
import { ApiResponse, PaginationMeta } from "../types/common.types";
import { HTTP_STATUS, HTTP_MESSAGES } from "../constants/http-status";

export class ResponseUtil {
  static success<T>(
    res: Response,
    message: string = HTTP_MESSAGES.OK,
    data?: T,
    statusCode: number = HTTP_STATUS.OK,
    pagination?: PaginationMeta
  ): Response {
    const response: ApiResponse<T> = {
      success: true,
      message,
      data,
      timestamp: new Date().toISOString(),
      ...(pagination && { pagination }),
    };
    return res.status(statusCode).json(response);
  }

  static error(
    res: Response,
    message: string = HTTP_MESSAGES.BAD_REQUEST,
    statusCode: number = HTTP_STATUS.BAD_REQUEST,
    error?: string
  ): Response {
    const response: ApiResponse = {
      success: false,
      message,
      error,
      timestamp: new Date().toISOString(),
    };
    return res.status(statusCode).json(response);
  }

  static created<T>(res: Response, message: string, data: T): Response {
    return this.success(res, message, data, HTTP_STATUS.CREATED);
  }

  static notFound(res: Response, resource: string = "Resource"): Response {
    return this.error(res, `${resource} not found`, HTTP_STATUS.NOT_FOUND);
  }

  static unauthorized(
    res: Response,
    message: string = HTTP_MESSAGES.UNAUTHORIZED
  ): Response {
    return this.error(res, message, HTTP_STATUS.UNAUTHORIZED);
  }

  static forbidden(
    res: Response,
    message: string = HTTP_MESSAGES.FORBIDDEN
  ): Response {
    return this.error(res, message, HTTP_STATUS.FORBIDDEN);
  }

  static conflict(res: Response, message: string): Response {
    return this.error(res, message, HTTP_STATUS.CONFLICT);
  }

  static validationError(
    res: Response,
    message: string,
    error?: string
  ): Response {
    return this.error(res, message, HTTP_STATUS.UNPROCESSABLE_ENTITY, error);
  }

  static internalError(
    res: Response,
    message: string = HTTP_MESSAGES.INTERNAL_SERVER_ERROR
  ): Response {
    return this.error(res, message, HTTP_STATUS.INTERNAL_SERVER_ERROR);
  }
}
```

Create `src/utils/logger.util.ts`:

```typescript
export enum LogLevel {
  ERROR = "error",
  WARN = "warn",
  INFO = "info",
  DEBUG = "debug",
}

export class Logger {
  private static instance: Logger;
  private logLevel: LogLevel;

  private constructor() {
    this.logLevel = (process.env.LOG_LEVEL as LogLevel) || LogLevel.INFO;
  }

  static getInstance(): Logger {
    if (!Logger.instance) {
      Logger.instance = new Logger();
    }
    return Logger.instance;
  }

  private shouldLog(level: LogLevel): boolean {
    const levels = [
      LogLevel.ERROR,
      LogLevel.WARN,
      LogLevel.INFO,
      LogLevel.DEBUG,
    ];
    const currentLevelIndex = levels.indexOf(this.logLevel);
    const messageLevelIndex = levels.indexOf(level);
    return messageLevelIndex <= currentLevelIndex;
  }

  private formatLog(level: LogLevel, message: string, meta?: any): string {
    const timestamp = new Date().toISOString();
    const logEntry = {
      timestamp,
      level,
      message,
      ...(meta && { meta }),
    };
    return JSON.stringify(logEntry);
  }

  error(message: string, meta?: any): void {
    if (this.shouldLog(LogLevel.ERROR)) {
      console.error(this.formatLog(LogLevel.ERROR, message, meta));
    }
  }

  warn(message: string, meta?: any): void {
    if (this.shouldLog(LogLevel.WARN)) {
      console.warn(this.formatLog(LogLevel.WARN, message, meta));
    }
  }

  info(message: string, meta?: any): void {
    if (this.shouldLog(LogLevel.INFO)) {
      console.info(this.formatLog(LogLevel.INFO, message, meta));
    }
  }

  debug(message: string, meta?: any): void {
    if (this.shouldLog(LogLevel.DEBUG)) {
      console.debug(this.formatLog(LogLevel.DEBUG, message, meta));
    }
  }
}

export const logger = Logger.getInstance();
```

### Step 4: Base Classes

Create `src/repositories/base.repository.ts`:

```typescript
import { QueryOptions, PaginationMeta } from "../types/common.types";

export interface IBaseRepository<T, CreateDTO, UpdateDTO> {
  findAll(options?: QueryOptions): Promise<{ data: T[]; meta: PaginationMeta }>;
  findById(id: number): Promise<T | null>;
  create(data: CreateDTO): Promise<T>;
  update(id: number, data: UpdateDTO): Promise<T | null>;
  delete(id: number): Promise<boolean>;
  count(filters?: any): Promise<number>;
}

export abstract class BaseRepository<T, CreateDTO, UpdateDTO>
  implements IBaseRepository<T, CreateDTO, UpdateDTO>
{
  protected abstract data: T[];
  protected abstract nextId: number;

  async findAll(
    options: QueryOptions = {}
  ): Promise<{ data: T[]; meta: PaginationMeta }> {
    const { page = 1, limit = 10, sortBy, sortOrder = "asc" } = options;
    let filteredData = [...this.data];

    // Apply filtering in child classes
    filteredData = await this.applyFilters(filteredData, options);

    // Apply sorting
    if (sortBy) {
      filteredData.sort((a, b) => {
        const aValue = (a as any)[sortBy];
        const bValue = (b as any)[sortBy];

        if (sortOrder === "desc") {
          return aValue < bValue ? 1 : -1;
        }
        return aValue > bValue ? 1 : -1;
      });
    }

    // Apply pagination
    const total = filteredData.length;
    const totalPages = Math.ceil(total / limit);
    const offset = (page - 1) * limit;
    const paginatedData = filteredData.slice(offset, offset + limit);

    const meta: PaginationMeta = {
      page,
      limit,
      total,
      totalPages,
      hasNext: page < totalPages,
      hasPrev: page > 1,
    };

    return { data: paginatedData, meta };
  }

  async findById(id: number): Promise<T | null> {
    const item = this.data.find((item: any) => item.id === id);
    return item || null;
  }

  abstract create(data: CreateDTO): Promise<T>;
  abstract update(id: number, data: UpdateDTO): Promise<T | null>;

  async delete(id: number): Promise<boolean> {
    const index = this.data.findIndex((item: any) => item.id === id);
    if (index === -1) return false;

    this.data.splice(index, 1);
    return true;
  }

  async count(filters?: any): Promise<number> {
    return this.data.length;
  }

  protected abstract applyFilters(
    data: T[],
    options: QueryOptions
  ): Promise<T[]>;
}
```

Create `src/services/base.service.ts`:

```typescript
import { QueryOptions, PaginationMeta } from "../types/common.types";
import { IBaseRepository } from "../repositories/base.repository";

export abstract class BaseService<T, CreateDTO, UpdateDTO> {
  constructor(protected repository: IBaseRepository<T, CreateDTO, UpdateDTO>) {}

  async getAll(
    options?: QueryOptions
  ): Promise<{ data: T[]; meta: PaginationMeta }> {
    return await this.repository.findAll(options);
  }

  async getById(id: number): Promise<T | null> {
    return await this.repository.findById(id);
  }

  async create(data: CreateDTO): Promise<T> {
    await this.validateCreate(data);
    return await this.repository.create(data);
  }

  async update(id: number, data: UpdateDTO): Promise<T | null> {
    const existing = await this.repository.findById(id);
    if (!existing) return null;

    await this.validateUpdate(id, data);
    return await this.repository.update(id, data);
  }

  async delete(id: number): Promise<boolean> {
    const existing = await this.repository.findById(id);
    if (!existing) return false;

    await this.validateDelete(id);
    return await this.repository.delete(id);
  }

  protected abstract validateCreate(data: CreateDTO): Promise<void>;
  protected abstract validateUpdate(id: number, data: UpdateDTO): Promise<void>;
  protected abstract validateDelete(id: number): Promise<void>;
}
```

Create `src/controllers/base.controller.ts`:

```typescript
import { Request, Response, NextFunction } from "express";
import { ResponseUtil } from "../utils/response.util";
import { logger } from "../utils/logger.util";
import { QueryOptions } from "../types/common.types";
import { HTTP_STATUS } from "../constants/http-status";

export abstract class BaseController {
  protected async handleAsync(
    fn: (req: Request, res: Response, next: NextFunction) => Promise<any>
  ) {
    return (req: Request, res: Response, next: NextFunction) => {
      Promise.resolve(fn(req, res, next)).catch(next);
    };
  }

  protected getQueryOptions(req: Request): QueryOptions {
    const { page, limit, sortBy, sortOrder, search } = req.query;

    return {
      page: page ? parseInt(page as string) : undefined,
      limit: limit ? parseInt(limit as string) : undefined,
      sortBy: sortBy as string,
      sortOrder: sortOrder as "asc" | "desc",
      search: search as string,
    };
  }

  protected logAction(action: string, userId?: number, meta?: any): void {
    logger.info(`Controller action: ${action}`, {
      userId,
      action,
      ...meta,
    });
  }

  protected handleNotFound(res: Response, resource: string): Response {
    return ResponseUtil.notFound(res, resource);
  }

  protected handleValidationError(
    res: Response,
    message: string,
    errors?: string
  ): Response {
    return ResponseUtil.validationError(res, message, errors);
  }

  protected handleSuccess<T>(
    res: Response,
    message: string,
    data?: T,
    statusCode: number = HTTP_STATUS.OK
  ): Response {
    return ResponseUtil.success(res, message, data, statusCode);
  }
}
```

### Step 5: User Domain Implementation

Create `src/repositories/user.repository.ts`:

```typescript
import { BaseRepository } from "./base.repository";
import {
  User,
  CreateUserRequest,
  UpdateUserRequest,
  UserRole,
  UserFilterOptions,
} from "../types/user.types";
import { QueryOptions } from "../types/common.types";
import bcrypt from "bcryptjs";

export class UserRepository extends BaseRepository<
  User,
  CreateUserRequest,
  UpdateUserRequest
> {
  protected data: User[] = [
    {
      id: 1,
      firstName: "John",
      lastName: "Doe",
      email: "john@example.com",
      password: "$2b$10$XzPiW7.VRGy5vC8Dz.123.qwerty123456", // 'password123'
      role: UserRole.ADMIN,
      isActive: true,
      createdAt: new Date("2023-01-01"),
      updatedAt: new Date("2023-01-01"),
    },
    {
      id: 2,
      firstName: "Jane",
      lastName: "Smith",
      email: "jane@example.com",
      password: "$2b$10$XzPiW7.VRGy5vC8Dz.123.qwerty123456", // 'password123'
      role: UserRole.USER,
      isActive: true,
      createdAt: new Date("2023-01-02"),
      updatedAt: new Date("2023-01-02"),
    },
    {
      id: 3,
      firstName: "Bob",
      lastName: "Wilson",
      email: "bob@example.com",
      password: "$2b$10$XzPiW7.VRGy5vC8Dz.123.qwerty123456", // 'password123'
      role: UserRole.MODERATOR,
      isActive: false,
      createdAt: new Date("2023-01-03"),
      updatedAt: new Date("2023-01-03"),
    },
  ];
  protected nextId: number = 4;

  async create(data: CreateUserRequest): Promise<User> {
    const hashedPassword = await bcrypt.hash(data.password, 10);

    const newUser: User = {
      id: this.nextId++,
      firstName: data.firstName,
      lastName: data.lastName,
      email: data.email,
      password: hashedPassword,
      role: data.role || UserRole.USER,
      isActive: true,
      createdAt: new Date(),
      updatedAt: new Date(),
    };

    this.data.push(newUser);
    return newUser;
  }

  async update(id: number, data: UpdateUserRequest): Promise<User | null> {
    const userIndex = this.data.findIndex((user) => user.id === id);
    if (userIndex === -1) return null;

    const updatedUser: User = {
      ...this.data[userIndex],
      ...data,
      updatedAt: new Date(),
    };

    this.data[userIndex] = updatedUser;
    return updatedUser;
  }

  async findByEmail(email: string): Promise<User | null> {
    return this.data.find((user) => user.email === email) || null;
  }

  protected async applyFilters(
    data: User[],
    options: QueryOptions
  ): Promise<User[]> {
    let filteredData = [...data];
    const { search } = options;

    // Apply search filter
    if (search) {
      const searchLower = search.toLowerCase();
      filteredData = filteredData.filter(
        (user) =>
          user.firstName.toLowerCase().includes(searchLower) ||
          user.lastName.toLowerCase().includes(searchLower) ||
          user.email.toLowerCase().includes(searchLower)
      );
    }

    return filteredData;
  }

  async findByFilters(
    filters: UserFilterOptions,
    options?: QueryOptions
  ): Promise<{ data: User[]; meta: any }> {
    let filteredData = [...this.data];

    if (filters.role) {
      filteredData = filteredData.filter((user) => user.role === filters.role);
    }

    if (filters.isActive !== undefined) {
      filteredData = filteredData.filter(
        (user) => user.isActive === filters.isActive
      );
    }

    if (filters.search) {
      const searchLower = filters.search.toLowerCase();
      filteredData = filteredData.filter(
        (user) =>
          user.firstName.toLowerCase().includes(searchLower) ||
          user.lastName.toLowerCase().includes(searchLower) ||
          user.email.toLowerCase().includes(searchLower)
      );
    }

    // Apply pagination
    const { page = 1, limit = 10 } = options || {};
    const total = filteredData.length;
    const totalPages = Math.ceil(total / limit);
    const offset = (page - 1) * limit;
    const paginatedData = filteredData.slice(offset, offset + limit);

    const meta = {
      page,
      limit,
      total,
      totalPages,
      hasNext: page < totalPages,
      hasPrev: page > 1,
    };

    return { data: paginatedData, meta };
  }
}
```

Create `src/services/user.service.ts`:

```typescript
import { BaseService } from "./base.service";
import { UserRepository } from "../repositories/user.repository";
import {
  User,
  CreateUserRequest,
  UpdateUserRequest,
  UserFilterOptions,
  AuthUser,
} from "../types/user.types";
import { QueryOptions } from "../types/common.types";
import bcrypt from "bcryptjs";
import jwt from "jsonwebtoken";

export class UserService extends BaseService<
  User,
  CreateUserRequest,
  UpdateUserRequest
> {
  private userRepository: UserRepository;

  constructor(userRepository: UserRepository) {
    super(userRepository);
    this.userRepository = userRepository;
  }

  async getUsersByFilters(filters: UserFilterOptions, options?: QueryOptions) {
    return await this.userRepository.findByFilters(filters, options);
  }

  async getUserByEmail(email: string): Promise<User | null> {
    return await this.userRepository.findByEmail(email);
  }

  async authenticateUser(
    email: string,
    password: string
  ): Promise<{ user: AuthUser; token: string } | null> {
    const user = await this.userRepository.findByEmail(email);
    if (!user || !user.isActive) return null;

    const isPasswordValid = await bcrypt.compare(password, user.password);
    if (!isPasswordValid) return null;

    const authUser: AuthUser = {
      id: user.id,
      email: user.email,
      firstName: user.firstName,
      lastName: user.lastName,
      role: user.role,
    };

    const token = jwt.sign({ userId: user.id }, process.env.JWT_SECRET!, {
      expiresIn: process.env.JWT_EXPIRES_IN || "7d",
    });

    return { user: authUser, token };
  }

  async changePassword(
    userId: number,
    currentPassword: string,
    newPassword: string
  ): Promise<boolean> {
    const user = await this.userRepository.findById(userId);
    if (!user) return false;

    const isCurrentPasswordValid = await bcrypt.compare(
      currentPassword,
      user.password
    );
    if (!isCurrentPasswordValid) return false;

    const hashedNewPassword = await bcrypt.hash(newPassword, 10);
    await this.userRepository.update(userId, {
      password: hashedNewPassword,
    } as UpdateUserRequest);

    return true;
  }

  protected async validateCreate(data: CreateUserRequest): Promise<void> {
    const existingUser = await this.userRepository.findByEmail(data.email);
    if (existingUser) {
      throw new Error("User with this email already exists");
    }
  }

  protected async validateUpdate(
    id: number,
    data: UpdateUserRequest
  ): Promise<void> {
    if (data.email) {
      const existingUser = await this.userRepository.findByEmail(data.email);
      if (existingUser && existingUser.id !== id) {
        throw new Error("Email is already in use by another user");
      }
    }
  }

  protected async validateDelete(id: number): Promise<void> {
    // Add business logic here, e.g., prevent deleting admin users
    const user = await this.userRepository.findById(id);
    if (user && user.role === "admin") {
      throw new Error("Cannot delete admin users");
    }
  }

  // Utility method to exclude password from user objects
  excludePassword(user: User): Omit<User, "password"> {
    const { password, ...userWithoutPassword } = user;
    return userWithoutPassword;
  }

  excludePasswordFromArray(users: User[]): Omit<User, "password">[] {
    return users.map((user) => this.excludePassword(user));
  }
}
```

Create `src/controllers/user.controller.ts`:

```typescript
import { Request, Response, NextFunction } from "express";
import { BaseController } from "./base.controller";
import { UserService } from "../services/user.service";
import {
  CreateUserRequest,
  UpdateUserRequest,
  LoginRequest,
  UserRole,
  UserFilterOptions,
} from "../types/user.types";
import { ResponseUtil } from "../utils/response.util";
import { HTTP_STATUS } from "../constants/http-status";

export class UserController extends BaseController {
  constructor(private userService: UserService) {
    super();
  }

  getUsers = this.handleAsync(async (req: Request, res: Response) => {
    const options = this.getQueryOptions(req);
    const { role, isActive } = req.query;

    const filters: UserFilterOptions = {
      role: role as UserRole,
      isActive: isActive ? isActive === "true" : undefined,
      search: options.search,
    };

    const result = await this.userService.getUsersByFilters(filters, options);
    const usersWithoutPassword = this.userService.excludePasswordFromArray(
      result.data
    );

    this.logAction("get_users", req.user?.id, {
      filters,
      count: result.data.length,
    });

    return ResponseUtil.success(
      res,
      "Users retrieved successfully",
      { users: usersWithoutPassword },
      HTTP_STATUS.OK,
      result.meta
    );
  });

  getUserById = this.handleAsync(async (req: Request, res: Response) => {
    const userId = parseInt(req.params.id);
    const user = await this.userService.getById(userId);

    if (!user) {
      return this.handleNotFound(res, "User");
    }

    const userWithoutPassword = this.userService.excludePassword(user);
    this.logAction("get_user_by_id", req.user?.id, { targetUserId: userId });

    return this.handleSuccess(res, "User retrieved successfully", {
      user: userWithoutPassword,
    });
  });

  createUser = this.handleAsync(
    async (req: Request<{}, {}, CreateUserRequest>, res: Response) => {
      try {
        const userData = req.body;
        const newUser = await this.userService.create(userData);
        const userWithoutPassword = this.userService.excludePassword(newUser);

        this.logAction("create_user", req.user?.id, {
          newUserId: newUser.id,
          email: newUser.email,
        });

        return ResponseUtil.created(res, "User created successfully", {
          user: userWithoutPassword,
        });
      } catch (error) {
        if (error instanceof Error) {
          return ResponseUtil.conflict(res, error.message);
        }
        throw error;
      }
    }
  );

  updateUser = this.handleAsync(
    async (
      req: Request<{ id: string }, {}, UpdateUserRequest>,
      res: Response
    ) => {
      try {
        const userId = parseInt(req.params.id);
        const updateData = req.body;

        // Check if user is trying to update themselves or has admin privileges
        if (req.user?.id !== userId && req.user?.role !== UserRole.ADMIN) {
          return ResponseUtil.forbidden(
            res,
            "You can only update your own profile"
          );
        }

        const updatedUser = await this.userService.update(userId, updateData);

        if (!updatedUser) {
          return this.handleNotFound(res, "User");
        }

        const userWithoutPassword =
          this.userService.excludePassword(updatedUser);
        this.logAction("update_user", req.user?.id, {
          targetUserId: userId,
          updatedFields: Object.keys(updateData),
        });

        return this.handleSuccess(res, "User updated successfully", {
          user: userWithoutPassword,
        });
      } catch (error) {
        if (error instanceof Error) {
          return ResponseUtil.conflict(res, error.message);
        }
        throw error;
      }
    }
  );

  deleteUser = this.handleAsync(async (req: Request, res: Response) => {
    try {
      const userId = parseInt(req.params.id);

      // Only admins can delete users
      if (req.user?.role !== UserRole.ADMIN) {
        return ResponseUtil.forbidden(
          res,
          "Only administrators can delete users"
        );
      }

      // Prevent self-deletion
      if (req.user?.id === userId) {
        return ResponseUtil.forbidden(
          res,
          "You cannot delete your own account"
        );
      }

      const deleted = await this.userService.delete(userId);

      if (!deleted) {
        return this.handleNotFound(res, "User");
      }

      this.logAction("delete_user", req.user?.id, { deletedUserId: userId });

      return ResponseUtil.success(res, "User deleted successfully");
    } catch (error) {
      if (error instanceof Error) {
        return ResponseUtil.conflict(res, error.message);
      }
      throw error;
    }
  });

  loginUser = this.handleAsync(
    async (req: Request<{}, {}, LoginRequest>, res: Response) => {
      const { email, password } = req.body;

      const result = await this.userService.authenticateUser(email, password);

      if (!result) {
        return ResponseUtil.unauthorized(res, "Invalid email or password");
      }

      this.logAction("user_login", result.user.id, { email });

      return this.handleSuccess(res, "Login successful", result);
    }
  );

  getCurrentUser = this.handleAsync(async (req: Request, res: Response) => {
    const userId = req.user!.id;
    const user = await this.userService.getById(userId);

    if (!user) {
      return this.handleNotFound(res, "User");
    }

    const userWithoutPassword = this.userService.excludePassword(user);
    return this.handleSuccess(res, "Current user retrieved successfully", {
      user: userWithoutPassword,
    });
  });

  changePassword = this.handleAsync(
    async (
      req: Request<{}, {}, { currentPassword: string; newPassword: string }>,
      res: Response
    ) => {
      const userId = req.user!.id;
      const { currentPassword, newPassword } = req.body;

      const success = await this.userService.changePassword(
        userId,
        currentPassword,
        newPassword
      );

      if (!success) {
        return ResponseUtil.unauthorized(res, "Current password is incorrect");
      }

      this.logAction("change_password", userId);

      return this.handleSuccess(res, "Password changed successfully");
    }
  );
}
```

### Step 6: Routes and Middleware Setup

Create `src/routes/user.routes.ts`:

```typescript
import { Router } from "express";
import { UserController } from "../controllers/user.controller";
import { UserService } from "../services/user.service";
import { UserRepository } from "../repositories/user.repository";
import { authenticateToken, requireRole } from "../middleware/auth.middleware";
import { validate } from "../middleware/validation.middleware";
import { schemas } from "../utils/validator.util";
import { UserRole } from "../types/user.types";

const router = Router();

// Initialize dependencies
const userRepository = new UserRepository();
const userService = new UserService(userRepository);
const userController = new UserController(userService);

// Public routes
router.post("/login", validate(schemas.login), userController.loginUser);
router.post(
  "/register",
  validate(schemas.createUser),
  userController.createUser
);

// Protected routes (require authentication)
router.use(authenticateToken); // All routes below require authentication

router.get("/profile", userController.getCurrentUser);
router.put("/profile", validate(schemas.updateUser), userController.updateUser);
router.put(
  "/change-password",
  validate(schemas.changePassword),
  userController.changePassword
);

// Admin-only routes
router.get(
  "/",
  requireRole([UserRole.ADMIN, UserRole.MODERATOR]),
  userController.getUsers
);
router.get(
  "/:id",
  requireRole([UserRole.ADMIN, UserRole.MODERATOR]),
  userController.getUserById
);
router.put("/:id", requireRole([UserRole.ADMIN]), userController.updateUser);
router.delete("/:id", requireRole([UserRole.ADMIN]), userController.deleteUser);

export default router;
```

Create `src/utils/validator.util.ts` with updated schemas:

```typescript
import Joi from "joi";
import { UserRole } from "../types/user.types";

export const schemas = {
  createUser: Joi.object({
    firstName: Joi.string().min(2).max(50).required(),
    lastName: Joi.string().min(2).max(50).required(),
    email: Joi.string().email().required(),
    password: Joi.string()
      .min(6)
      .pattern(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/)
      .required(),
    role: Joi.string()
      .valid(...Object.values(UserRole))
      .optional(),
  }),

  updateUser: Joi.object({
    firstName: Joi.string().min(2).max(50).optional(),
    lastName: Joi.string().min(2).max(50).optional(),
    email: Joi.string().email().optional(),
    role: Joi.string()
      .valid(...Object.values(UserRole))
      .optional(),
    isActive: Joi.boolean().optional(),
  }).min(1),

  login: Joi.object({
    email: Joi.string().email().required(),
    password: Joi.string().required(),
  }),

  changePassword: Joi.object({
    currentPassword: Joi.string().required(),
    newPassword: Joi.string()
      .min(6)
      .pattern(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/)
      .required(),
  }),

  userId: Joi.object({
    id: Joi.number().integer().positive().required(),
  }),
};
```

Update the middleware files accordingly, and create `src/app.ts` to tie everything together:

```typescript
import express from "express";
import cors from "cors";
import helmet from "helmet";
import dotenv from "dotenv";
import userRoutes from "./routes/user.routes";
import { errorHandler, notFoundHandler } from "./middleware/error.middleware";
import { requestLogger } from "./middleware/logging.middleware";

dotenv.config();

const app = express();

// Security middleware
app.use(helmet());
app.use(cors());

// Body parsing middleware
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// Request logging
app.use(requestLogger);

// API routes
app.use("/api/v1/users", userRoutes);

// Health check
app.get("/health", (req, res) => {
  res.json({
    status: "OK",
    timestamp: new Date().toISOString(),
    environment: process.env.NODE_ENV,
  });
});

// Error handling
app.use(notFoundHandler);
app.use(errorHandler);

export default app;
```

## Architecture Benefits Demonstrated

### 1. **Clear Separation of Concerns**

- **Routes**: Handle HTTP routing and middleware application
- **Controllers**: Manage HTTP requests/responses and orchestration
- **Services**: Contain business logic and domain rules
- **Repositories**: Abstract data access and provide query interface

### 2. **Reusability and Testability**

- Each layer can be tested independently
- Business logic is separated from HTTP concerns
- Data access is abstracted from business logic

### 3. **Maintainability**

- Easy to add new features following established patterns
- Changes in one layer don't affect others
- Consistent structure across the application

### 4. **Type Safety**

- Strong typing throughout all layers
- Clear interfaces and contracts
- Compile-time error checking

This structured approach provides a solid foundation for building scalable Express.js applications that are easy to maintain, test, and extend.

---

## References and Resources

### Architecture Patterns

- [Clean Architecture by Robert Martin](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)
- [Layered Architecture Pattern](https://docs.microsoft.com/en-us/azure/architecture/guide/architecture-styles/n-tier)
- [Domain-Driven Design](https://martinfowler.com/bliki/DomainDrivenDesign.html)

### Express.js Best Practices

- [Express.js Best Practices](https://expressjs.com/en/advanced/best-practice-security.html)
- [Node.js Best Practices](https://github.com/goldbergyoni/nodebestpractices)
- [RESTful API Design](https://restfulapi.net/)

### TypeScript and Design Patterns

- [TypeScript Handbook](https://www.typescriptlang.org/docs/)
- [Repository Pattern](https://martinfowler.com/eaaCatalog/repository.html)
- [Service Layer Pattern](https://martinfowler.com/eaaCatalog/serviceLayer.html)

### Testing and Validation

- [Joi Validation Documentation](https://joi.dev/api/)
- [Jest Testing Framework](https://jestjs.io/docs/getting-started)
- [Express.js Testing](https://expressjs.com/en/guide/testing.html)
