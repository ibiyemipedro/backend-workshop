# Extending the Express Application

## Overview

Building on our simple Express application, we'll now create a more structured, multi-file application using key libraries and middleware. This exercise demonstrates how to scale an Express app beyond a single file while maintaining simplicity.

## Learning Objectives

- Organize Express apps with multiple files and folders
- Integrate essential middleware libraries
- Implement proper error handling
- Add input validation and security
- Use environment configuration
- Structure code for maintainability

## Exercise: Enhanced Task Manager API

We'll extend our previous task manager to demonstrate real-world Express.js patterns and libraries.

### Step 1: Project Structure Setup

Create the following folder structure:

```
enhanced-express-app/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ app.ts                  # Main application
â”‚   â”œâ”€â”€ server.ts               # Server startup
â”‚   â”œâ”€â”€ config/
â”‚   â”‚   â””â”€â”€ database.ts         # Database configuration
â”‚   â”œâ”€â”€ middleware/
â”‚   â”‚   â”œâ”€â”€ auth.ts             # Authentication middleware
â”‚   â”‚   â”œâ”€â”€ validation.ts       # Validation middleware
â”‚   â”‚   â””â”€â”€ errorHandler.ts     # Error handling middleware
â”‚   â”œâ”€â”€ routes/
â”‚   â”‚   â”œâ”€â”€ index.ts            # Route aggregator
â”‚   â”‚   â”œâ”€â”€ tasks.ts            # Task routes
â”‚   â”‚   â””â”€â”€ auth.ts             # Authentication routes
â”‚   â”œâ”€â”€ utils/
â”‚   â”‚   â”œâ”€â”€ logger.ts           # Logging utility
â”‚   â”‚   â”œâ”€â”€ response.ts         # Response utilities
â”‚   â”‚   â””â”€â”€ validator.ts        # Validation schemas
â”‚   â””â”€â”€ types/
â”‚       â””â”€â”€ index.ts            # Type definitions
â”œâ”€â”€ .env                        # Environment variables
â”œâ”€â”€ package.json
â””â”€â”€ tsconfig.json
```

### Step 2: Install Key Libraries

```bash
npm init -y
npm install express cors helmet morgan joi bcryptjs jsonwebtoken dotenv
npm install -D @types/express @types/cors @types/morgan @types/bcryptjs @types/jsonwebtoken @types/node typescript ts-node nodemon
```

### Step 3: Environment Configuration

Create `.env` file:

```env
NODE_ENV=development
PORT=3000
JWT_SECRET=your_jwt_secret_key_here
JWT_EXPIRES_IN=7d
LOG_LEVEL=info
```

Create `src/types/index.ts`:

```typescript
export interface Task {
  id: number;
  title: string;
  description: string;
  completed: boolean;
  userId?: number;
  createdAt: Date;
  updatedAt: Date;
}

export interface User {
  id: number;
  email: string;
  password: string;
  name: string;
  createdAt: Date;
}

export interface AuthUser {
  id: number;
  email: string;
  name: string;
}

export interface CreateTaskRequest {
  title: string;
  description: string;
}

export interface UpdateTaskRequest {
  title?: string;
  description?: string;
  completed?: boolean;
}

export interface RegisterRequest {
  email: string;
  password: string;
  name: string;
}

export interface LoginRequest {
  email: string;
  password: string;
}

declare global {
  namespace Express {
    interface Request {
      user?: AuthUser;
    }
  }
}
```

### Step 4: Utility Functions

Create `src/utils/logger.ts`:

```typescript
import { Request, Response } from "express";

export enum LogLevel {
  ERROR = "error",
  WARN = "warn",
  INFO = "info",
  DEBUG = "debug",
}

class Logger {
  private logLevel: LogLevel;

  constructor() {
    this.logLevel = (process.env.LOG_LEVEL as LogLevel) || LogLevel.INFO;
  }

  private shouldLog(level: LogLevel): boolean {
    const levels = [
      LogLevel.ERROR,
      LogLevel.WARN,
      LogLevel.INFO,
      LogLevel.DEBUG,
    ];
    const currentLevelIndex = levels.indexOf(this.logLevel);
    const messageLevelIndex = levels.indexOf(level);
    return messageLevelIndex <= currentLevelIndex;
  }

  private log(level: LogLevel, message: string, meta?: any): void {
    if (!this.shouldLog(level)) return;

    const timestamp = new Date().toISOString();
    const logEntry = {
      timestamp,
      level,
      message,
      ...(meta && { meta }),
    };

    console.log(JSON.stringify(logEntry));
  }

  error(message: string, meta?: any): void {
    this.log(LogLevel.ERROR, message, meta);
  }

  warn(message: string, meta?: any): void {
    this.log(LogLevel.WARN, message, meta);
  }

  info(message: string, meta?: any): void {
    this.log(LogLevel.INFO, message, meta);
  }

  debug(message: string, meta?: any): void {
    this.log(LogLevel.DEBUG, message, meta);
  }

  request(req: Request, res: Response): void {
    const start = Date.now();
    res.on("finish", () => {
      const duration = Date.now() - start;
      this.info("HTTP Request", {
        method: req.method,
        url: req.originalUrl,
        status: res.statusCode,
        duration: `${duration}ms`,
        userAgent: req.headers["user-agent"],
        ip: req.ip,
      });
    });
  }
}

export const logger = new Logger();
```

Create `src/utils/response.ts`:

```typescript
import { Response } from "express";

export interface ApiResponse<T = any> {
  success: boolean;
  message: string;
  data?: T;
  error?: string;
  timestamp: string;
}

export class ResponseUtil {
  static success<T>(
    res: Response,
    message: string,
    data?: T,
    statusCode: number = 200
  ): Response {
    const response: ApiResponse<T> = {
      success: true,
      message,
      data,
      timestamp: new Date().toISOString(),
    };
    return res.status(statusCode).json(response);
  }

  static error(
    res: Response,
    message: string,
    statusCode: number = 400,
    error?: string
  ): Response {
    const response: ApiResponse = {
      success: false,
      message,
      error,
      timestamp: new Date().toISOString(),
    };
    return res.status(statusCode).json(response);
  }

  static created<T>(res: Response, message: string, data: T): Response {
    return this.success(res, message, data, 201);
  }

  static notFound(res: Response, resource: string = "Resource"): Response {
    return this.error(res, `${resource} not found`, 404);
  }

  static unauthorized(
    res: Response,
    message: string = "Unauthorized"
  ): Response {
    return this.error(res, message, 401);
  }

  static forbidden(res: Response, message: string = "Forbidden"): Response {
    return this.error(res, message, 403);
  }

  static conflict(res: Response, message: string): Response {
    return this.error(res, message, 409);
  }

  static internalError(
    res: Response,
    message: string = "Internal server error"
  ): Response {
    return this.error(res, message, 500);
  }
}
```

Create `src/utils/validator.ts`:

```typescript
import Joi from "joi";

export const schemas = {
  createTask: Joi.object({
    title: Joi.string().min(3).max(100).required().messages({
      "string.min": "Title must be at least 3 characters long",
      "string.max": "Title cannot exceed 100 characters",
      "any.required": "Title is required",
    }),
    description: Joi.string().min(10).max(500).required().messages({
      "string.min": "Description must be at least 10 characters long",
      "string.max": "Description cannot exceed 500 characters",
      "any.required": "Description is required",
    }),
  }),

  updateTask: Joi.object({
    title: Joi.string().min(3).max(100).optional(),
    description: Joi.string().min(10).max(500).optional(),
    completed: Joi.boolean().optional(),
  })
    .min(1)
    .messages({
      "object.min": "At least one field must be provided for update",
    }),

  register: Joi.object({
    email: Joi.string().email().required().messages({
      "string.email": "Please provide a valid email address",
      "any.required": "Email is required",
    }),
    password: Joi.string()
      .min(6)
      .pattern(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/)
      .required()
      .messages({
        "string.min": "Password must be at least 6 characters long",
        "string.pattern.base":
          "Password must contain at least one lowercase letter, one uppercase letter, and one number",
        "any.required": "Password is required",
      }),
    name: Joi.string().min(2).max(50).required().messages({
      "string.min": "Name must be at least 2 characters long",
      "string.max": "Name cannot exceed 50 characters",
      "any.required": "Name is required",
    }),
  }),

  login: Joi.object({
    email: Joi.string().email().required(),
    password: Joi.string().required(),
  }),

  taskId: Joi.object({
    id: Joi.number().integer().positive().required(),
  }),
};
```

### Step 5: Middleware Implementation

Create `src/middleware/validation.ts`:

```typescript
import { Request, Response, NextFunction } from "express";
import Joi from "joi";
import { ResponseUtil } from "../utils/response";
import { logger } from "../utils/logger";

export const validate = (
  schema: Joi.ObjectSchema,
  property: "body" | "params" | "query" = "body"
) => {
  return (req: Request, res: Response, next: NextFunction): void => {
    const { error, value } = schema.validate(req[property]);

    if (error) {
      const errorMessage = error.details
        .map((detail) => detail.message)
        .join(", ");
      logger.warn("Validation failed", {
        property,
        error: errorMessage,
        receivedData: req[property],
      });
      ResponseUtil.error(res, "Validation failed", 400, errorMessage);
      return;
    }

    req[property] = value;
    next();
  };
};

export const validateTaskId = validate(
  Joi.object({ id: Joi.number().integer().positive().required() }),
  "params"
);
```

Create `src/middleware/auth.ts`:

```typescript
import { Request, Response, NextFunction } from "express";
import jwt from "jsonwebtoken";
import { ResponseUtil } from "../utils/response";
import { logger } from "../utils/logger";
import { AuthUser } from "../types";

// Mock user database
const users = [
  {
    id: 1,
    email: "user@example.com",
    name: "John Doe",
    password: "$2b$10$hash",
  },
  {
    id: 2,
    email: "admin@example.com",
    name: "Jane Smith",
    password: "$2b$10$hash",
  },
];

export const authenticateToken = (
  req: Request,
  res: Response,
  next: NextFunction
): void => {
  const authHeader = req.headers.authorization;
  const token = authHeader && authHeader.split(" ")[1];

  if (!token) {
    logger.warn("Authentication failed - No token provided", {
      ip: req.ip,
      userAgent: req.headers["user-agent"],
    });
    ResponseUtil.unauthorized(res, "Access token is required");
    return;
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET!) as any;
    const user = users.find((u) => u.id === decoded.userId);

    if (!user) {
      ResponseUtil.unauthorized(res, "Invalid token - user not found");
      return;
    }

    req.user = {
      id: user.id,
      email: user.email,
      name: user.name,
    };

    logger.debug("Authentication successful", {
      userId: user.id,
      email: user.email,
    });

    next();
  } catch (error) {
    logger.warn("Authentication failed - Invalid token", {
      error: error instanceof Error ? error.message : "Unknown error",
      token: token.substring(0, 20) + "...",
    });
    ResponseUtil.unauthorized(res, "Invalid or expired token");
  }
};

export const optionalAuth = (
  req: Request,
  res: Response,
  next: NextFunction
): void => {
  const authHeader = req.headers.authorization;
  const token = authHeader && authHeader.split(" ")[1];

  if (!token) {
    return next();
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET!) as any;
    const user = users.find((u) => u.id === decoded.userId);

    if (user) {
      req.user = {
        id: user.id,
        email: user.email,
        name: user.name,
      };
    }
  } catch (error) {
    // For optional auth, we don't fail on invalid tokens
    logger.debug("Optional auth - Invalid token provided");
  }

  next();
};
```

Create `src/middleware/errorHandler.ts`:

```typescript
import { Request, Response, NextFunction } from "express";
import { logger } from "../utils/logger";
import { ResponseUtil } from "../utils/response";

export interface AppError extends Error {
  statusCode?: number;
  isOperational?: boolean;
}

export const errorHandler = (
  err: AppError,
  req: Request,
  res: Response,
  next: NextFunction
): void => {
  logger.error("Error occurred", {
    message: err.message,
    stack: err.stack,
    url: req.originalUrl,
    method: req.method,
    ip: req.ip,
    userAgent: req.headers["user-agent"],
  });

  // Default to 500 server error
  let statusCode = err.statusCode || 500;
  let message = err.message || "Internal Server Error";

  // Handle specific error types
  if (err.name === "ValidationError") {
    statusCode = 400;
    message = "Validation Error";
  } else if (err.name === "JsonWebTokenError") {
    statusCode = 401;
    message = "Invalid token";
  } else if (err.name === "TokenExpiredError") {
    statusCode = 401;
    message = "Token expired";
  }

  // Don't leak error details in production
  if (process.env.NODE_ENV === "production" && statusCode === 500) {
    message = "Internal Server Error";
  }

  ResponseUtil.error(
    res,
    message,
    statusCode,
    process.env.NODE_ENV === "development" ? err.stack : undefined
  );
};

export const notFoundHandler = (req: Request, res: Response): void => {
  logger.warn("Route not found", {
    url: req.originalUrl,
    method: req.method,
    ip: req.ip,
  });

  ResponseUtil.notFound(res, `Route ${req.originalUrl} not found`);
};
```

### Step 6: Route Implementation

Create `src/routes/auth.ts`:

```typescript
import { Router, Request, Response, NextFunction } from "express";
import bcrypt from "bcryptjs";
import jwt from "jsonwebtoken";
import { validate } from "../middleware/validation";
import { schemas } from "../utils/validator";
import { ResponseUtil } from "../utils/response";
import { logger } from "../utils/logger";
import { RegisterRequest, LoginRequest } from "../types";

const router = Router();

// Mock user database
let users = [
  {
    id: 1,
    email: "user@example.com",
    name: "John Doe",
    password: "$2b$10$XzPiW7.VRGy5vC8Dz.123.qwerty123456", // 'password123'
  },
];
let nextUserId = 2;

const generateToken = (userId: number): string => {
  return jwt.sign({ userId }, process.env.JWT_SECRET!, {
    expiresIn: process.env.JWT_EXPIRES_IN,
  });
};

// Register endpoint
router.post(
  "/register",
  validate(schemas.register),
  async (
    req: Request<{}, {}, RegisterRequest>,
    res: Response,
    next: NextFunction
  ) => {
    try {
      const { email, password, name } = req.body;

      // Check if user already exists
      const existingUser = users.find((u) => u.email === email);
      if (existingUser) {
        return ResponseUtil.conflict(
          res,
          "User already exists with this email"
        );
      }

      // Hash password
      const hashedPassword = await bcrypt.hash(password, 10);

      // Create user
      const newUser = {
        id: nextUserId++,
        email,
        name,
        password: hashedPassword,
      };

      users.push(newUser);

      // Generate token
      const token = generateToken(newUser.id);

      logger.info("User registered successfully", {
        userId: newUser.id,
        email: newUser.email,
      });

      ResponseUtil.created(res, "User registered successfully", {
        user: {
          id: newUser.id,
          email: newUser.email,
          name: newUser.name,
        },
        token,
      });
    } catch (error) {
      next(error);
    }
  }
);

// Login endpoint
router.post(
  "/login",
  validate(schemas.login),
  async (
    req: Request<{}, {}, LoginRequest>,
    res: Response,
    next: NextFunction
  ) => {
    try {
      const { email, password } = req.body;

      // Find user
      const user = users.find((u) => u.email === email);
      if (!user) {
        return ResponseUtil.unauthorized(res, "Invalid email or password");
      }

      // Check password
      const isValidPassword = await bcrypt.compare(password, user.password);
      if (!isValidPassword) {
        logger.warn("Login attempt with invalid password", {
          email,
          ip: req.ip,
        });
        return ResponseUtil.unauthorized(res, "Invalid email or password");
      }

      // Generate token
      const token = generateToken(user.id);

      logger.info("User logged in successfully", {
        userId: user.id,
        email: user.email,
      });

      ResponseUtil.success(res, "Login successful", {
        user: {
          id: user.id,
          email: user.email,
          name: user.name,
        },
        token,
      });
    } catch (error) {
      next(error);
    }
  }
);

export default router;
```

Create `src/routes/tasks.ts`:

```typescript
import { Router, Request, Response, NextFunction } from "express";
import { authenticateToken, optionalAuth } from "../middleware/auth";
import { validate, validateTaskId } from "../middleware/validation";
import { schemas } from "../utils/validator";
import { ResponseUtil } from "../utils/response";
import { logger } from "../utils/logger";
import { Task, CreateTaskRequest, UpdateTaskRequest } from "../types";

const router = Router();

// Mock task database
let tasks: Task[] = [
  {
    id: 1,
    title: "Learn Express.js",
    description: "Build a comprehensive Express application",
    completed: false,
    userId: 1,
    createdAt: new Date(),
    updatedAt: new Date(),
  },
  {
    id: 2,
    title: "Setup middleware",
    description: "Implement authentication and validation middleware",
    completed: true,
    userId: 1,
    createdAt: new Date(),
    updatedAt: new Date(),
  },
];
let nextTaskId = 3;

// Get all tasks (with optional authentication for user-specific tasks)
router.get(
  "/",
  optionalAuth,
  (req: Request, res: Response, next: NextFunction) => {
    try {
      const { completed, search } = req.query;
      let filteredTasks = tasks;

      // Filter by user if authenticated
      if (req.user) {
        filteredTasks = tasks.filter((task) => task.userId === req.user!.id);
      }

      // Filter by completion status
      if (completed !== undefined) {
        const isCompleted = completed === "true";
        filteredTasks = filteredTasks.filter(
          (task) => task.completed === isCompleted
        );
      }

      // Search in title and description
      if (search && typeof search === "string") {
        const searchTerm = search.toLowerCase();
        filteredTasks = filteredTasks.filter(
          (task) =>
            task.title.toLowerCase().includes(searchTerm) ||
            task.description.toLowerCase().includes(searchTerm)
        );
      }

      logger.info("Tasks retrieved", {
        userId: req.user?.id || "anonymous",
        count: filteredTasks.length,
        filters: { completed, search },
      });

      ResponseUtil.success(res, "Tasks retrieved successfully", {
        tasks: filteredTasks,
        count: filteredTasks.length,
      });
    } catch (error) {
      next(error);
    }
  }
);

// Get task by ID
router.get(
  "/:id",
  validateTaskId,
  optionalAuth,
  (req: Request, res: Response, next: NextFunction) => {
    try {
      const taskId = parseInt(req.params.id);
      const task = tasks.find((t) => t.id === taskId);

      if (!task) {
        return ResponseUtil.notFound(res, "Task");
      }

      // Check if user owns the task (if authenticated)
      if (req.user && task.userId !== req.user.id) {
        return ResponseUtil.forbidden(res, "Access denied to this task");
      }

      ResponseUtil.success(res, "Task retrieved successfully", { task });
    } catch (error) {
      next(error);
    }
  }
);

// Create new task (requires authentication)
router.post(
  "/",
  authenticateToken,
  validate(schemas.createTask),
  (
    req: Request<{}, {}, CreateTaskRequest>,
    res: Response,
    next: NextFunction
  ) => {
    try {
      const { title, description } = req.body;
      const userId = req.user!.id;

      const newTask: Task = {
        id: nextTaskId++,
        title,
        description,
        completed: false,
        userId,
        createdAt: new Date(),
        updatedAt: new Date(),
      };

      tasks.push(newTask);

      logger.info("Task created", {
        taskId: newTask.id,
        userId,
        title: newTask.title,
      });

      ResponseUtil.created(res, "Task created successfully", { task: newTask });
    } catch (error) {
      next(error);
    }
  }
);

// Update task (requires authentication and ownership)
router.put(
  "/:id",
  authenticateToken,
  validateTaskId,
  validate(schemas.updateTask),
  (
    req: Request<{ id: string }, {}, UpdateTaskRequest>,
    res: Response,
    next: NextFunction
  ) => {
    try {
      const taskId = parseInt(req.params.id);
      const taskIndex = tasks.findIndex((t) => t.id === taskId);

      if (taskIndex === -1) {
        return ResponseUtil.notFound(res, "Task");
      }

      // Check ownership
      if (tasks[taskIndex].userId !== req.user!.id) {
        return ResponseUtil.forbidden(res, "Access denied to this task");
      }

      const { title, description, completed } = req.body;

      // Update fields
      if (title !== undefined) tasks[taskIndex].title = title;
      if (description !== undefined) tasks[taskIndex].description = description;
      if (completed !== undefined) tasks[taskIndex].completed = completed;
      tasks[taskIndex].updatedAt = new Date();

      logger.info("Task updated", {
        taskId,
        userId: req.user!.id,
        updatedFields: Object.keys(req.body),
      });

      ResponseUtil.success(res, "Task updated successfully", {
        task: tasks[taskIndex],
      });
    } catch (error) {
      next(error);
    }
  }
);

// Delete task (requires authentication and ownership)
router.delete(
  "/:id",
  authenticateToken,
  validateTaskId,
  (req: Request, res: Response, next: NextFunction) => {
    try {
      const taskId = parseInt(req.params.id);
      const taskIndex = tasks.findIndex((t) => t.id === taskId);

      if (taskIndex === -1) {
        return ResponseUtil.notFound(res, "Task");
      }

      // Check ownership
      if (tasks[taskIndex].userId !== req.user!.id) {
        return ResponseUtil.forbidden(res, "Access denied to this task");
      }

      const deletedTask = tasks.splice(taskIndex, 1)[0];

      logger.info("Task deleted", {
        taskId,
        userId: req.user!.id,
        title: deletedTask.title,
      });

      ResponseUtil.success(res, "Task deleted successfully", {
        task: deletedTask,
      });
    } catch (error) {
      next(error);
    }
  }
);

export default router;
```

Create `src/routes/index.ts`:

```typescript
import { Router } from "express";
import taskRoutes from "./tasks";
import authRoutes from "./auth";

const router = Router();

// Health check endpoint
router.get("/health", (req, res) => {
  res.json({
    status: "OK",
    timestamp: new Date().toISOString(),
    uptime: process.uptime(),
    environment: process.env.NODE_ENV,
    version: "1.0.0",
  });
});

// API routes
router.use("/auth", authRoutes);
router.use("/tasks", taskRoutes);

export default router;
```

### Step 7: Main Application Setup

Create `src/app.ts`:

```typescript
import express from "express";
import cors from "cors";
import helmet from "helmet";
import morgan from "morgan";
import dotenv from "dotenv";

import routes from "./routes";
import { errorHandler, notFoundHandler } from "./middleware/errorHandler";
import { logger } from "./utils/logger";

// Load environment variables
dotenv.config();

// Create Express app
const app = express();

// Security middleware
app.use(helmet());

// CORS configuration
app.use(
  cors({
    origin:
      process.env.NODE_ENV === "production"
        ? ["https://yourdomain.com"]
        : [
            "http://localhost:3000",
            "http://localhost:3001",
            "http://localhost:8080",
          ],
    credentials: true,
  })
);

// Logging middleware
app.use(
  morgan("combined", {
    stream: { write: (message) => logger.info(message.trim()) },
  })
);

// Body parsing middleware
app.use(express.json({ limit: "10mb" }));
app.use(express.urlencoded({ extended: true, limit: "10mb" }));

// Request logging
app.use((req, res, next) => {
  logger.request(req, res);
  next();
});

// API routes
app.use("/api/v1", routes);

// Root endpoint
app.get("/", (req, res) => {
  res.json({
    message: "Enhanced Task Manager API",
    version: "1.0.0",
    environment: process.env.NODE_ENV,
    endpoints: {
      health: "/api/v1/health",
      auth: {
        register: "POST /api/v1/auth/register",
        login: "POST /api/v1/auth/login",
      },
      tasks: {
        getAll: "GET /api/v1/tasks",
        getById: "GET /api/v1/tasks/:id",
        create: "POST /api/v1/tasks",
        update: "PUT /api/v1/tasks/:id",
        delete: "DELETE /api/v1/tasks/:id",
      },
    },
  });
});

// Error handling
app.use(notFoundHandler);
app.use(errorHandler);

export default app;
```

Create `src/server.ts`:

```typescript
import app from "./app";
import { logger } from "./utils/logger";

const PORT = process.env.PORT || 3000;

// Graceful shutdown handling
process.on("SIGTERM", () => {
  logger.info("SIGTERM signal received: closing HTTP server");
  process.exit(0);
});

process.on("SIGINT", () => {
  logger.info("SIGINT signal received: closing HTTP server");
  process.exit(0);
});

// Handle uncaught exceptions
process.on("uncaughtException", (error) => {
  logger.error("Uncaught Exception", {
    error: error.message,
    stack: error.stack,
  });
  process.exit(1);
});

// Handle unhandled promise rejections
process.on("unhandledRejection", (reason, promise) => {
  logger.error("Unhandled Rejection", { reason, promise });
  process.exit(1);
});

// Start server
app.listen(PORT, () => {
  logger.info(`ðŸš€ Server running on http://localhost:${PORT}`);
  logger.info(`ðŸ“š API Documentation: http://localhost:${PORT}/`);
  logger.info(`ðŸ¥ Health Check: http://localhost:${PORT}/api/v1/health`);
  logger.info(`ðŸŒ Environment: ${process.env.NODE_ENV}`);
});
```

Update `package.json`:

```json
{
  "scripts": {
    "start": "node dist/server.js",
    "dev": "nodemon src/server.ts",
    "build": "tsc",
    "clean": "rm -rf dist"
  }
}
```

### Step 8: Testing the Enhanced Application

Start the application:

```bash
npm run dev
```

Test the enhanced functionality:

```bash
# Register a new user
curl -X POST http://localhost:3000/api/v1/auth/register \
  -H "Content-Type: application/json" \
  -d '{"email": "test@example.com", "password": "Test123", "name": "Test User"}'

# Login to get token
curl -X POST http://localhost:3000/api/v1/auth/login \
  -H "Content-Type: application/json" \
  -d '{"email": "test@example.com", "password": "Test123"}'

# Create a task (use token from login response)
curl -X POST http://localhost:3000/api/v1/tasks \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer YOUR_TOKEN_HERE" \
  -d '{"title": "Enhanced Task", "description": "This task was created with the enhanced application"}'

# Get tasks with search
curl "http://localhost:3000/api/v1/tasks?search=enhanced" \
  -H "Authorization: Bearer YOUR_TOKEN_HERE"

# Test validation error
curl -X POST http://localhost:3000/api/v1/tasks \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer YOUR_TOKEN_HERE" \
  -d '{"title": "Hi"}'
```

## Key Libraries and Concepts Demonstrated

### 1. Essential Middleware Libraries

#### Helmet.js - Security

```typescript
app.use(helmet()); // Sets various HTTP headers for security
```

#### Morgan - HTTP Logging

```typescript
app.use(morgan("combined")); // Logs HTTP requests
```

#### Joi - Input Validation

```typescript
const schema = Joi.object({
  title: Joi.string().min(3).required(),
});
```

### 2. File Organization Patterns

#### Separation of Concerns

- **Routes**: Handle HTTP routing
- **Middleware**: Cross-cutting concerns
- **Utils**: Reusable functions
- **Types**: TypeScript definitions

#### Environment Configuration

```typescript
dotenv.config(); // Load .env file
const port = process.env.PORT || 3000;
```

### 3. Advanced Middleware Patterns

#### Validation Middleware

```typescript
const validate = (schema: Joi.ObjectSchema) => {
  return (req: Request, res: Response, next: NextFunction) => {
    const { error } = schema.validate(req.body);
    if (error) return res.status(400).json({ error });
    next();
  };
};
```

#### Authentication Middleware

```typescript
const authenticateToken = (req: Request, res: Response, next: NextFunction) => {
  const token = req.headers.authorization?.split(" ")[1];
  // Verify token and set req.user
  next();
};
```

### 4. Error Handling Strategy

#### Custom Error Types

```typescript
interface AppError extends Error {
  statusCode?: number;
  isOperational?: boolean;
}
```

#### Global Error Handler

```typescript
const errorHandler = (
  err: AppError,
  req: Request,
  res: Response,
  next: NextFunction
) => {
  // Log error and send appropriate response
};
```

### 5. Logging and Monitoring

#### Structured Logging

```typescript
logger.info("User action", {
  userId: 123,
  action: "create_task",
  metadata: { taskId: 456 },
});
```

## Best Practices Demonstrated

1. **Environment Configuration**: Use `.env` files for configuration
2. **Input Validation**: Validate all incoming data
3. **Error Handling**: Centralized error handling
4. **Security**: Use helmet, proper CORS, input validation
5. **Logging**: Structured logging for debugging and monitoring
6. **Code Organization**: Logical file structure and separation of concerns
7. **TypeScript**: Type safety throughout the application

This enhanced Express application provides a solid foundation for building scalable web APIs while maintaining simplicity and readability.

---

## References and Resources

### Core Libraries

- [Express.js Documentation](https://expressjs.com/)
- [Helmet.js Security](https://helmetjs.github.io/)
- [Morgan Logging](https://github.com/expressjs/morgan)
- [Joi Validation](https://joi.dev/api/)
- [bcryptjs Hashing](https://github.com/dcodeIO/bcrypt.js)
- [jsonwebtoken JWT](https://github.com/auth0/node-jsonwebtoken)

### Environment and Configuration

- [dotenv Documentation](https://github.com/motdotla/dotenv)
- [Node.js Environment Variables](https://nodejs.org/api/process.html#processenv)

### Security Best Practices

- [Express Security Best Practices](https://expressjs.com/en/advanced/best-practice-security.html)
- [OWASP Node.js Security](https://cheatsheetseries.owasp.org/cheatsheets/Nodejs_Security_Cheat_Sheet.html)

### Error Handling

- [Node.js Error Handling](https://nodejs.org/api/errors.html)
- [Express Error Handling](https://expressjs.com/en/guide/error-handling.html)

### TypeScript Resources

- [TypeScript Handbook](https://www.typescriptlang.org/docs/)
- [Express with TypeScript](https://blog.logrocket.com/how-to-set-up-node-typescript-express/)
